\documentclass[twocolumn]{jsbook}
\usepackage{amsmath,amssymb,ascmac,bm}

% Literals
\newcommand{\charlit}[1]{\texttt{#1}}

% Operators and symbols
\newcommand{\applicativefunc}{\bigotimes} % <*>
\newcommand{\bind}{\rightrightarrows} % >>=
\newcommand{\comp}{\bullet} % .
\newcommand{\dollar}{\mathop{\$}} % $
\newcommand{\foldfunc}{\bigsqcup} % foldl
\newcommand{\guard}[1]{\mathop{\mid_{{#1}}}}
\newcommand{\haskelllambda}{\backslash}
\newcommand{\lambdaperiod}{\;.\;}
\newcommand{\listappend}{\mathop{++}}
\newcommand{\mapfunc}{\bigodot} % fmap
\newcommand{\monadfunc}{\bigoplus}
\newcommand{\monadjoin}{\dag}
\newcommand{\monadreturn}{\star} % return
\newcommand{\nullelem}{\emptyset}
\newcommand{\pure}{\bigstar} % pure

% Functions
\newcommand{\concat}{\mathop{\text{concat}}}

% Booleans
\newcommand{\booleankeyword}[1]{\text{#1}}
\newcommand{\falsevalue}{\text{F}}
\newcommand{\truevalue}{\text{T}}

% Typenames
\newcommand{\typename}[1]{\bm{#1}}
\newcommand{\booleantype}{\typename{B}}
\newcommand{\integertype}{\typename{Z}}
\newcommand{\realtype}{\typename{R}}

% Typeclasses
\newcommand{\typeclassname}[1]{\mathcal{#1}}
\newcommand{\functortypeclass}{\typeclassname{F}}

% Functors
\newcommand{\generalcontainer}[1]{\left\langle#1\right\rangle}
\newcommand{\listtype}[1]{\left[#1\right]}
\newcommand{\maybe}[1]{\left\{#1\right\}}
\newcommand{\monad}[1]{\left\langle\!\left\langle#1\right\rangle\!\right\rangle}

% Functor names
\newcommand{\functor}[1]{\mathop{\textbf{#1}}}
\newcommand{\listfunctor}{\mathop{\functor{List}}}
\newcommand{\maybefunctor}{\mathop{\functor{Maybe}}}
\newcommand{\monadfunctor}{\mathop{\functor{Monad}}}

% Kind names
\newcommand{\kindname}[1]{\mathbb{#1}}
\newcommand{\eqkind}{\kindname{E}}
\newcommand{\ordkind}{\kindname{O}}

% Keywords
\newcommand{\haskellkeyword}[1]{\textbf{#1}}
\newcommand{\letinprogram}{\haskellkeyword{let}}
\newcommand{\otherwise}{\haskellkeyword{otherwise}}
\newcommand{\where}{\haskellkeyword{where}}

% Math keywords
\newcommand{\mathkeyword}[1]{\textbf{#1}}
\newcommand{\mathelse}{\mathop{\mathkeyword{else}}}
\newcommand{\mathif}{\mathop{\mathkeyword{if}}}
\newcommand{\maththen}{\mathop{\mathkeyword{then}}}

% Special keywords
\newcommand{\specialkeyword}[1]{\textsf{#1}}
\newcommand{\firstelem}{\specialkeyword{First}}
\newcommand{\identity}{\specialkeyword{id}}
\newcommand{\nothing}{\specialkeyword{Nothing}}
\newcommand{\restelems}{\specialkeyword{Rest}}


\begin{document}

\chapter{思考の道具}

「言語は思考を規定する」という．
実際プログラマは思考の道具としてプログラミング言語をよく用いるし，そのプログラマの好みのプログラミング言語の影響を強く受ける．
手続き的に問題を解くのが好きなプログラマもいれば，宣言的に問題を解くのが好きなプログラマもいる．
問題の複雑さを「オブジェクト」というプログラム単位に押し込むのが好きなプログラマもいれば，「クロージャ」という別のプログラム単位に押し込むのが好きなプログラマもいる．

一方で，古代ギリシャから連綿と続く数学者たちは，数学という言葉で問題を考えることを好む．
数学はわずかな方言の違いを無視すれば驚くほど統一された言語である．

プログラマが使う言葉すなわちプログラミング言語と，数学者たちが使う語はだいたい乖離しており，その両者の歩み寄りは虚しいものであることが多かった．
ここで言いたいのはプログラマが限られた文字セットしか使えないとか，スクリーン上の行という制約に縛られているとか，そのような表面的なことではない．
そうではなく，思考の様式が，プログラミング「文化」と数学「文化」で異なるという意味である．

プログラミング文化と数学文化の大きな違いの一つは，リアルタイムに起こるイベントの取り扱い方法である．
プログラマはほとんどいつもリアルタイムに起こるイベントに対応しないといけない．
一方で，数学者たちはそのようなイベントを「不純なもの」として理論から取り除く．
例えば変数$x$があるときは$0$だがあるときは$1$であるというのは，甚だ不純なものとして数学者の間では認識されるものだ．

\chapter{数学的準備}

この章では今後本書で登場する数学的概念の記法を決めておく．

\section{定数・論理定数・文字定数}

定数はアラビア数字で記述するものとする．
定数が負の場合はマイナス記号($-$)を用いる．
定数が実数の場合は小数点($.$)を用いる場合がある．
例えば $-1, 0, 1.2$ は定数である．

論理定数とは真偽値を表す定数で，真($\truevalue$)及び偽($\falsevalue$)の2種類のみがある．

文字定数とはコード化された文字のことである．
文字コードを定数として扱うといささか読みづらくなるため，該当する文字をシングルクォートで囲むことにする．
例えば `\charlit{A}', `\charlit{b}', `\charlit{.}' は文字定数である．

\section{変数}

変数はアルファベット（ローマ文字またはギリシア文字）の小文字1文字で表すことにする．
変数名には任意個のプライム記号($'$)をつけても良いし，添え字をつけても良いこととする．
変数名はイタリック体で書く．

変数は代入演算子($=$)によって定数や変数，それらを複合した式の値を代入できる．
例えば $$x=1, y=x$$ は代入の例である．

\section{演算子}

演算子には数学記号を割り当てる．
単項演算子には論理否定($\neg$)とマイナス($-$)がある．
本書で扱う単項演算子はこの2種類だけである．

二項演算子のうちよく使われるものは和($+$)，積($\ast$)，論理和($\vee$)，論理積($\wedge$)である．
二項演算子はたとえ積記号であっても省略できない．
二項演算子は多数あるので，その都度説明する．

演算の優先順位を明示的に与えるために括弧が用いられる．

\section{関数}

関数も変数と同じようにアルファベット（ローマ文字またはギリシア文字）の小文字1文字で表すことにする．
関数名には任意個のプライム記号($'$)をつけても良いし，添え字をつけても良いこととする．
三角関数のように十分な知名度を持つ関数や，それに匹敵する汎用的な関数は長い名前を持っても良い．
変数名や関数名はイタリック体で書くが，長い関数名はローマン体で書く．

関数引数には括弧を付けない．我々はよく引数$x$をとる関数$f$を$f(x)$と書くが，括弧は冗長なので今後は$fx$と書くことにする．
引数$x$を関数$f$に「食わせる」ことを関数適用と呼ぶ．

複数引数をとる関数を我々はよく$f(x,y)$と書くが，これも括弧が冗長なので今後は$fxy$と書くことにする．
この場合式$fxy$は左を優先して結合するものとする．つまりいつも$$fxy\equiv (fx)y$$である．
引数に「飢えた」関数$(fx)$を部分適用された関数と呼ぶ．
二項演算子$\equiv$は右辺と左辺が等しい場合に真となる演算子である．

関数は合成できる．関数$f$と関数$g$があって，その合成を$f\comp g$と書くとき$$(f\comp g)x\triangleq f(gx)$$である．
ここに記号$\triangleq$は左辺を右辺で定義するという意味である．
関数合成の演算子$\comp$は関数適用よりも優先順位が高く，$(f\comp g)x$は単に$f\comp gx$と書いても良い．
この記法は括弧の数を減らすためにしばしば用いられる．

関数合成演算子とは逆に，優先順位の低い関数適用演算子も考えておくと括弧の数を減らすのに便利である．
関数適用演算子$\dollar$を次のように定義しておく．
$$f\dollar gx\triangleq f(gx)$$
演算子$\dollar$の優先順位は足し算演算子よりも低いものとする．
よって$f(x+1)$は$f\dollar x+1$と書くこともできる．

二項演算子とは2引数関数の特別な場合であると考えてよい．
関数$r$を次のように中置する記法を定義しておく．
$$x\,{}^\backprime r^\backprime\,y\triangleq rxy$$
バックプライム記号(${}^\backprime$)を使っているのはプライム記号($'$)と区別するためである．

既存の二項演算子$\circ$は次のようにして通常の関数として使えるものとする．
$$(\circ)xy\triangleq x\circ y$$

\section{ラムダ式}

引数$x$をとり値$1+x$を返すラムダ式は次のように書くことにする．
$$\haskelllambda x\rightarrow 1+x$$
この式はチャーチのオリジナルの論文の記法であれば$\Hat x\lambdaperiod 1+x$と書かれたところであり，現在でも多くの書物で$\lambda x\lambdaperiod 1+x$と記述されるところである．
しかし我々はすべてのギリシア文字を変数名のために予約しておきたいのと，ピリオド記号($.$)が関数合成演算子($\comp$)と非常に紛らわしいため，上述の記法を用いる．

ラムダ式を適用するには，ラムダ式を括弧で包む必要がある．
例を挙げる．
$$\left(\haskelllambda x\rightarrow x+1\right)2$$
この式は結果として$3$を返す．

複数引数をとるラムダ式は例えば$$\haskelllambda xy\rightarrow x+y$$のように書く．

\section{関数定義}

ラムダ式を用いた関数の定義が可能である．
例えば引数$x$をとり値$1+x$を返す関数$f$は$$f=\haskelllambda x\rightarrow 1+x$$と定義できる．
この省略形として$$fx=1+x$$と書いても良いし，さらに省略して$$f=(+)1$$と書いても良い．
もちろん$f=+1$でないことに注意しよう．

関数にスペシャルバージョンがある場合は列挙する．
例えば引数が$0$の場合は特別に戻り値も0であり，その他の場合は関数$f$と同じ振る舞いをする関数$f'$を考える．
この時$f'$は次のように定義することになる．
\begin{equation*}
\begin{split}
f'0&=0\\
f'x&=1+x
\end{split}
\end{equation*}

関数定義に場合分けが必要な場合は「ガード」を用いる．
例えば引数の値が負の場合は$-1$を，$0$の場合は$0$を，それ以外の場合は関数$f$と同じ振る舞いをする関数$f''$は
\begin{equation*}
\begin{split}
f''x&\guard{x<0}=-1\\
&\guard{x\equiv0}=0\\
&\guard{\otherwise}=1+x
\end{split}
\end{equation*}
という風に定義することにする．

\section{条件式}

数学者のいう条件式とはスペシャルバージョンやガードを一般化したもので，if節とotherwise節からなるものである．
例を挙げる．
$$fx=\begin{cases}
0&\text{if $x\equiv0$}\\
1+x&\text{otherwise}
\end{cases}$$
この書き方は行を意識せざるをえないプログラミング言語とは相性がよろしくない．
そこで次のように書くものとする．
$$fx=\mathif x\equiv0\maththen0\mathelse 1+x$$

\section{型}

型とは変数が取りうる値に与えた制約のことである．
数学者はしばしば変数$x$が整数であることを$x\in\integertype$のように書くが，我々は記号$\in$を別の用途に使いたいので代わりに記号$::$を使って$$x::\integertype$$と書く事にする．

今我々が考慮しておくべき型は，論理型($\booleantype$)，整数型($\integertype$)，及び実数型($\realtype$)である．
括弧内に示した記号は数学者たちが慣用的に用いているものである．

関数にも型がある．
今は深入りしないが，例えば整数引数を一つ取り，整数を返す関数は$$\integertype\rightarrow\integertype$$という型を持つ．

\section{リスト}

同じ型の値を一列に並べたものはリストである．
例えば0から始まり10まで続く整数のリストは$[0,1,2,3,4,5,6,7,8,9,10]$と書く．
等差数列に限って，簡略化した書き方が許されるものとする．
0から10までのリストは$[0,1\dotsb10]$と書いても良い．

より高度なリスト，例えば0から10までの平方数のリストは$$\left[x^2\guard{x\in[0,1\dotsb 10]}\right]$$のようにガードを用いて書く．
ガードは複数条件をカンマ($,$)で区切って書いて良い．
例えば$$\left[x+y\guard{x\in[0,1\dotsb 10],\,y\in[0,1\dotsb 5],\,x+y>3}\right]$$は$0\le x\le 10$かつ$0\le y\le 5$の範囲で$x+y>3$となる$x$及び$y$から$x+y$を並べたリストである．

リストは結合できる．例えばリスト$l$とリスト$m$を結合したリストは$$l\listappend m$$で得られる．

リストは無限個の要素を持っても良い．
例えば自然数全体を表すリスト$n$は$$n=[1,2\dotsb]$$のように定義して良い．

空リストは$\emptyset$または$[\,]$で表す．

型$\typename{a}$のリストの型は$[\typename{a}]$で表す．
ある型を包み込んだ別の型を一般にコンテナ型と呼ぶ．

\section{タプル}

複数の変数を束ねたものをタプルと呼ぶ．
変数$x$と変数$y$からなるタプルは$(x,y)$と書く．
いま$$t=(x,y)$$としたとき，タプルの中身を取り出すには$$(t_1,t_2)=t$$のようにしてパタンマッチングを用いる．

\section{リストの実装}

ここでリストの実装について若干述べておかねばならない．
紙上ではリストは自由に考えられるが，計算機上ではそれほど自由ではないからである．
ここではリストはLISPにおけるリストと同じ構造を持つものとする．
LISPにおけるリストとは要素$\firstelem$と要素$\restelems$からなる「ペア」の集合である．
要素$\firstelem$がリストの要素を持ち，要素$\restelems$が次のペアを「参照」する．
リストの最後のペアの$\restelems$は空リストを参照する．

これらのペアはタプルで実装したいところだが，参照，逆参照の煩雑さを避けるために，リストのための特別な表現$$\firstelem:\restelems$$を用い，第2要素である$\restelems$はリスト型であるとする．
演算子$:$は結合演算子と呼ぶ．

要素$\restelems$はリスト（または空リスト）であるから，一般にリストは次のように展開できることになる．
\begin{align*}
[x_0,x_1,x_2\dotsb x_n]&=x_0:[x_1,x_2\dotsb x_n]\\
&=x_0:x_1:[x_2\dotsb x_n]\\
&=x_0:x_1:x_2:\dotsb:x_n:[\,]
\end{align*}
結合演算子$:$は右結合する．
すなわち$$x_0:x_1:x_2\equiv x_0:(x_1:x_2)$$である．

\chapter{型・型クラス・種}

\section{関数の型}

$$f::\integertype\rightarrow\integertype$$

関数$f$が引数として整数を2個取り1個の整数を返す時，その型は$$\integertype\rightarrow\integertype\rightarrow\integertype$$である．
型の式は右結合するものとする．
従って上式は$$\integertype\rightarrow\left(\integertype\rightarrow\integertype\right)$$と読む．
これは関数$f$が最初の引数を1個受け取り，$(\integertype\rightarrow\integertype)$型の関数を返していることを考えると理にかなっている表現である．

\section{型クラス}

\section{種}

$$\integertype\subset\eqkind$$

$$\integertype\subset\ordkind$$

\chapter{マップ}

\section{畳み込み}

我々はよくリストの総和を表現するためにシグマ記号($\sum$)を使う．
リスト$$l=\listtype{l_0,l_1\dotsb l_n}$$がある時，その総和を$$\sum l\triangleq l_0+l_1+\dotsb+l_n$$であるようなシグマ記号である．
この表現を一般化してみよう．
リスト$\listtype{l_0,l_1\dotsb l_n}$が与えられた時，$$\foldfunc^\circ_a\listtype{l_0,l_1\dotsb l_n}\triangleq a\circ l_0\circ l_1\circ\dotsb\circ l_n$$であると定義する．
この新しい記号$\foldfunc$は畳み込み演算子と呼ばれる．

リストの総和をとる演算子$\sum$は$$\sum=\foldfunc^+_0$$とすれば得られる．
同じようにリストの要素のすべての関をとる演算子$\prod$は$$\prod=\foldfunc^\ast_1$$とすれば得られる．

畳み込み演算子は第1引数（演算子の上）に二項演算子，第2引数（演算子の下）にスカラー，第3引数（演算子の右）にリストを取り，スカラーを返す．
第1引数の二項演算子が取る引数型と第2引数のスカラーの型，第3引数のリストの要素の型，戻り値の型は全て一致していなければならない．
この型を$\typename{a}$とすると，畳み込み演算子の型を$$\foldfunc::(\typename{a}\rightarrow\typename{a}\rightarrow\typename{a})\rightarrow\typename{a}\rightarrow\listtype{\typename{a}}\rightarrow\typename{a}$$と定義できる．


\section{マップ}

畳み込みではなく，リストはリストのままにして，各要素に決まった関数を適用したい場合がある．
引数として関数$f$とリスト$[l_0,l_1\dotsb l_n]$を取り，戻り値として$[fl_0,fl_1\dotsb fl_n]$を返す演算子$\mapfunc_\text{list}$を考えよう．
この時$$\mapfunc^f_\text{list}[l_0,l_1\dotsb l_n]\triangleq [fl_0,fl_1\dotsb fl_n]$$であると定義する．
リストのマップ演算子$\mapfunc_\text{list}$は$$\mapfunc_\text{list}::(\typename{a}\rightarrow\typename{b})\rightarrow\listtype{\typename{a}}\rightarrow\listtype{\typename{b}}$$という型を持つ．


\section{一般化マップ}

マップ演算子の概念を一般化してみよう．
マップ演算子はあるコンテナの中身に関数適用を行い，元のコンテナと同じコンテナを返す演算子であると考えることができる．
そこで，今後マップ演算子の右引数は一般のコンテナであるとする．
型$\typename{a}$をコンテナに入れた型を一般に$\generalcontainer{\typename{a}}$と書くことにすると，一般化されたマップ演算子$\mapfunc$は$$\mapfunc::(\typename{a}\rightarrow\typename{b})\rightarrow\generalcontainer{\typename{a}}\rightarrow\generalcontainer{\typename{b}}$$という型を持つ．

一般化マップはマップが使えるところではいつでも置き換えて使える．
つまり我々は$\mapfunc_\text{list}$を使わずに，最初から$\mapfunc$を使えば良いのである．

一般化マップの型は$\typename{a}\rightarrow\typename{b}$をとり$\generalcontainer{\typename{a}}\rightarrow\generalcontainer{\typename{b}}$を返しているようにも見える．
それゆえ一般化マップを用いることを関数の「持ち上げ(lifting)」と呼ぶのである．

\section{Maybe}

整数$x$を$0$で除算することはエラーである．
しかし除算の度にエラーが起こったかどうか調べるのは面倒であるし，記述も煩雑になってしまう．
プログラマはよくこういう場合に「例外」という機構を用いるが，数学に例外は持ち込みたくない．
そこで変数$x$が正しく計算されたかもしれないし，されていないかもしれないということを，特別な記号$\maybe{x}$で表しておこう．
ここで変数$\maybe{x}$が取り得る値は正しく計算された値$x$か，あるいはエラーを表す値$\nothing$である．

この変数$\maybe{x}$はもはや整数型とは言えない．
そこでこの$\maybe{x}$の型を$\maybe{\integertype}$と表して「きっと整数」型と呼ぶことにしよう．
英語では ``maybe integer'' と呼ぶ．

変数$x$が一度$0$除算の危険性に汚染された場合，その後ずっと$\maybe{x}$と印をつけられなければならない．
このきっと整数$\maybe{x}$に対して整数を引数にとる関数$f$を適用させるには，一般化マップ演算子が必要である．
具体的には$$\mapfunc^f\maybe{x}$$のように関数$f$を「持ち上げて」から変数$\maybe{x}$に適用させる．
その結果はまた$\maybe{\integertype}$型である．
従って，結果を受け取る変数も$\maybe{\integertype}$でなければならず，それを忘れないように印を付けておかねばならない．
例えば$$\maybe{y}=\mapfunc^f\maybe{x}$$のように書くことになるであろう．

\section{関手}

ある型から，マップの右引数になれる型を作る射（一般化された写像）のことを関手と呼ぶ．
例えば型$\typename{a}$からリスト型$[\typename{a}]$を作る射$\listfunctor$ただし$$\listfunctor\typename{a}=\typename{a}\mapsto\listtype{\typename{a}}$$は関手である．
また型$\typename{a}$から ``maybe a'' 型$\maybe{\typename{a}}$を作る射$\maybefunctor$ただし$$\maybefunctor\typename{a}=\typename{a}\mapsto\maybe{\typename{a}}$$も関手である．
一般に$$\typename{a}\mapsto\generalcontainer{\typename{a}}$$という風に型$\typename{a}$をコンテナに入れて型$\generalcontainer{\typename{a}}$を作る射を関手と呼ぶ．

関手全体の集合を$\functortypeclass$で表す．
これまでに見た関手は$$\listfunctor,\maybefunctor::\functortypeclass$$である．

\section{関手が従う規則}

\begin{align}
\mapfunc^\identity&=\identity\\
\mapfunc^{\functor{f}\comp\functor{g}}&\equiv\mapfunc^{\functor{f}}\comp\mapfunc^{\functor{g}}
\end{align}


\section{一般化マップの一般化}

一般化マップとは$$\mapfunc::(\typename{a}\rightarrow\typename{b})\rightarrow\generalcontainer{\typename{a}}\rightarrow\generalcontainer{\typename{b}}$$のことであった．
一般化マップの第1引数である1引数関数がコンテナに入っている場合を想定しよう．
そうすると次のような「一般化された」一般化マップ$\applicativefunc$を考えることができる．
$$\applicativefunc::\generalcontainer{(\typename{a}\rightarrow\typename{b})}\rightarrow\generalcontainer{\typename{a}}\rightarrow\generalcontainer{\typename{b}}$$
実際の使い方は$$\listtype{y_0,y_1\dotsb y_{n''}}=\applicativefunc^{\listtype{f_0,f_1\dotsb f_n}}\listtype{x_0,x_1\dotsb x_{n'}}$$のようになるであろう．

\section{アプリカティブ}

一般化一般化マップ演算子$\applicativefunc$と次のピュア演算子$\pure$があれば，リストもMaybeも同じ枠組みで考えることができる．
ピュア演算子$\pure$は$$\pure::\typename{a}\rightarrow\generalcontainer{\typename{a}}$$という型を持つ．
関手の型$\typename{a}\mapsto\generalcontainer{\typename{a}}$とは矢印が違う事に注意しよう．
ピュア演算子は型を型へ変換するのではなく，変数をコンテナに入れられた別な変数へと変換する．

リストの場合，ピュア演算子と一般化一般化マップは次のように実装することができる．
\begin{align*}
\pure x&=\listtype{x}\\
\applicativefunc^{\listtype{f_0,f_1\dotsb f_n}}\listtype{x_0,x_1\dotsb x_{n'}}&=\listtype{fx\guard{f\in\listtype{f_0,f_1\dotsb f_n},x\in\listtype{x_0,x_1\dotsb x_{n'}}}}
\end{align*}

Maybeの場合は次のようにピュア演算子と一般化一般化マップを実装することができる．
\begin{align*}
\pure x&=\maybe{x}\\
\applicativefunc^{\nothing}\maybe{x}&=\nothing\\
\applicativefunc^{\maybe{f}}\maybe{x}&=\mapfunc^f\maybe{x}
\end{align*}

% IO: skip.

% Function:
% \begin{align*}
% \pure x&=\haskelllambda y\rightarrow x\\
% \applicativefunc^fg&=\haskelllambda x\rightarrow fx(gx)
% \end{align*}

\section{アプリカティブが従う規則}

$$\applicativefunc^{\pure f}x\equiv\mapfunc^fx$$

\section{モナド}

ある型$\typename{a}$について，特殊なコンテナ$\monad{\typename{a}}$に入れられた型を想像してほしい．
この型にもマップ演算子があり$$\monadfunc::(\typename{a}\rightarrow\monad{\typename{b}})\rightarrow\monad{\typename{a}}\rightarrow{\typename{b}}$$という型を持っているとする．
このマップ演算子は第1引数（上）として型$\typename{a}$をとりコンテナに収めた型$\monad{\typename{b}}$を返す関数を，第2引数（右）としてコンテナに収められた型$\monad{\typename{a}}$をとり，戻り値として「生の」型$\typename{b}$を返す．

型$\typename{a}$から型$\monad{\typename{a}}$を作り出す関手を$\monadfunctor$とし$$\monadfunctor\typename{a}=\typename{a}\mapsto\monad{\typename{a}}$$とする．
$\typename{a}$型の変数から$\monad{\typename{a}}$型の変数を作る演算子を$\monadreturn$とする．

Maybeの方がリストよりも簡単なので，Maybeから説明する．
Maybeの場合は次のような実装となる．
\begin{align*}
\monadreturn x&=\maybe{x}\\
\monadfunc^f\nothing&=\nothing\\
\monadfunc^f\maybe{x}&=fx
\end{align*}
ここに関数$f$は$$f::\typename{a}\rightarrow\monad{\typename{b}}$$であるから，関数適用された値$fx$は$$fx::\monad{\typename{b}}$$という型を持つことに注意しよう．

% ---
% 
% $$\bind\,::\monad{\typename{a}}\rightarrow(\typename{a}\rightarrow\monad{\typename{b}})\rightarrow\monad{\typename{b}}$$
% 
% Maybe:
% \begin{align*}
% \monadreturn x&=\maybe{x}\\
% \nothing\bind f&=\nothing\\
% \maybe{x}\bind f&=fx
% \end{align*}
% 
% ---

リストの場合は次のような実装となる．
\begin{align*}
\monadreturn x&=\listtype{x}\\
\monadfunc^f\listtype{x_0,x_1\dotsb x_n}&=\concat\mapfunc^f\listtype{x_0,x_1\dotsb x_n}
\end{align*}
関数$\concat$はリストのリスト$$\listtype{\listtype{x_0,x_1\dotsb x_n},\listtype{y_0,y_1\dotsb y_n}\dotsb}$$をフラットなリスト$$\listtype{x_0,x_1\dotsb x_n,y_0,y_1\dotsb y_n\dotsb}$$へと変換する．

% List:
% \begin{align*}
% \monadreturn x&=\listtype{x}\\
% \listtype{x_0,x_1\dotsb x_n}\bind f&=\concat\mapfunc^f\listtype{x_0,x_1\dotsb x_n}
% \end{align*}

% Function:
% \begin{align*}
% \monadreturn x&=\haskelllambda y\rightarrow x\\
% g\bind f&=\haskelllambda h\rightarrow f(gh)h
% \end{align*}


\section{モナド則}

新しい演算子$\triangleleft$を$$(f\triangleleft g)x\triangleq\monadfunc^f(gx)$$として導入する．
モナドは次の規則に従う．
\begin{align}
f\triangleleft\monadreturn&=f\\
\monadreturn\triangleleft f&=f\\
(f\triangleleft g)\triangleleft h&=f\triangleleft(g\triangleleft h)
\end{align}

---

$$(f\triangleright g)x\triangleq(fx)\bind g$$
\begin{align}
\monadreturn\triangleright f&=f\\
f\triangleright\monadreturn&=f\\
(f\triangleright g)\triangleright h&=f\triangleright(g\triangleright h)
\end{align}

\begin{align}
\monadreturn x\bind f&=fx\\
\monad{x}\bind\monadreturn&=\monad{x}\\
(\monad{x}\bind f)\bind g&=\monad{x}\bind(\haskelllambda x'\rightarrow(fx'\bind g))
\end{align}

Or,
\begin{align}
\monadfunc^f(\monadreturn x)&=fx\\
\monadfunc^\monadreturn\monad{x}&=\monad{x}\\
\monadfunc^g\left(\monadfunc^f\monad{x}\right)&=\monadfunc^{\haskelllamda x'\rightarrow\left(\monadfunc^gfx'\right)}\monad{x}
\end{align}

Memo.
\begin{align*}
\monadjoin\monad{\monad{x}}&\triangleq\monad{x}\\
\mapfunc^f\monad{x}&=\monad{x}\bind(\monadreturn\comp f)\\
\monadjoin\monad{x}&=\monad{x}\bind\identity\\
\monad{x}\bind f&\triangleq\monadjoin\mapfunc^f\monad{x}\\
\monadreturn\comp f&\triangleq\mapfunc^f\comp\monadreturn\\
\monadjoin\comp\mapfunc^\monadjoin&\triangleq\monadjoin\comp\monadjoin\\
\monadjoin\comp\mapfunc^\monadreturn&\triangleq\monadjoin\comp\monadreturn=\identity\\
\monadjoin\comp\mapfunc^{\mapfunc^f}&\triangleq\mapfunc^f\comp\monadjoin
\end{align*}

\chapter{プログラミング}

letとwhere.

乱数．


\end{document}
