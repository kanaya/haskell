\documentclass[twocolumn]{jsbook}
\usepackage{amsmath,amssymb,ascmac,bm,multirow,fancyvrb,makeidx}
\makeindex

\title{プログラマのための代数構造}
\author{Ichi Kanaya}
\date{2016}

\def\[{[\![}
\def\]{]\!]}
% \def\keyword#1{#1\index{#1}}

\newcommand{\cxx}{\textrm{C}\texttt{++}}

\newcommand{\keyword}[1]{\underline{\emph{#1}}}

\newcommand{\code}[1]{\texttt{#1}}
\newenvironment{leader}{\begingroup\bf}{\endgroup}
\newenvironment{point}{\begin{screen}}{\end{screen}}
\newenvironment{cxxcode}{\begin{itembox}[r]{\cxx}}{\end{itembox}}
\newenvironment{javacode}{\begin{itembox}[r]{\textsl{Java}}}{\end{itembox}}
\newenvironment{pythoncode}{\begin{itembox}[r]{\textsl{Python}}}{\end{itembox}}
\newenvironment{rubycode}{\begin{itembox}[r]{Ruby}}{\end{itembox}}
\newenvironment{python}{\begin{tabbing}\hspace*{1em}\=\hspace*{1em}\=\hspace*{1em}\=\hspace*{1em}\=\kill}{\end{tabbing}}

% \newenvironment{footnotecode}{\begin{Verbatim}[xleftmargin=10mm]}{\end{Verbatim}}

\newcommand{\pthnKeyword}[1]{\textbf{#1}}
\DeclareMathOperator{\pthnDef}{\pthnKeyword{def}}
\DeclareMathOperator{\pthnElse}{\pthnKeyword{else}}
\DeclareMathOperator{\pthnFor}{\pthnKeyword{for}}
\DeclareMathOperator{\pthnIf}{\pthnKeyword{if}}
\DeclareMathOperator{\pthnIn}{\pthnKeyword{in}}
\DeclareMathOperator{\pthnLambda}{\pthnKeyword{lambda}}
\DeclareMathOperator{\pthnMap}{map}
\DeclareMathOperator{\pthnPrint}{print}
\DeclareMathOperator{\pthnReturn}{\pthnKeyword{return}}
\DeclareMathOperator{\pthnRange}{range}
\DeclareMathOperator{\pthnReduce}{reduce}
\DeclareMathOperator{\pthnUp}{**}

\newcommand{\pthnNextLine}{$\blacktriangleright\blacktriangleright$}

\newcommand{\hsklType}[1]{\textbf{#1}}
\newcommand{\hsklTypeclass}[1]{\mathsf{#1}}
\newcommand{\hsklTypeConstructor}[1]{\mathop{\mathrm{#1}}}

\DeclareMathOperator{\hsklApplicativeApply}{\S}
\DeclareMathOperator{\hsklApplicativeMap}{\times}
\DeclareMathOperator{\hsklApplicativeListMap}{\otimes}
\DeclareMathOperator{\hsklApplicativeMaybeMap}{\boxtimes}
\DeclareMathOperator{\hsklConcat}{\flat}
\DeclareMathOperator{\hsklFmap}{\cdot}
\DeclareMathOperator{\hsklHead}{head}
\DeclareMathOperator{\hsklListConstructor}{\hsklTypeConstructor{List}}
\DeclareMathOperator{\hsklMap}{\odot}
\DeclareMathOperator{\hsklMaybeConstructor}{\hsklTypeConstructor{Maybe}}
\DeclareMathOperator{\hsklMaybeAppend}{\boxplus}
\DeclareMathOperator{\hsklMaybeMap}{\boxdot}
\DeclareMathOperator{\hsklMonadMap}{\heartsuit}
\DeclareMathOperator{\hsklOf}{::}
\DeclareMathOperator{\hsklPred}{pred}
\DeclareMathOperator{\hsklSucc}{succ}
\DeclareMathOperator{\hsklTail}{tail}

\newcommand{\hsklAppend}{\oplus}
\newcommand{\hsklApplicative}{\hsklTypeclass{Applicative}}
\newcommand{\hsklBool}{\hsklType{Bool}}
\newcommand{\hsklChar}{\hsklType{Char}}
\newcommand{\hsklEmptyList}{\emptyset}
\newcommand{\hsklEnum}{\hsklTypeclass{Enum}}
\newcommand{\hsklInt}{\hsklType{Int}}
\newcommand{\hsklIntegral}{\hsklTypeclass{Integral}}
\newcommand{\hsklEq}{\hsklTypeclass{Eq}}
\newcommand{\hsklFloat}{\hsklType{Float}}
\newcommand{\hsklFunctor}{\hsklTypeclass{Functor}}
\newcommand{\hsklMonad}{\hsklTypeclass{Monad}}
\newcommand{\hsklMonadplus}{\hsklTypeclass{Monadplus}}
\newcommand{\hsklMonoid}{\hsklTypeclass{Monoid}}
\newcommand{\hsklNothing}{\varnothing}
\newcommand{\hsklNum}{\hsklTypeclass{Num}}
\newcommand{\hsklOrd}{\hsklTypeclass{Ord}}
\newcommand{\hsklReal}{\hsklTypeclass{Real}}

\newcommand{\hsklFunction}[1]{\Hat{#1}}
\newcommand{\hsklJust}[1]{\[#1\]}
\newcommand{\hsklList}[1]{\Bar{#1}}
\newcommand{\hsklListType}[1]{\boldsymbol{[}#1\boldsymbol{]}}
\newcommand{\hsklMaybe}[1]{\Tilde{#1}}
\newcommand{\hsklMaybeW}[1]{\widetilde{#1}}
\newcommand{\hsklMaybeType}[1]{\boldsymbol{\[}#1\boldsymbol{\]}}
\newcommand{\hsklPure}[1]{\langle#1\rangle_\textsf{pure}}
\newcommand{\hsklUnit}[1]{\langle#1\rangle_\textsf{unit}}

\newcommand{\hsklTypeConstruct}[2]{#1\,#2}

\newcommand{\mathKeyword}[1]{\mathbf{#1}}
\newcommand{\mathVarKeyword}[1]{\mathsf{#1}}

\DeclareMathOperator{\mathAnyBinaryOperator}{\bigstar}
\DeclareMathOperator{\mathInverse}{\sharp}
\DeclareMathOperator{\mathAnd}{\wedge}
\DeclareMathOperator{\mathApply}{\$}
\DeclareMathOperator{\mathAnyUnaryOperator}{\star}
\DeclareMathOperator{\mathCompose}{\bullet}
\DeclareMathOperator{\mathI}{i}
\DeclareMathOperator{\mathIn}{::}
\DeclareMathOperator{\mathElse}{\mathKeyword{else}}
\DeclareMathOperator*{\mathFold}{\bigcup}
\DeclareMathOperator*{\mathFoldRight}{\bigsqcup}
\DeclareMathOperator{\mathFrom}{\in}
\DeclareMathOperator{\mathIf}{\mathKeyword{if}}
\DeclareMathOperator{\mathLambda}{\backslash}
\DeclareMathOperator{\mathMapsTo}{\mapsto}
\DeclareMathOperator{\mathOr}{\vee}
\DeclareMathOperator{\mathSetTimes}{\circledast}
\DeclareMathOperator{\mathThen}{\mathKeyword{then}}

\newcommand{\mathFirst}{\mathVarKeyword{First}}
\newcommand{\mathLambdaAnonymousParameter}{\lozenge}
\newcommand{\mathLambdaArrow}{\rightarrow}
\newcommand{\mathLeft}{\mathKeyword{left}}
\newcommand{\mathOtherwise}{\mathKeyword{otherwise}}
\newcommand{\mathRest}{\mathVarKeyword{Rest}}
\newcommand{\mathRight}{\mathKeyword{right}}
\newcommand{\mathSomething}{\square}

\newcommand{\mathFunctor}[1]{\mathrm{#1}}
\newcommand{\mathGuard}[1]{\mathop{\mid_{#1}}}
\newcommand{\mathSet}[1]{\mathbf{#1}}
\newcommand{\mathSpecialSet}[1]{\mathbb{#1}}
\newcommand{\mathVector}[1]{\vec{#1}}

\newcommand{\mathCategoryShort}[2]{(#1,#2)}
\newcommand{\mathLambdaExpression}[2]{\mathLambda#1\mathLambdaArrow#2}
\newcommand{\mathMorph}[2]{#1\mathMapsTo#2}

\newcommand{\mathMonoid}[3]{(#1,#2,#3)}
\newcommand{\mathMorphII}[3]{#1\mathMapsTo#2\mathMapsTo#3}
\newcommand{\mathMorphIIWithParenthesis}[3]{#1\mathMapsTo(#2\mathMapsTo#3)}

\newcommand{\mathCategory}[4]{(#1,#2,#3,#4)}
\newcommand{\mathGroup}[4]{(#1,#2,#3,#4)}
\newcommand{\mathMorphIII}[4]{#1\mathMapsTo#2\mathMapsTo#3\mathMapsTo#4}

\newcommand{\mathField}[7]{(#1,#2,#3,#4,#5,#6,#7)}

\begin{document}
\maketitle
\tableofcontents

\begin{table*}
\caption{凡例}
\begin{center}
\begin{tabular}{||c|c|c||}
\hline
種類&字体・表記法&例\\
\hline
変数&イタリック体，小文字（1文字）&$x$, $y$\\
関数&イタリック体，小文字（1文字）&$f$, $g$\\
定数&イタリック体，大文字（1文字）&$I$, $T$\\
特別な関数&ローマン体，小文字で始める&$\hsklSucc$, $\hsklPred$\\
キーワード&ボールド体，小文字で始める&$\mathIf$, $\mathOtherwise$\\
特別な集合&ブラックボード体&$\mathSpecialSet{R}$, $\mathSpecialSet{Q}$, $\mathSpecialSet{Z}$\\
集合と型&ボールド体，大文字で始める&$\mathSet{S}$, $\hsklInt$\\
型パラメタ&ボールド体，小文字（1文字）&$\hsklType{a}$, $\hsklType{b}$\\
関手と型コンストラクタ&ローマン体，大文字で始める&$\mathFunctor{F}$, $\hsklListConstructor$\\
型クラス&サンセリフ体，大文字で始める&$\hsklEq$, $\hsklIntegral$\\
\hline
リスト&ブラケットで包む&$[x,y,z]$\\
集合&ブレースで包む&$\{x,y,z\}$\\
組み合わせ（タプル）&丸括弧で包む&$(x,y,z)$\\
% \hline
% リスト変数&名前にバーをつける&$\hsklList{x}$\\
% Maybe変数&名前にチルダをつける&$\hsklMaybe{x}$\\
% 関数変数&名前にハットをつける&$\hsklFunction{x}$\\
% ベクトル変数&名前に矢印をつける&$\mathVector{x}$\\
% \hline
% コード&タイプライタ体&\texttt{1+x}\\
\hline
\end{tabular}
\end{center}
\end{table*}

\part{代数的構造とプログラミング}

\chapter{はじめに}

Haskellというプログラミング言語を知ろうとすると，従来のプログラミング言語の知識が邪魔をする．モダンで，人気があって，Haskellから影響を受けた言語，例えばRubyやSwiftの知識さえ，Haskellを学ぶ障害になり得る．ではどのようにしてHaskellの深みに到達すればいいのだろうか．

その答えは，一見遠回りに見えるが，一度抽象数学の高みに登ることである．

と言っても，あわてる必要はない．

近代的なプログラミング言語を知っていれば，すでにある程度抽象数学に足を踏み入れているからである．

そこで，本書では近代的なプログラマを対象に，プログラミング言語を登山口に抽象数学の山を登り，その高みからHaskellという海を見下ろすことにする．

さて，登山口にどのプログラミング言語を選ぶのが適当であろうか．IEEE Spectrum による ``The 2015 Top Ten Programming Languages'' という記事によると「ビッグファイブ」として Java, C, \cxx, Python, C\texttt{\#} が挙げられている．そこで本書では，多くのプログラマが読めて，シンプルに記述ができ，なおかつHaskellと対極にある言語であるPython（バージョン3）を登山口に選ぶことにした．Pythonコードはこのように登場する．
\begin{pythoncode}
\begin{Verbatim}
print("Hello, world.")
\end{Verbatim}
% \begin{python}
% $\pthnPrint(\texttt{"Hello, world."})$
% \end{python}
\end{pythoncode}
本文中に登場するPythonコードは文字通り打ち込めばそのまま使える．
% が，比較演算子$\equiv$だけはキーボードにない記号なので\code{==}に置き換えてもらいたい．

また，一部の章でどうしても型に触れないといけない部分がある．Pythonは動的型付け言語であり，型の説明には不適切であるため，この部分だけ理解の助けとしてJavaによるコードを例示した．この部分はコードを読まなくても先に進める．

本書は3部構成になっている．第I部はプログラミング言語から抽象数学への登山である．第II部は抽象数学の山頂からHaskellの丘へ下っていく道である．第III部はこれまで歩いた道全体を俯瞰する．

第I部は対応するHaskellのコードを脚注に記載している．脚注部分はHaskellを一通り覚えた後で読み返してもらいたい．\footnote{Haskellのコードも\code{x = 1}のようにタイプライタ体で書く．}

\chapter{関数*}
\begin{leader}
プログラムはひとつの関数であり，その関数はいくつかの部分的な関数から合成される．
つまり，関数はプログラムの全体であり，またビルディングブロックである．
プログラムという関数をより小さな関数の合成で作るのは，それらの小さな関数が他のプログラムに再利用されることを期待するためである．
このように関数と関数の合成はプログラミングの中心的な概念である．
% プログラミング言語Cは，プログラムが関数だけからでも構成できることを示した．
% Pascalの「手続き」はCでは値を返さない関数であり，Pascalの「本文」はmainという名前の関数である．
\end{leader}


\section{Pythonの関数*}

関数引数には括弧を付けない．Pythonでは引数$x$をとる関数$f$を
\begin{pythoncode}
\begin{python}
$f(x)$
\end{python}
\end{pythoncode}
と書くが，括弧は冗長なので今後は$fx$と書くことにする．引数$x$を関数$f$に「食わせる」ことを\keyword{関数適用}と呼ぶ．もし$ab$と書いてあっても，それは$a*b$ではなくて従来の$a(b)$すなわち関数$a$に引数$b$を与えているものと解釈する．\footnote{Haskellでは関数\code{f}に引数\code{x}を適用させることを \code{f x} と書く．}

複数引数をとる関数をPythonでは
\begin{pythoncode}
\begin{python}
$g(x,y)$
\end{python}
\end{pythoncode}
と書くが，これも括弧が冗長なので今後は$gxy$と書くことにする．この場合式$gxy$は左を優先して結合するものとする．つまり$$gxy=(gx)y$$である．引数に「飢えた」関数$(gx)$を\keyword{部分適用}された関数と呼ぶ．

このように式の左側を優先的に演算していくことを\keyword{左結合}と呼ぶ．関数適用は左結合である．他に式の右側を優先的に演算する\keyword{右結合}の演算子も存在する．



\section{関数$=$ラムダ式*}

引数$x$をとり値$1+x$を返す\keyword{ラムダ式}をPythonでは
\begin{pythoncode}
\begin{python}
$\pthnLambda x:1+x$
\end{python}
\end{pythoncode}
と書くが，我々は$$\mathLambdaExpression{x}{1+x}$$のように書くことにする．
この式はラムダ式を発明したチャーチのオリジナルの論文の記法であれば$\Hat x\,.\,1+x$と書かれたところであり，現在でも多くの書物で$\lambda x\,.\,1+x$と記述されるところである．
しかし我々はすべてのギリシア文字を変数名のために予約しておきたいのと，ピリオド記号($.$)が今後登場する二項演算子$\cdot$と紛らわしいため，上述の記法を用いる．\footnote{Haskellではこのラムダ式を \code{\textbackslash x -> 1 + x} と書く．}

ラムダ式は関数である．
ラムダ式を適用するには，ラムダ式を括弧で包む必要がある．
例を挙げる．
$$\left(\mathLambdaExpression{x}{1+x}\right)2$$
この式は結果として$3$を返す．

複数引数をとるラムダ式は例えば$$\mathLambdaExpression{xy}{x+y}$$のように引数を並べて書く．

本書では新たに，次のラムダ式記法も導入する．
式中に記号$\mathLambdaAnonymousParameter$が現れた場合，その式全体がラムダ式であるとみなす．
記号$\mathLambdaAnonymousParameter$の部分には引数が入る．
第$n$番目の$\mathLambdaAnonymousParameter$には第$n$番目の引数が入る．
例えばラムダ式$\mathLambdaExpression{xy}{x+y}$は$$\mathLambdaAnonymousParameter+\mathLambdaAnonymousParameter$$と書いても良い．
式を左から読んで1番目の$\mathLambdaAnonymousParameter$が元々の$x$すなわち第1引数を，2番目の$\mathLambdaAnonymousParameter$が元々の$y$すなわち第2引数を意味する．この省略記法はプログラミング言語Schemeにおけるcutプロシジャに由来する．\footnote{この記法はHaskellにはない．}

let, where.


\section{関数適用と関数定義*}

\keyword{関数}$fx=1+x$の定義はPythonでは
\begin{pythoncode}
\begin{python}
$\pthnDef f(x):$\\
\>$\pthnReturn1+x$
\end{python}
\end{pythoncode}
のように書くことが普通である．これは，ある値をとってある値を返す関数の記述方法としてはいささかオーバーキルである．事実，ラムダ式を用いた
\begin{pythoncode}
\begin{python}
$f=\pthnLambda x:1+x$
\end{python}
\end{pythoncode}
も全く同じ意味になる．

関数の定義は，基本的にはラムダ式の変数への代入である．引数$x$をとり値$1+x$を返す関数$f$は$$f=\mathLambdaExpression{x}{1+x}$$と定義できる．ただし，この省略形として$$fx=1+x$$と書いても良いし，さらに省略して$$f=(+)1$$と書いても良い．もちろん$f=+1$でないことに注意しよう．\footnote{Haskellでは$f=\mathLambdaExpression{x}{1+x}$を\code{f = \textbackslash x -> 1 + x}，$fx=1+x$を\code{f x = 1 + x}，$f=(+)1$を\code{f = (+)1}のように書く．}

関数に\keyword{スペシャルバージョン}がある場合はそれらを列挙する．例えば引数が$0$の場合は特別に戻り値も$0$であり，その他の場合は関数$f$と同じ振る舞いをする関数$f'$を考える．このとき$f'$は
\begin{equation*}
\left\{
\begin{split}
f'0&=0\\
f'x&=1+x
\end{split}
\right.
\end{equation*}
ように定義することになる．\footnote{Haskellでは
\begin{Verbatim}[xleftmargin=10mm]
f' 0 = 0
f' x = 1+x
\end{Verbatim}
と書く．}

関数定義に\keyword{場合分け}が必要な場合は\keyword{ガード}を用いる．例えば引数の値が負の場合は$-1$を，$0$の場合は$0$を，それ以外の場合は関数$f$と同じ振る舞いをする関数$f''$は
\begin{equation*}
\begin{split}
f''x&\mathGuard{x<0}=-1\\
&\mathGuard{x\equiv 0}=0\\
&\mathGuard{\mathOtherwise}=1+x
\end{split}
\end{equation*}
という風に定義する．\footnote{Haskellでは
\begin{Verbatim}[xleftmargin=10mm]
f'' x | x<0       = -1
      | x==0      = 0
      | otherwise = 1+x
\end{Verbatim}
と書く．}

関数のスペシャルバージョン，場合分けといった左辺での条件付けではなく，定義式の右辺で条件付けをすることも可能である．それには\keyword{条件式}を使う．条件式とは$$fx=\mathIf x\equiv0\mathThen0\mathElse1+x$$のように$\mathIf$節，$\mathThen$節，及び$\mathElse$節からなるものである．$\mathIf$節の式の値が真($T$)であれば$\mathThen$節の式が評価され，そうでなければ$\mathElse$節の式が評価される．$\mathIf$節の中身は真理値を返す関数であれば良いので，関数$p$を$$p=(\equiv)0$$としておき，$$fx=\mathIf px\mathThen0\mathElse1+x$$と書く方法もしばしば用いられる．\footnote{Haskellでは$fx=\mathIf x\equiv0\mathThen0\mathElse1+x$を\code{f x = if x == 0 then 0 else 1+x}と書く．}

条件式が値を持っていることに注意しよう．Pythonの条件文（if文）は値を返すわけではなく，プログラムの\keyword{制御構造}を表しているため，次のようなコードになる．
\begin{pythoncode}
\begin{python}
$\pthnDef f(x):$\\
\>$\pthnIf x\equiv0:$\\
\>\>$\pthnReturn 0$\\
\>$\pthnElse:$\\
\>\>$\pthnReturn 1+x$
\end{python}
\end{pythoncode}
プログラムの制御構造は値を持った式として評価できないため，数式としては扱いにくい．そこで我々は前述の条件式だけを使うことにする．

条件式は紙面が許せば次のように書いても良い．
\begin{equation*}
fx=\begin{cases}
0&\mathIf x\equiv0\\
1+x&\mathOtherwise
\end{cases}
\end{equation*}
左ブレース（中括弧）の位置が関数のスペシャルバージョンの定義の時と異なっていることに注目しよう．

関数は内部で自分自身を呼んでも良い．例えば$x$の階乗を返す関数$s$は
\begin{equation*}
sx=\begin{cases}
1&\mathIf x\equiv0\\
x*s(x-1)&\mathOtherwise
\end{cases}
\end{equation*}
と定義できる．関数が自分自身を呼び出すことを\keyword{再帰呼び出し}と呼ぶ．




\section*{余計な話：数値と条件式}

ラムダで．


\chapter{演算子*}

\begin{leader}
本書では一般の数学書やプログラミングの教科書からは少し異なった記法を用いる．ある概念が発明されてからずっと後になって正しい記法が見つかり，それがきっかけとなって正しく理解されるという現象は歴史上よくあることである．本書でも様々な新しい記号，記法を導入するが，この章では既に比較的広く知られている記法を紹介する．
\end{leader}



\section{Pythonの演算子*}

単項演算子には論理否定($\neg$)とマイナス($-$)がある．
本書で扱う基本的な単項演算子はこの2種類だけであるが，複数の演算子を組み合わせて単項演算子を新たに作ることはある．
本書に登場する単項演算子は全て\keyword{前置}である．

二項演算子のうちよく使われるものは和($+$)，積($*$)，論理和($\vee$)，論理積($\wedge$)，同値($\equiv$)，大なり($>$)，小なり($<$)等である．
二項演算子はたとえ積記号であっても省略できない．
二項演算子は多数あるので，その都度説明する．

二項演算子は中置することが基本であるが，括弧で包むことで前置することも可能である．
任意の二項演算子$\mathAnyBinaryOperator$について$$x\mathAnyBinaryOperator y$$及び$$(\mathAnyBinaryOperator)xy$$は全く同じ意味である．
従って，二項演算子と2引数関数に本質的な差はない．
本書では演算子と関数という用語は全く同じ意味で用いる．
\footnote{Haskellでは任意の二項演算子を括弧で包むことで前置演算子として使うことができる．例えば\code{x + y}と \code{(+)x y} は同じ結果を返す．逆に任意の二引数関数\code{f}は \code{x `f` y} と書くことで中置することができる．}

二項演算子の結合性，すなわち左結合か右結合かは，演算子によって異なる．

演算の優先順位を明示的に与えるために括弧が用いられる．

\begin{point}
任意の二項演算子$\mathAnyBinaryOperator$について$$x\mathAnyBinaryOperator y=(\mathAnyBinaryOperator)xy$$である．
\end{point}


\section{演算子$=$関数*}

\section{関数合成演算子と関数適用演算子*}

ある変数に複数の関数を順に適用することはよくあることである．例えば
\begin{pythoncode}
\begin{python}
$y=g(x)$\\
$z=f(y)$
\end{python}
\end{pythoncode}
あるいは，同じことであるが
\begin{pythoncode}
\begin{python}
$z=f(g(x))$
\end{python}
\end{pythoncode}
とすることがある．

ここで，引数のことは忘れて，関数$f$と関数$g$を先に\keyword{合成}しておきたいとしよう．その合成を$f\mathCompose g$と書く．合成はラムダ式を使って$$(f\mathCompose g)x=f(gx)$$と定義できる．関数合成の演算子$\mathCompose$は関数適用よりも優先順位が高く，$(f\mathCompose g)x$は単に$f\mathCompose g\,x$と書いても良い．この記法は括弧の数を減らすためにしばしば用いられる．\footnote{Haskellでは関数\code{f}と関数\code{g}の合成は\code{f.g}である．}

関数合成演算子とは逆に，優先順位の低い\keyword{関数適用演算子}も考えておくと括弧の数を減らすのに便利である．関数適用演算子$\mathApply$を次のように定義しておく．$$f\mathApply gx=f(gx)$$演算子$\mathApply$の優先順位は足し算演算子よりも低いものとする．よって$f(x+1)$は$f\mathApply x+1$と書くこともできる．\footnote{Haskellでは$f\mathApply gx$を\code{f \$ g x}と書く．}



\section*{余計な話：カリー化}

どのような関数であれ，引数は1個しかとらない．引数が2個あるように見える関数として，例えば$fxy$があったとしよう．関数適用が左結合であるから，これは$(fx)y$である．ここに$(fx)$は引数$y$をとる関数であると見ることができる．つまり，関数$f$とは引数$x$をとり「引数$y$をとって値を返す関数$(fx)$を返す」関数であると言える．

二項演算$x+y$は$$(+)xy$$とも書けたことを思い出そう．これも左結合を思い出すと$$((+)x)y$$と書けるから，$y$という引数を$((+)x)$という関数に食わせていると解釈できる．

ラムダ式の場合は話はもっと単純で，機械的に$$\mathLambdaExpression{xy}{x+y}=\mathLambdaExpression{x}{(\mathLambdaExpression{y}{x+y})}$$のように展開するだけである．矢印$\mathLambdaArrow$は右結合であるから，このラムダ式は括弧を省略して$$\mathLambdaExpression{xy}{x+y}=\mathLambdaExpression{x}{\mathLambdaExpression{y}{x+y}}$$とも書かれる．

複数引数をとる関数を1引数関数に分解することを\keyword{カリー化}と呼ぶ．これはこの分野の先駆者であるハスケル・カリーの名前に由来する．



\chapter{代数的構造*}

\begin{leader}
この章では「代数的構造」を見ていくことにする．代数的構造とは，四則演算のような数に関する基本的な性質を抽象化していくことで，数の背後にある基本的なメカニズムを抽出したものである．代数的構造はあらゆるプログラミング言語に明示的，あるいは非明示的に見られる要素である．
\end{leader}

\section{数}

これから各種の\keyword{代数的構造}を見ていくことにする．代数的構造と言っても，身構える必要はない．それは，我々プログラマが日々接している概念に，共通した名前を与えたにすぎない．

まず最初に，我々にとって一番身近な代数的構造である\keyword{数}を見てみよう．数の代表例は\keyword{実数}であるから，実数を例にとって考えてみよう．実数全体の集合を$\mathSpecialSet{R}$で表すことにする．また任意の実数を$x,y,z$で表すこととする．このことを数学者は$x,y,z\in\mathSpecialSet{R}$と書くが，我々は記号$\in$を別の用途に使いたいので，本書では$$x,y,z\mathIn\mathSpecialSet{R}$$と表すことにする．

以下に実数の備える代数的性質を列挙する．どれも当たり前のことに見えるが，ひとつひとつ見ていこう．ここで$x,y,z\mathIn\mathSpecialSet{R}$とする．
\begin{description}
\item[実数の性質1. 足し算] 任意の$x$と任意の$y$の足し算（\keyword{加法}）の結果（\keyword{和}）$x+y$は$\mathSpecialSet{R}$の元すなわち実数である．
\item[実数の性質2. 足し算の結合則] 任意の$x,y,z$について$$(x+y)+z=x+(y+z)$$である．これを\keyword{結合則}と呼ぶ．
\item[実数の性質3. 零元（加法単位元）の存在] 特別な実数$0\mathIn\mathSpecialSet{R}$があり$$0+x=x+0=x$$である．この$0$は足し算の\keyword{単位元}である．\keyword{零元}または\keyword{加法単位元}と呼ぶこともある．
\item[実数の性質4. 負元（加法逆元）の存在] 任意の$x$に対して$-x\mathIn\mathSpecialSet{R}$があり$$-x+x=0$$である．この$-x$は$x$の足し算の\keyword{逆元}である．\keyword{負元}または\keyword{加法逆元}と呼ぶこともある．
\item[実数の性質5. 足し算の可換性] 任意の$x,y$について$$x+y=y+x$$である．このことを足し算の\keyword{可換性}と呼ぶ．
\item[実数の性質6. 掛け算] 任意の$x$と任意の$y$の掛け算（\keyword{乗法}）の結果（\keyword{積}）$x*y$は$\mathSpecialSet{R}$の元すなわち実数である．
\item[実数の性質7. 掛け算の結合則] 任意の$x,y,z$について$$(x*y)*z=x*(y*z)$$である．
\item[実数の性質8. 単位元の存在] 特別な実数$1\mathIn\mathSpecialSet{R}$があり$$1*x=x*1=x$$である．この$1$を掛け算の単位元または\keyword{乗法単位元}と呼ぶ．
\item[実数の性質9. 逆元の存在] 任意の$x$に対して$x^{-1}\mathIn\mathSpecialSet{R}$があり$$x^{-1}*x=1$$である．この$x^{-1}$は$x$の掛け算の逆元である．\keyword{乗法逆元}と呼ぶこともある．ただし性質11で述べる通り，加法単位元については逆元がなくても良い．Pythonでは$x^{-1}$とキーボードから打てないため$1/x$という書き方をする．
\item[実数の性質10. 掛け算の可換性] 任意の$x,y$について$$x*y=y*x$$である．このことを掛け算の可換性と呼ぶ．
\item[実数の性質11. 加法単位元の乗法逆元] 加法単位元に対する掛け算の逆元は存在しなくても良い．（つまり$0^{-1}$のことは考えなくて良い．）
\item[実数の性質12. 分配則] 足し算と掛け算が混在する場合$$(x+y)*z=(x*z)+(y*z)$$と掛け算を\keyword{分配}する．
\end{description}
以上が実数の代数的性質の全てである．我々がよく使う引き算，割り算は数学上は糖衣構文 (syntax sugar) である．

上述の12個の条件が当てはまる数には，\keyword{有理数}や\keyword{複素数}がある．この12個の性質をまとめて，数学では\keyword{体}または可換体と呼ぶ．わざわざ可換と断るのは，現代の数学では$x*y\neq y*x$であるような体系がよく用いられるからである．

体の要素は，集合$\mathSet{K}$，二項演算子$+$，二項演算子$+$の単位元$0$，二項演算子$+$の逆元生成演算子$-$，もう一つの二項演算子$*$，二項演算子$*$の単位元$1$，二項演算子$*$の逆元生成演算子$\mathSomething^{-1}$であるから，体はそれらを列挙して$\mathField{\mathSet{K}}{+}{0}{-}{*}{1}{\mathSomething^{-1}}$と表現する．

体の性質から言えることを一つ紹介しよう．これから$$z\uparrow n=\underbrace{z*\dotsb*z}_n$$なる二項演算子$\uparrow$（\keyword{クヌースの矢印}）を使う．ここに$z$を体$\mathField{\mathSet{K}}{+}{0}{-}{*}{1}{\mathSomething^{-1}}$の$\mathSet{K}$の元，$n$を自然数とした．さて$z\uparrow2$は$$z\uparrow2=z*z$$であるから，いま$z=x+y$とすると
\begin{align*}
z\uparrow2&=z*z\\
&=z*(x+y)\\
&=z*x+z*y\;\dots\;\text{分配則}\\
&=(x+y)*x+(x+y)*y\\
&=x*x+y*x+x*y+y*y\;\dots\;\text{分配則}\\
&=x\uparrow2+x*y+y*x+y\uparrow2
\end{align*}
となり
\begin{equation}
\label{eq:xysq}
(x+y)\uparrow2=x\uparrow2+x*y+y*x+y\uparrow2
\end{equation}
を得る．式\eqref{eq:xysq}は体の性質だけを使って導いた関係なので，実数だけでなく有理数や複素数にもそのまま使える．実際には式\eqref{eq:xysq}は体の性質のうち分配則だけを使っいるので，体以外にも応用が利く式である．

\begin{table*}
\caption{代表的な代数的構造の性質(1)}
\label{tab:field-and-ring}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c||}
\hline
代数的構造&$\mathAnyBinaryOperator_1$&$\mathAnyBinaryOperator_1$の単位元&$\mathAnyBinaryOperator_1$の逆元&$\mathAnyBinaryOperator_2$&$\mathAnyBinaryOperator_2$の単位元&$\mathAnyBinaryOperator_2$の逆元\\
\hline\hline
体&可換&あり&あり&可換&あり&あり\\
環&可換&あり&あり&非可換&あり&なし\\
\hline
\end{tabular}
\end{center}
\end{table*}

\section{群}

体の性質を若干緩めたい場合がある．さもなければ，\keyword{整数}，\keyword{正方行列}，\keyword{クォータニオン}（四元数），\keyword{論理値}，\keyword{ベクトル}，ベクトルの\keyword{変換}，集合から集合への\keyword{写像}と言った重要な概念が数の概念からこぼれてしまうからである．例えば整数の掛け算の逆元は（単位元の逆元を除いて）整数の中には存在しないし，正則行列やクォータニオンの場合は掛け算が可換ではない．

だいたいどの辺まで制約を緩めたものを数の仲間に入れるかというのは見解の分かれるところでもあるが，体から性質9（掛け算の逆元），性質10（掛け算の可換性），性質11（加法単位元の乗法逆元）を取り除いたものを\keyword{環}と呼び，環の性質を持つものを数の仲間に入れることが一般的である．環の性質を持つものは，体である実数，有理数，複素数に加えて，整数，正方行列，クォータニオン，論理値などがある．

制約を少しずつ緩める代わりに，制約をその構成要素に分解するほうがさらなる応用が利きそうである．体には二つの二項演算子$+$と$*$が登場した．その片方にのみ注目してみたらどうなるだろう．それがこの節で取り上げる\keyword{群}である．

形式的に二項演算子$+$を$\mathAnyBinaryOperator_1$とし，二項演算子$*$を$\mathAnyBinaryOperator_2$として，体と環の性質を並べたものが表\ref{tab:field-and-ring}である．これを見ると，演算子$\mathAnyBinaryOperator$について「可換・単位元あり・逆元あり」の組み合わせが二つペアになったもの（体）か，「可換・単位元あり・逆元あり」の組み合わせと「非可換・単位元あり・逆元なし」の組み合わせがペアになったもの（環）があり，その構成要素は二項演算子$\mathAnyBinaryOperator$について「可換・単位元あり・逆元あり」と「非可換・単位元あり・逆元なし」の2種類であることがわかる．

いま集合$\mathSet{G}$があり，$x,y,z\mathIn\mathSet{G}$であるとし，二項演算子を$\mathAnyBinaryOperator$と書くことにして，体の性質の前半分を書き下してみよう．
\begin{description}
\item[性質1.] 任意の$x$と任意の$y$の演算の結果$x\mathAnyBinaryOperator y$は$\mathSet{G}$の元である．
\item[性質2.] 任意の$x,y,z$について$$(x\mathAnyBinaryOperator y)\mathAnyBinaryOperator z=x\mathAnyBinaryOperator(y\mathAnyBinaryOperator z)$$である．
\item[性質3.] 特別な元$O\mathIn\mathSet{G}$があり$$O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x$$である．
\item[性質4.] 任意の$x$に対して$\mathInverse x\mathIn\mathSet{G}$があり$$\mathInverse x\mathAnyBinaryOperator x=O$$である．
\item[性質5.] 任意の$x,y$について$$x\mathAnyBinaryOperator y=y\mathAnyBinaryOperator x$$である．
\end{description}
このような性質が満たされる時，組み合わせ$\mathGroup{\mathSet{G}}{\mathAnyBinaryOperator}{O}{\mathInverse}$を\keyword{可換群}または\keyword{加群}と呼ぶ．この可換群が最初の構成要素「可換・単位元あり・逆元あり」の正体である．

例えば$\mathGroup{\mathSpecialSet{R}}{+}{0}{-}$は可換群である．整数全体の集合を$\mathSpecialSet{Z}$とすると$\mathGroup{\mathSpecialSet{Z}}{+}{0}{-}$も可換群である．また，集合$\mathSpecialSet{R}$から$0$だけを取り除いた集合を$\mathSpecialSet{R}\setminus0$とするとき$\mathGroup{\mathSpecialSet{R}\setminus0}{*}{1}{\mathSomething^{-1}}$も可換群である．

可換群は代表的な代数的構造のひとつであり，他にも数学のあちこちに顔を出している．例えば回転角を$t$とする二次元の回転変換を$R_t$として，回転変換$R_t$すべてからなる集合$\mathSet{R}$を考えてみよう．回転の合成を$\bullet$で表すとすると
\begin{equation}
\label{eq:rotation}
R_{t_1}\bullet R_{t_2}=R_{(t_1+t_2)}
\end{equation}
であるから，回転を合成した結果も回転である．また式\eqref{eq:rotation}から$$R_{t_1}\bullet\left(R_{t_2}\bullet R_{t_3}\right)=\left(R_{t_1}\bullet R_{t_2}\right)\bullet R_{t_3}$$
であるから，回転変換は結合則も満たしている．

次にに回転変換に単位元があるかどうか調べてみよう．回転しない変換は\keyword{恒等変換}とも言い，しばしば$I$で表す．何もしない回転変換は$0$度の回転であるから$I=R_0$である．このとき式\eqref{eq:rotation}から$$I\bullet R_t=R_t\bullet I=R_t$$であるから，$I$は回転変換の単位元であると言える．

最後に回転変換に逆元があるかも調べてみよう．$t$回転の逆は明らかに$-t$であるから$$R_{-t}\bullet R_t=R_t\bullet R_{-t}=I$$が成り立つ．そこで$$R_{t}^{-1}=R_{-t}$$として$R_t$の逆元$R_t^{-1}$を定義することができる．

このように，組み合わせ$\mathGroup{\mathSet{R}}{\bullet}{I}{\mathSomething^{-1}}$も可換群である．（回転$R_t$全体の集合$\mathSet{R}$が群を形成することは，パラメタ$t$が所属する実数全体の集合$\mathSpecialSet{R}$が群を形成することに大いに頼っている．この部分を詳細に調べるとリー群という美しい代数的構造が見つかる．）
% !!!!!!!!!!

回転されるものをベクトルと呼ぶ．ベクトルや回転変換の実装方法はいくつかあり，例えば第1座標値を$u$，第2座標値を$v$としたときにベクトル$\mathVector{p}$を$$\mathVector{p}=\begin{bmatrix}u\\v\end{bmatrix}$$と表した場合，回転変換は$$R_t=\begin{bmatrix}\cos t&-\sin t\\\sin t&\cos t\end{bmatrix}$$と行列で表すことになり，回転後のベクトル$\mathVector{p'}$は$$\mathVector{p'}=R_t*\mathVector{p}$$となる．ここに演算子$*$は行列の積である．また，この場合変換の合成$\mathCompose$は行列積$*$となる．

他にもベクトルを複素数で表現する方法もある．いま$\mathVector{p}$を$$\mathVector{p}=u+\mathI v$$と表して，回転変換$R_t$を$$R_t=\cos t+\mathI\sin t$$とすると，回転後の$\mathVector{p'}$はやはり$$\mathVector{p'}=R_t*\mathVector{p}$$と書ける．ここに演算子$*$は複素数の積である．また，この場合変換の合成$\mathCompose$も複素数積$*$となる．

任意次元のベクトル全体からなる集合を$\mathSet{V}$として，零ベクトルを$\mathVector{Z}$で表すことにしよう．矢印はベクトルであることを忘れないようにするための飾りである．ベクトル同士の加算を二項演算子$+$で表し，向きを反転させた逆ベクトル作る演算子を$-$とすると，組み合わせ$\mathGroup{\mathSet{V}}{+}{\mathVector{Z}}{-}$もまた可換群である．

可換群の性質のうち最初の4項目だけを満たすものを群と呼ぶ．可換群は群の特別な場合である．現代の数学では$x\mathAnyBinaryOperator y\neq y\mathAnyBinaryOperator x$のように演算子の前後を入れ替えると結果が異なるような演算をよく取り扱うので，一般の群は可換群よりもよく取り上げられ，それ故より短い名前が付けられている．

もう一度組み合わせ$\mathGroup{\mathSet{G}}{\mathAnyBinaryOperator}{O}{\mathInverse}$が群である条件を見ておこう．それは
\begin{description}
\item[群の性質1.] 任意の$x$と任意の$y$の演算の結果$x\mathAnyBinaryOperator y$は$\mathSet{G}$の元である．
\item[群の性質2. 結合則] 任意の$x,y,z$について$$(x\mathAnyBinaryOperator y)\mathAnyBinaryOperator z=x\mathAnyBinaryOperator(y\mathAnyBinaryOperator z)$$である．
\item[群の性質3. 単位元の存在] 特別な元$O\mathIn\mathSet{G}$があり$$O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x$$である．
\item[群の性質4. 逆元の存在] 任意の$x$に対して$\mathInverse x\mathIn\mathSet{G}$があり$$\mathInverse x\mathAnyBinaryOperator x=O$$である．
\end{description}
であった．これらの条件を少し緩め，逆元が存在しなくても良い「緩やかな群」を考えてみる．この「緩やかな群」のことを\keyword{単位的半群}または\keyword{モノイド}と呼ぶ．これが構成要素「非可換・単位元あり・逆元なし」の正体である．

\begin{table}
\caption{代表的な代数的構造の性質 (2)}
\label{tab:group-and-monoid}
\begin{center}
\begin{tabular}{||c||c|c|c||}
\hline
代数的構造&$\mathAnyBinaryOperator$&$\mathAnyBinaryOperator$の単位元&$\mathAnyBinaryOperator$の逆元\\
\hline\hline
可換群&可換&あり&あり\\
群&非可換&あり&あり\\
単位的半群&非可換&あり&なし\\
半群&非可換&なし&なし\\
\hline
\end{tabular}
\end{center}
\end{table}

単位的半群の性質は次の三つである．ただし$x,y,z$が集合$\mathSet{M}$の元であるとする．
\begin{description}
\item[単位的半群の性質1.] 任意の$x$と任意の$y$の演算の結果$x\mathAnyBinaryOperator y$は$\mathSet{M}$の元である．
\item[単位的半群の性質2. 結合則] 任意の$x,y,z$について$$(x\mathAnyBinaryOperator y)\mathAnyBinaryOperator z=x\mathAnyBinaryOperator(y\mathAnyBinaryOperator z)$$である．
\item[単位的半群の性質3. 単位元の存在] 特別な元$O\mathIn\mathSet{M}$があり$$O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x$$である．
\end{description}
このとき，組み合わせ$\mathMonoid{\mathSet{M}}{\mathAnyBinaryOperator}{O}$が単位的半群である．可換群とこの単位的半群を組み合わせたのが環，可換群二つを組み合わせたのが体であった．

なお，これまで単位元の定義として$O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x$を掲げているが，厳密には単位元は$$O_\mathLeft\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O_\mathRight=x$$のように，\keyword{左単位元}と\keyword{右単位元}を区別しても良い．

単位的半群の性質からさらに性質3を消したものを\keyword{半群}と呼ぶ．可換群，群，単位的半群，半群を一覧にしたものを表\ref{tab:group-and-monoid}に掲げる．

\section{圏}

これまでは集合の元同士に対する二項演算を考えてきた．集合$\mathSet{M}$が単位的半群であるとき，集合$\mathSet{M}$の元$x,y\mathIn\mathSet{M}$に対して$x\mathAnyBinaryOperator y\mathIn\mathSet{M}$であった．見方を変えると，演算子$\mathAnyBinaryOperator$とは集合$\mathSet{M}$の元2個から出発して，集合$\mathSet{M}$の元1個へとジャンプさせる\keyword{写像}であると言える．これを$$\mathAnyBinaryOperator\mathIn{}\mathMorph{(\mathSet{M}\mathSetTimes\mathSet{M})}{\mathSet{M}}$$と書く．ここに$\mathSet{X}\mathSetTimes\mathSet{Y}$は集合$\mathSet{X}$と集合$\mathSet{Y}$の\keyword{直積集合}である．直積集合と元の集合はもはや別な集合であることに注意しよう．

写像は$\mathMorph{\mathSet{M}\mathSetTimes\mathSet{M}}{\mathSet{M}}$に限ったもの出はなく，集合$\mathSet{M}$から集合$\mathSet{M}$への写像$\mathAnyUnaryOperator$ただし$$\mathAnyUnaryOperator\mathIn\mathMorph{\mathSet{M}}{\mathSet{M}}$$があっても良い．実はこれまでにも登場した逆元を作る演算子はまさに$\mathMorph{\mathSet{M}}{\mathSet{M}}$という写像である．

またベクトルには，実数倍や回転といった写像がある．これらは実数のパラメタを一つとるので，ベクトル全体の集合を$\mathSet{V}$，実数全体の集合を$\mathSpecialSet{R}$として，実数のパラメタを$r$としたときに$$\mathAnyUnaryOperator_r\mathIn{}\mathMorph{(\mathSpecialSet{R}\mathSetTimes\mathSet{V})}{\mathSet{V}}$$と書ける．例えば回転の場合は$\mathAnyUnaryOperator_r=U_r$である．

このようにとある集合（例えば$\mathSet{M}\mathSetTimes\mathSet{M}$や$\mathSpecialSet{R}\mathSetTimes\mathSet{V}$）から異なる別な集合（例えば$\mathSet{M}$や$\mathSet{V}$）へという写像を一般化するとどうなるだろうか．いま，集合$\mathSet{X}$から集合$\mathSet{Y}$への写像$f$があり，集合$\mathSet{Y}$から集合$\mathSet{Z}$への写像$g$があるとする．すなわち
\begin{align*}
f&\mathIn\mathMorph{\mathSet{X}}{\mathSet{Y}}\\
g&\mathIn\mathMorph{\mathSet{Y}}{\mathSet{Z}}
\end{align*}
があるとする．
また写像同士を二項演算子$\mathCompose$で\keyword{合成}できるものとする．例えば$f$と$g$の合成写像は$\mathSet{X}$を出発点に$\mathSet{Y}$を経由して$\mathSet{Z}$へと行くので$$f\mathCompose g\mathIn\mathMorph{\mathSet{X}}{\mathSet{Z}}$$と書ける．ここで合成演算子は結合則を満たすものとしておこう．

さらに$$I_\mathSet{X}\mathIn\mathMorph{\mathSet{X}}{\mathSet{X}},\;I_\mathSet{Y}\mathIn\mathMorph{\mathSet{Y}}{\mathSet{Y}},\;I_\mathSet{Z}\mathIn\mathMorph{\mathSet{Z}}{\mathSet{Z}}$$という写像もあるとしよう．ここで$$I_\mathSet{Y}\mathCompose f=f\mathCompose I_\mathSet{X}$$とすると，写像$I_\mathSet{X}$と写像$I_\mathSet{Y}$はそれぞれ写像の合成演算子$\mathCompose$に対して単位元のように振る舞う．写像$g$については$$I_\mathSet{Z}\mathCompose g=g\mathCompose I_\mathSet{Y}$$であるとする．このような写像$I_\mathSet{X},I_\mathSet{Y},I_\mathSet{Z}$を\keyword{恒等写像}と呼ぶ．

集合$\mathSet{X}$，集合$\mathSet{Y}$，集合$\mathSet{Z}$の集合$\mathSet{C}$と，写像$f$と写像$g$の集合$\mathSet{P}$と，写像合成演算子$\mathCompose$と，恒等写像の集合$\mathSet{I}$の組み合わせ$\mathCategory{\mathSet{C}}{\mathSet{P}}{\mathCompose}{\mathSet{I}}$を\keyword{圏}と呼ぶ．写像合成演算子と恒等写像の集合は自明であるためしばしば省略され，組み合わせ$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$を圏とする書き方もよくされる．

圏を考えるとき，変換や写像は全て\keyword{射}と呼ぶ決まりである．

いまある単位的半群$\mathMonoid{\mathSet{M}}{\mathAnyBinaryOperator}{O}$があるとする．集合$\mathSet{C}$を$\mathSet{M}$及び$\mathSet{M}\mathSetTimes\mathSet{M}$を元とする集合すなわち$$\mathSet{C}=\{\mathSet{M},\mathSet{M}\mathSetTimes\mathSet{M}\}$$とし，集合$\mathSet{P}$を$\mathAnyBinaryOperator$のみを元とする集合すなわち$$\mathSet{P}=\{\mathAnyBinaryOperator\}$$とすると，組み合わせ$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$は圏になっている．

\section*{余計な話：束*}

\chapter{型*}


\begin{leader}
プログラマのいう型とは，数学者のいう集合のことである．
\end{leader}


\section{型}

型とは変数が取りうる値に与えた制約のことである．
数学者がよく扱う型は論理型($\mathSet{B}$)，整数型($\mathSpecialSet{Z}$)，実数型($\mathSpecialSet{R}$)といったところであろう．
ただし数学者たちは型ではなく集合と呼ぶ．
括弧内に示した記号は数学者たちが慣用的に用いているものである．

我々は計算機での実装を考慮して，数学者たちとは若干異なる型と表記方法を扱うことにする．
まず論理型($\mathSet{B}$)はそのまま論理型として$\hsklBool$で表す．

計算機にとって都合の良い整数の範囲を考慮した整数型を$\hsklInt$で表す．
計算機にとって都合の良い整数の範囲とは，例えば64ビット計算機の場合$-2^{32}$から$2^{32}-1$までの範囲のことである．

計算機は残念ながら無限精度の実数を扱えない．
そこで標準精度の浮動小数点数を表す型を$\hsklFloat$で表す．

もう一つ，計算機ならではの型を導入しておこう．
それは$\hsklInt$とよく似ているが，特別に文字を扱うために考えられた型$\hsklChar$である．
文字といってもその中身は整数である．
整数ではあるが，わざわざ別な型とするのには理由がある．
歴史的には文字は小さな整数として表現されることが多かったため，計算機のメモリが高価であった時代背景もあり，メモリの節約のために文字を表す型が存在した．
現在では，文字が数値にエンコードされる方式がより複雑になってきたために，文字を通常の数値と区別するために特別な型が用意さてれいる．



\section{関数の型}

関数にも型がある．
例えば整数引数を一つ取り，整数を返す関数$f$は$$f\mathIn\mathMorph{\hsklInt}{\hsklInt}$$という型を持つ．
これは関数$f$が集合$\hsklInt$から集合$\hsklInt$への写像であると読む．

整数引数を二つ取り，整数を返す関数$f'$は$$f'\mathIn\mathMorphII{\hsklInt}{\hsklInt}{\hsklInt}$$という型を持つ．
写像の矢印記号は右結合するので，これは$$f'\mathIn\mathMorphIIWithParenthesis{\hsklInt}{\hsklInt}{\hsklInt}$$と同じ意味である．
自然言語で考えると，$\hsklInt$型の引数を一つ取り，$\hsklInt$型の引数を一つ取って$\hsklInt$型の値を返す関数を返す，と読める．

\begin{table}
\caption{単位的半群}
\label{tab:monoids}
\begin{center}
\begin{tabular}{||c||c|c||}
\hline
型クラス
    &\multicolumn{2}{|c||}{$\hsklMonoid$}\\
\hline\hline
型$\backslash$演算子と単位元
    &演算子
    &単位元\\
\hline
$\hsklChar$
    &---
    &---\\
\hline
$\hsklBool$
    &$\vee$
    &$F$\\
\hline
$\hsklBool$
    &$\wedge$
    &$T$\\
\hline
$\hsklInt$
    &$+$
    &$0$\\
\hline
$\hsklInt$
    &$*$
    &$1$\\
\hline
$\hsklFloat$
    &$+$
    &$0$\\
\hline
$\hsklFloat$
    &$*$
    &$1$\\
\hline
\end{tabular}
\end{center}
\end{table}




\begin{table*}
\caption{型と型クラス}
\label{tab:type-and-typeclass}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c|c|c|c|c|c|c||}
\hline
\multirow{4}{*}{型クラス}
    &\multicolumn{12}{|c||}{$\hsklIntegral$}\\
\cline{2-13}
\multirow{3}{*}{}
    &\multicolumn{10}{|c|}{$\hsklReal$}
    &\multicolumn{2}{|c||}{$\hsklEnum$}\\
\cline{2-11}
\multirow{2}{*}{}
    &\multicolumn{5}{|c|}{$\hsklOrd$}
    &\multicolumn{5}{|c|}{$\hsklNum$}
    &\multicolumn{2}{|c||}{ }\\
\cline{2-2}\cline{7-7}
{ }
    &$\hsklEq$
    &\multicolumn{4}{|c|}{ }
    &$\hsklEq$
    &\multicolumn{4}{|c|}{ }
    &\multicolumn{2}{|c||}{ }\\
\hline\hline
型$\backslash$演算子
    &$\equiv$
    &$<$
    &$\le$
    &$\ge$
    &$>$
    &$\equiv$
    &$+$
    &$-$
    &$*$
    &$/$
    &$\hsklPred$
    &$\hsklSucc$\\
\hline
$\hsklChar$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---
    &---
    &---
    &$\checkmark$
    &$\checkmark$\\
\hline
$\hsklBool$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---
    &---
    &---
    &$\checkmark$
    &$\checkmark$\\
\hline
$\hsklInt$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$\\
\hline
$\hsklFloat$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---\\
\hline
\end{tabular}
\end{center}
\end{table*}

\section{型クラス}

組み合わせ$\mathMonoid{\hsklInt}{+}{0}$は単位的半群である．
同様に$\mathMonoid{\hsklInt}{*}{1}$, $\mathMonoid{\hsklFloat}{+}{0}$, $\mathMonoid{\hsklFloat}{*}{1}$, $\mathMonoid{\hsklBool}{\vee}{F}$, $\mathMonoid{\hsklBool}{\wedge}{T}$ も単位的半群である．
そこで，任意の型$\hsklType{a}$について，組み合わせ$\mathMonoid{\hsklType{a}}{\mathAnyBinaryOperator}{O}$が単位的半群である場合には$$\mathMonoid{\hsklType{a}}{\mathAnyBinaryOperator}{O}\mathIn\hsklMonoid$$と書くことにする．
二項演算子，単位元が自明な場合は簡略化して$$\hsklType{a}\mathIn\hsklMonoid$$と書くことにする．
これまで出てきた型を表\ref{tab:monoids}にまとめた．

このような型をより抽象化した型のようなものを\keyword{型クラス}と呼ぶ．
単位的半群は型クラスの例である．
表\ref{tab:monoids}に型と対応する単位的半群の単位元，演算子の一覧を示す．

もっと身近な型クラスもある．
例えば，型$\hsklType{a}$の変数どうしの間で等値性が定義されている場合，その型は型クラス$\hsklEq$に属することになる．
型クラス$\hsklEq$に属する型は等値演算子$\equiv$を提供する．

型$\hsklType{a}$の変数どうしの間で大小関係が定義されている場合，かつその型が型クラス$\hsklEq$に属する場合，その型は型クラス$\hsklOrd$にも属する．
型クラス$\hsklOrd$に属する型は比較演算子$<,\le,\ge,>$を提供する．

型$\hsklType{a}$の変数どうしの間で四則演算関係が定義されている場合，かつその型が型クラス$\hsklEq$に属する場合，その型は型クラス$\hsklNum$にも属する．
型クラス$\hsklNum$に属する型は二項演算子$+,-,*,/$を提供する．
ここに$-$は二項演算子のマイナスである．

型$\hsklType{a}$が型クラス$\hsklOrd$及び型クラス$\hsklNum$に属しているとき，かつそのときに限り，型$\hsklType{a}$は型クラス$\hsklReal$にも属する．

型$\hsklType{a}$の変数について，一つ小さい値を返す関数$\hsklPred$と一つ大きい値を返す関数$\hsklSucc$が定義されているとき，かつそのときに限り，型$\hsklType{a}$は型クラス$\hsklEnum$に属する．

型$\hsklType{a}$が型クラス$\hsklReal$及び型クラス$\hsklEnum$に属しているとき，かつそのときに限り，型$\hsklType{a}$は型クラス$\hsklIntegral$にも属する．

これらの関係を表にまとめたものが表\ref{tab:type-and-typeclass}である．


\chapter{リスト*}
\begin{leader}
型から作る型をコンテナと呼ぶ．代表的なコンテナはある型のホモジニアスな配列であるリストである．この章ではリストと，リストに対する重要な演算である畳み込み，マップを取り扱う．
\end{leader}


\section{Pythonのリスト*}

同じ型の値を一列に並べたもの，つまりホモジニアスな配列のことを\keyword{リスト}と呼ぶ．我々もPythonのように，例えば$0$から始まり$9$まで続く整数のリストを$[0,1,2,3,4,5,6,7,8,9]$と書くことにしよう．これはPythonの次のコードと同じことである．
\begin{pythoncode}
\begin{python}
$l=[0,1,2,3,4,5,6,7,8,9]$
\end{python}
\end{pythoncode}

これはいささか冗長なので，等差数列に限って，簡略化した書き方が許されることにする．$0$から$9$までのリストは$[0,1\dots9]$と書いても良い．\footnote{Haskellでは\code{l = [0,1...9]}と書く．}

複数の型の要素が混在してもよい配列のことをヘテロジニアスな配列と呼び，ホモジニアスな配列とは区別する．

今後，リストを指す変数にはバーをつけて$\hsklList{l}$と書くことにして$$\hsklList{l}=[0,1\dots9]$$のように書くことにしよう．\footnote{Haskellコンパイラは人間よりも記憶力が優れているため，変数名にバーをつける必要はない．}

Pythonではリスト内包表記が使える．例えば$0$から$9$までの平方数のリストは次のように作った．
\begin{pythoncode}
\begin{python}
$l=[x\pthnUp2\pthnFor x\pthnIn\pthnRange(0,10)]$
\end{python}
\end{pythoncode}
ここに$\pthnRange(a,b)$は$a$から連続する$b$個の数値からなるリストを返すPython関数である．

我々は内包表記のかわりにガードを使って$$\hsklList{l}=\left[x^2\mathGuard{x\mathFrom{[0,1\dots9]}}\right]$$のように書こう．ここに右辺のリストから一つずつ要素を取り出して左辺に代入する演算子$\mathFrom$を用いた．

ガードの中の式は複数あっても良い．例えば$$\hsklList{l}=\left[x+y\mathGuard{x\mathFrom[0,1\dots9],\,y\mathFrom[0,1\dots5],\,x+y>3}\right]$$は$0\le x\le 10$かつ$0\le y\le 5$の範囲で$x+y>3$となる$x$及び$y$から$x+y$を並べたリストである．これはPythonでいう
\begin{pythoncode}
\begin{python}
$l=[x+y\pthnFor x\pthnIn\pthnRange(0,10)\pthnFor y$ \pthnNextLine\\
\>$\pthnIn\pthnRange(0,6)\pthnIf x+y>3]$
\end{python}
\end{pythoncode}
のことである．\footnote{Haskellでは\code{l = [x+y | x<-[0,1..9], y<-[0,1..5], x+y>3]}と書く．}

リストは\keyword{結合}できる．例えばリスト$\hsklList{l}$とリスト$\hsklList{m}$を結合したリストは$$\hsklList{l}\hsklAppend\hsklList{m}$$で得られる．\footnote{Haskellでは\code{l++m}と書く．}

リストは無限個の要素を持っても良い．例えば自然数全体を表すリスト$\hsklList{n}$は$$\hsklList{n}=[1,2\dots]$$のように定義して良い．\footnote{Haskellでは\code{n = [1,2..]}と書く．}

\keyword{空リスト}は$\hsklEmptyList$で表す．\footnote{Haskellでは空リストを\code{[]}で表す．}

任意の型を$\hsklType{a}$とするとき，$\hsklType{a}$型のリスト型を$\hsklListType{\hsklType{a}}$と書く．型$\hsklType{a}$から型$\hsklListType{\hsklType{a}}$を生成する演算子を\keyword{リスト型コンストラクタ}と呼んで$\hsklListConstructor$と書き$$\hsklListType{\hsklType{a}}=\hsklTypeConstruct{\hsklListConstructor}{\hsklType{a}}$$とする．この等式の両辺は変数ではなく型名であることに注意しよう．\footnote{Haskellでは表記上コンテナ型$\hsklListType{a}$と型コンストラクタ式$\hsklTypeConstruct{\hsklListConstructor}{\hsklType{a}}$を区別せず，両者とも\code{[a]}と書く．}

$\hsklType{a}$型の変数$x$を入れた$\hsklListType{\hsklType{a}}$型のリストを作る演算子を\keyword{リスト値コンストラクタ}と呼ぶ．$\hsklType{a}$型の変数$x$からリスト値コンストラクタを使ってリスト$\hsklList{l}$を作ることは$$\hsklList{l}=[x]$$と書く．\footnote{Haskellでは\code{l = [x]}と書く．}

リスト型を表す$\hsklListType{\hsklType{a}}$と，1要素のリストである$[x]$の違いにはいつも気をつけておこう．
本書ではリスト型を表す場合はブラケットを太くし，型名を太字のローマン体で書く一方，リストの場合はブラケットを細くし，変数名を細字のイタリック体で書く．

ある型を包み込んだ別の型を一般に\keyword{コンテナ型}または単に\keyword{コンテナ}と呼ぶ．



\section{畳み込みとマップ}

我々はよくリストの総和を表現するためにシグマ記号($\sum$)を使う．リスト$[x_0,x_1\dots x_n]$の総和を$$\sum[x_0,x_1\dots x_n]=x_0+x_1+\dotsb+x_n$$とするようなシグマ記号である．この表現を一般化してみよう．
リスト$[x_0,x_1\dots x_n]$が与えられたとき，$$\mathFold^{\mathAnyBinaryOperator}_{a}[x_0,x_1\dots x_n]=a\mathAnyBinaryOperator x_0\mathAnyBinaryOperator x_1\mathAnyBinaryOperator\dotsb\mathAnyBinaryOperator x_n$$であると定義する．

この新しい記号$\mathFold$は\keyword{畳み込み演算子}と呼ばれる．変数$a$はアキュムレータと呼ぶ．アキュムレータは右側の引数が空であった場合のデフォルト値と考えても良い．\footnote{Haskellでは$\mathFold^{*}_{a}l$を\code{foldl * a l}と書く．}
% !!!!!!!!!! CHECK !!!!!!!!!!

Python 2.7 には畳み込み演算子に相当する$\pthnReduce$関数があり，リスト$l$の総和$s$を
\begin{pythoncode}
\begin{python}
\texttt{\# Python 2.7}\\
$l=[0,1,2,3,4,5]$\\
$s=\pthnReduce(\pthnLambda x,y:x+y,l,0)$
\end{python}
\end{pythoncode}
のように求めることができる．この$\pthnReduce$関数は Python 3 では非推奨である．% 一方，Rubyでは
% \begin{rubycode}
% \begin{verbatim}
% [0,1,2,3,4,5].inject(0) { |x,y| x+y }
% \end{verbatim}
% \end{rubycode}
% のような書き方がサポートされている．

リストの総和をとる演算子$\sum$は$$\sum=\mathFold^+_0$$とすれば得られる．同じようにリストの要素のすべての積をとる演算子$\prod$は$$\prod=\mathFold^*_1$$とすれば得られる．

畳み込み演算子は第1（上）引数に$\hsklType{a}$型と$\hsklType{b}$型の引数を取り$\hsklType{a}$型の戻り値を返す二項演算子，第2（下）引数に$\hsklType{a}$型，第3（右）引数に$\hsklType{b}$型のリストすなわち$\hsklListType{\hsklType{b}}$型を取り，$\hsklType{a}$型の値を返す．従って畳み込み演算子の型は$$\mathFold\mathIn\mathMorphIII{(\mathMorphII{\hsklType{a}}{\hsklType{b}}{\hsklType{a}})}{\hsklType{a}}{\hsklListType{\hsklType{b}}}{\hsklType{a}}$$と定義できる．

畳み込み演算子には次のようなもう一つのバリエーションがある．$$\mathFoldRight^{\mathAnyBinaryOperator}_{a}[x_0,x_1\dotsb x_n]=\left(x_0\mathAnyBinaryOperator\left(x_1\mathAnyBinaryOperator\dotsb\mathAnyBinaryOperator\left(x_n\mathAnyBinaryOperator a\right)\right)\right)$$
これは右畳み込みと呼ばれる演算子である．\footnote{Haskellでは$\mathFoldRight^{*}_{a}l$を\code{foldr l a *}と書く．}
% !!!!!!!!!! CHECK !!!!!!!!!!

畳み込み演算子の面白い応用例を示そう．$$\mathFold_\hsklEmptyList^\hsklAppend[[0,1,2],[3,4,5],\dots]=[0,1,2,3,4,5,\dots]$$であるから，演算子$$\mathFold_\hsklEmptyList^\hsklAppend$$はリストを平坦化する\keyword{平坦化演算子}である．平坦化演算子はconcat演算子とも呼ばれることもあるが，基本的な演算子であるため特別な記号をつけておこう．我々は$$\hsklConcat=\mathFold_\hsklEmptyList^\hsklAppend$$と定義することにする．\footnote{Haskellでは演算子$\hsklConcat$の代わりに\code{concat}関数を使う．}
% !!!!!!!!!! CHECK !!!!!!!!!!

リストの各要素に決まった関数を適用したい場合がある．引数として関数$f$とリスト$[x_0,x_1\dots x_n]$を取り，戻り値として$[fx_0,fx_1\dots fx_n]$を返す演算子$\hsklMap$を考えよう．このとき$$f\hsklMap[x_0,x_1\dots x_n]=[fx_0,fx_1\dots fx_n]$$であると定義する．この$\hsklMap$演算子を\keyword{マップ演算子}と呼ぶ．\footnote{Haskellでは$f\hsklMap l$を\code{map f l}または\code{f `map` l}と書く．}

マップ演算子はPythonの$\pthnMap$関数と同じものである．リストを$l$，関数を$f$とした時に
\begin{pythoncode}
\begin{python}
$\pthnMap(f,l)$
\end{python}
\end{pythoncode}
は関数$f$をリスト$l$の各要素に適用する．

マップ演算子の型は$$\hsklMap\hsklOf{}\mathMorphII{(\mathMorph{\hsklType{a}}{\hsklType{b}})}{\hsklListType{\hsklType{a}}}{\hsklListType{\hsklType{b}}}$$である．矢印$\mathMapsTo$は右結合なので，これは$$\hsklMap\hsklOf{}\mathMorph{(\mathMorph{\hsklType{a}}{\hsklType{b}})}{(\mathMorph{\hsklListType{\hsklType{a}}}{\hsklListType{\hsklType{b}}})}$$の意味でもある．ここで$f$と$f\hsklMap$の型を並べてみると
\begin{align*}
f&\mathIn\mathMorph{\hsklType{a}}{\hsklType{b}}\\
f\hsklMap&\mathIn\mathMorph{\hsklListType{\hsklType{a}}}{\hsklListType{\hsklType{b}}}
\end{align*}
となり，マップ演算子が何をしているのか一目瞭然になる．



\section{リストの実装}

ここでリストの実装について若干述べておかねばならない．紙上ではリストは自由に考えられるが，計算機上ではそれほど自由ではないからである．ここではリストはLISPにおけるリストと同じ構造を持つものとする．LISPにおけるリストとは要素$\mathFirst$と要素$\mathRest$からなるペアの集合である．要素$\mathFirst$がリストの要素を持ち，要素$\mathRest$が次のペアを参照する．リストの最後のペアの$\mathRest$は空リストを参照する．

リストのための特別な表現$$\mathFirst:\mathRest$$を用い，第1要素$\mathFirst$はリストが保持する型，第2要素$\mathRest$はリスト型であるとする．演算子$:$を\keyword{結合演算子}と呼ぶ．\footnote{Haskellでも要素\code{x}をリスト\code{l}の先頭に追加することを\code{x:l}と書く．}

要素$\mathRest$はリストまたは空リストであるから，一般にリストは次のように展開できることになる．
\begin{align*}
[x_0,x_1,x_2\rangedots x_n]&=x_0:[x_1,x_2\rangedots x_n]\\
&=x_0:x_1:[x_2\rangedots x_n]\\
&=x_0:x_1:x_2:\dots:x_n:\hsklEmptyList
\end{align*}
結合演算子$:$は右結合する．すなわち$$x_0:x_1:x_2=x_0:(x_1:x_2)$$である．

マップ演算子の実装は，リストの実装に踏み込めば簡単である．空でないリストは必ず$x:\hsklList{y}$へと分解できるから
\begin{align*}
f\hsklMap x:\hsklList{y}&=fx:f\hsklMap\hsklList{y}\\
f\hsklMap\hsklEmptyList&=\hsklEmptyList
\end{align*}
とマップ演算子($\hsklMap$)を定義できる．つまりマップ演算子($\hsklMap$)は結合演算子(:)から作ることができる．換言すれば，マップ演算子は糖衣構文である．

任意のリスト$\hsklList{l}$に対し，次の関数が用意されている．
\begin{align*}
\hsklHead\hsklList{l}&\dots\text{$\hsklList{l}$の先頭要素}\\
\hsklTail\hsklList{l}&\dots\text{$\hsklList{l}$の2番目以降の要素からなるリスト}
\end{align*}
これらはLISPのcar関数，cdr関数と同じものである．


\section*{余計な話：リストを引数にとる関数}

リストを分解する関数$\hsklHead$と$\hsklTail$さえあればどのようなリスト処理も可能であるが，リストを引数にとる関数を考えると最初から分解されたリストを渡された方が何かと便利である．そこで結合演算子を関数引数のパタンにも使えることにしよう．これで，例えばリストの和をとる関数$f$は
\begin{equation*}
\left\{
\begin{split}
f\hsklEmptyList&=0\\
% fx:\hsklEmptyList&=x\\
fx:\hsklList{y}&=x+f\hsklList{y}
\end{split}
\right.
\end{equation*}
のように定義できる．


\chapter{Maybe*}

\section{Pythonに文脈を*}

\section{Maybeと演算*}

整数$x$を$0$で除算することはエラーである．
しかし除算の度にエラーが起こったかどうか調べるのは面倒であるし，記述も煩雑になってしまう．
プログラマはよくこういう場合に「例外」という機構を用いるが，数学に例外は持ち込みたくない．
そこで変数$x$が正しく計算されたかもしれないし，されていないかもしれないということを，$\hsklMaybe{m}$のように印をつけた別の変数に入れて，忘れないようにしておこう．
ここで変数$\hsklMaybe{m}$が取り得る値は正しく計算された値$x$か，あるいはエラーを表す値$\hsklNothing$である．
このように計算結果に「意味付け」をすることを\keyword{文脈}に入れると言う．

この変数$\hsklMaybe{m}$はもはや整数型とは言えない．
そこでこの$\hsklMaybe{m}$の型を$\hsklMaybeType{\hsklInt}$と表して「きっと整数」型と呼ぶことにしよう．
型$\hsklType{a}$から型$\hsklMaybeType{\hsklType{a}}$を生成する型コンストラクタを$\hsklMaybeConstructor$と呼び$$\hsklMaybeType{\hsklType{a}}=\hsklTypeConstruct{\hsklMaybeConstructor}{\hsklType{a}}$$とする．\footnote{Haskellでは表記上コンテナ型$\hsklMaybeType{a}$と型コンストラクタ式$\hsklTypeConstruct{\hsklMaybeConstructor}{\hsklType{a}}$を区別せず，両者とも\code{Maybe a}と書く．}

$\hsklType{a}$型の変数を$\hsklMaybeType{\hsklType{a}}$型の変数に代入するには，次の値コンストラクタを用いて
$$\hsklMaybe{m}=\hsklJust{x}$$
と書く．\footnote{Haskellでは\code{m = Just x}と書く．}

変数$x$が一度$0$除算の危険性に汚染された場合，その後ずっと$\hsklMaybe{m}$というコンテナに入れ続けなければいけない．
このきっと整数$\hsklMaybe{m}$に対して整数を引数にとる関数$f$を適用させるには，何らかの関数マップ演算子が必要である．
そこできっと整数の中身に直接関数を適用する演算子を$\hsklMaybeMap$としよう．
具体的には$$f\hsklMaybeMap\hsklMaybe{m}=\hsklMaybeW{fx}$$のように関数$f$を変数$\hsklMaybe{m}$に適用させる．
その結果はまた$\hsklMaybeType{\hsklInt}$型である．

いま引数の$100$倍の値を返す関数$fx=100*x$があるとしよう．
% この関数は桁あふれも何も考えずに，とにかく引数を$100$倍するものとする．
これを「きっと整数」な$\hsklMaybe{m}$に適用するには，$\hsklMaybe{m}$がもし$\hsklMaybe{m}=\hsklJust{x}$ならば中身$x$を取り出して$fx$を計算し，もし$\hsklMaybe{m}=\hsklNothing$であれば$\hsklNothing$を返すような適用演算子である．
引数$\hsklMaybe{m}$がいつ$\hsklJust{x}$でいつ$\hsklNothing$になるのかは，いまは問わないことにする．

さて，我々が欲しいのは
\begin{equation*}
f\hsklMaybeMap\hsklMaybe{m}=\begin{cases}
\hsklJust{fx}&\mathIf\hsklMaybe{m}\equiv\hsklJust{x}\\
\hsklNothing&\mathOtherwise
\end{cases}
\end{equation*}
であるようなMaybeバージョンのマップ演算子$\hsklMaybeMap$である．
その実装は実はいたって単純で
\begin{equation*}
\left\{
\begin{split}
f\hsklMaybeMap\hsklJust{x}&=\hsklJust{fx}\\
f\hsklMaybeMap\hsklNothing&=\hsklNothing
\end{split}
\right.
\end{equation*}
である．

今後，普通の（引数にMaybeが来ることを想定していない）関数$f$をMaybe型である変数$\hsklMaybe{m}$に適用させるときには，必ず$$\hsklMaybe{n}=f\hsklMaybeMap\hsklMaybe{m}$$のようにMaybeバージョンのマップ演算子$\hsklMaybeMap$を用いることにする．\footnote{HaskellではMaybeバージョンのマップ演算子に特別な記号，関数名が与えられていない．その代わり\ref{ch:functor}章で述べる一般化マップ演算子$\hsklFmap$に相当する\code{fmap}関数を用い\code{n = fmap f m}または\code{n = f `fmap` m}のようにする．Haskellは型推論を行なうため変数\code{m}がMaybeであればMaybeバージョンのマップ演算子（関数）が適用される．（もし\code{m}がリストであれば通常のマップ関数である\code{map}が適用される．）}

% 従って，結果を受け取る変数も$\typeconstructor{\typemaybe}{\typeint}$型でなければならず，それを忘れないように印を付けておかねばならない．
% 例えば$$\maybetype{y}=f\binarymaybefunctormap\maybetype{x}$$のように書くことになるであろう．

% $$(\typeconstructor{\typemaybe}{\typename{a}},\binarymaybeappend,\constantnothing)$$
% \boxplus == \boxdot???

\begin{javacode}
Maybeの定義を数式で書くと簡単であるが，Javaで書く場合には例えば次のようなコードが必要になる．
\begin{Verbatim}
public class Maybe<a> {
  private a value;
  private boolean valid;
  public Maybe(a aValue) {
    value = aValue;
    valid = true;
  }
  public Maybe() {
    valid = false;
  }
  public a getValue() {
    return value;
  }
  public Bool isValid() {
    return valid;
  }
\end{Verbatim}
コンストラクタ呼び出し\code{Maybe<int>(x)}は$\hsklJust{x}$に相当し，コンストラクタ呼び出し\code{Maybe<int>()}は$\hsklNothing$に相当する．
\end{javacode}


\begin{javacode}
\begin{Verbatim}
Maybe<int> m = new Maybe<int>(10);
int square(int x) { return x * x; }
int x = square(m);  // 型エラー！
int y = square(m.getvalue());
Maybe<int> z = Maybe<int>.mapOver(square, m);
\end{Verbatim}
\end{javacode}

変数\code{x}への代入文は引数の型が一致していないためエラーである．
変数\code{y}への代入文はエラーではないが，元々\code{a}が持っていた文脈を捨てることになる．
変数\code{z}への代入文ならば関数\code{square}に手を入れることなく，また\code{a}の文脈も保存できる．
ただし次の関数\code{mapOver}が必要になる．

\begin{javacode}
% !!!!!! not Consumer...
\begin{Verbatim}
static public Maybe<a>
mapOver(Consumer<a> f, Maybe<a> m)
{
  return new Maybe<a>(f(m.getValue()));
}
\end{Verbatim}
\end{javacode}



\section{リストとMaybe*}

\section*{余計な話：単位的半群としてのコンテナ}

$$\mathMonoid{\hsklListType{\hsklType{a}}}{\hsklAppend}{\hsklEmptyList}$$

$$\mathMonoid{\hsklMaybeType{\hsklType{a}}}{\hsklMaybeAppend}{\hsklNothing}$$


\chapter{関手*}
\label{ch:functor}


\section{型コンストラクタと関手*}

圏$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$があるとする．
ここに集合$\mathSet{C}$は射の\keyword{対象}となる集合の集合であり，集合$\mathSet{P}$は射の集合である．
例えば$$\mathSet{C}=\{\hsklInt\},\;\mathSet{P}=\{-\}$$というのも圏の一つである．
この場合，整数と，その符号を反転させる写像（の集合）が圏の要素である．

ここにもう一つの圏$\mathCategoryShort{\mathSet{C}'}{\mathSet{P}'}$があるとする．
対象$\mathSet{C}$の各元と対象$\mathSet{C}'$の各元の間に一対一対応があり，また射$\mathSet{F}$の各元と射$\mathSet{P}'$の各元の間に一対一対応があるとき，圏$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$から圏$\mathCategoryShort{\mathSet{C}'}{\mathSet{P}'}$への「射」が存在する．
この射を\keyword{関手}と呼ぶ．
例えば$$\mathSet{C}'=\{\hsklListType{\hsklInt}\},\;\mathSet{P}'=\{(-\hsklMap)\}$$であるとき，整数($\hsklInt$)に対する単項演算($-$)と，整数のリスト($\hsklListType{\hsklInt}$)全体に対する単項演算($-\hsklMap$)は一対一に対応する．

つまり，$\hsklInt$型から$\hsklListType{\hsklInt}$型を作る型コンストラクタ$\hsklListConstructor$とマップ演算子$\hsklMap$があれば，圏$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$から圏$\mathCategoryShort{\mathSet{C}'}{\mathSet{P}'}$へとジャンプできるのである．

型コンストラクタ$\hsklListConstructor$とマップ演算子$\hsklMap$の組み合わせ$(\hsklListConstructor,\hsklMap)$は関手の一例である．

同じことが型コンストラクタ$\hsklMaybeConstructor$とMaybeバージョンのマップ演算子$\hsklMaybeMap$の組み合わせ$(\hsklMaybeConstructor,\hsklMaybeMap)$にも言える．

そこで（リストの）マップ演算子($\hsklMap$)，Maybeバージョンのマップ演算子($\hsklMaybeMap$)をひとくくりにして\keyword{一般マップ演算子} ($\hsklFmap$)とする．
一般マップ演算子は，右引数がリストであればマップ演算子を，右引数がMaybeであればMaybeバージョンのマップ演算子に「化ける」．
この意味は，もし$f\hsklFmap\hsklList{l}$と書いてあれば$f\hsklMap\hsklList{l}$のことであるし，もし$f\hsklFmap\hsklMaybe{m}$と書いてあれば$f\hsklMaybeMap\hsklMaybe{m}$のことであると，自動的に解釈することである．
そして，何の飾りもつけられていない変数$x$がふらっと現れ，目の前に$f\hsklFmap x$という式が登場しても，落ち着いて変数$x$の型を調べ，変数$x$がリストならば$\hsklFmap$の部分に$\hsklMap$を，変数$x$がMaybeならば$\hsklFmap$の部分に$\hsklMaybeMap$をはめ込むのだ．\footnote{Haskellでは一般マップ演算子は\code{fmap}である．ただしその実装は与えられず，対象とする型に応じて定義されるものとする．例えばリストに対しては\code{fmap = map}と定義されている．}

関手，というよりは一般マップ演算子($\hsklFmap$)には従うべき規則がある．
これらを関手則と呼ぶので，我々もその用語に従うことにする．
関手則は次の二つである．
\begin{description}
\item[関手則1.] 任意の関数を$f$，\keyword{恒等関数}を$I$とするとき
$$I\hsklFmap f=If=f$$
である．
なお$I\hsklFmap f=If=f$は$f$を省略して
$$I\hsklFmap=I$$
と書いても良い．
\item[関手則2.] 任意の関数 $f,g,h$ があるとき
$$(f\mathCompose g)\hsklFmap h=(f\hsklFmap h)\mathCompose(g\hsklFmap h)$$
である．
なお$(f\mathCompose g)\hsklFmap h=(f\hsklFmap h)\mathCompose(g\hsklFmap h)$は$h$を省略して$$(f\mathCompose g)\hsklFmap=(f\hsklFmap)\mathCompose(g\hsklFmap)$$と書いても良い．
\end{description}
なお恒等関数$I$とは
$$I=\mathLambdaAnonymousParameter$$
のことである．\footnote{Haskellでは恒等関数は\code{id}として定義されている．}





\section{アプリカティブ関手}

関手の一般化マップ演算子をさらに汎用性のあるものにするために，二つの要素に分解する．
その要素とは\keyword{ピュア演算子}と\keyword{一般アプリカティブマップ演算子} ($\hsklApplicativeMap$) である．\footnote{Haskellでは一般アプリカティブマップ演算子を\code{<*>}と書く．}

一般化マップ演算子が「普通の関数」$f$をコンテナの中の変数に適用するのに対し，アプリカティブマップ演算子はコンテナの中の関数をコンテナの中の変数へ適用する．

一般マップ演算子の実装に（リストバージョンの）マップ演算子，Maybeバージョンのマップ演算子があったように，一般アプリカティブマップ演算子にもリストバージョンのアプリカティブマップ演算子，Maybeバージョンのアプリカティブマップ演算子がある．

リストバージョンのアプリカティブマップ演算子($\hsklApplicativeListMap$)は左引数のリスト内のすべての関数を順番に右引数のリスト内の変数に適用し，その結果をリストとして返す．
例えば$$[f,g,h]\hsklApplicativeMap[x,y,z]$$とした場合，左引数，右引数ともリストであるため$$[f,g,h]\hsklApplicativeMap[x,y,z]=[f,g,h]\hsklApplicativeListMap[x,y,z]$$となり，その結果は
\begin{align*}
[f,g,h]\hsklApplicativeMap[x,y,z]&=[f,g,h]\hsklApplicativeListMap[x,y,z]\\
&=[fx,fy,fz,gx,gy,gz,hx,hy,hz]
\end{align*}
である．

Maybeバージョンのアプリカティブマップ演算子($\hsklApplicativeMaybeMap$)は左引数がもし$\hsklJust{f}$の形をしていれば，その$f$を右変数$\hsklMaybe{n}$に対して$f\hsklMaybeMap\hsklMaybe{n}$と適用する．
具体的には，もし$\hsklJust{(*)100}\hsklApplicativeMaybeMap{}\hsklJust{68}$という式が現れたとすると，アプリカティブマップ演算子の左引数から中身の関数$((*)100)$を抜き出して，右引数の中身$68$に適用し，その結果を再びMaybe値にして返す．
式で書けば
$$\hsklJust{(*)100}\hsklApplicativeMaybeMap{}\hsklJust{68}=\hsklJust{68000}$$
となる．

リストバージョンのアプリカティブマップ演算子は，（リストバージョンの）マップ演算子から再帰的に実装できる．
リストバージョンのアプリカティブマップ演算子の実装は
\begin{align*}
(f:\hsklList{g})\hsklApplicativeListMap\hsklList{l}&=\hsklConcat((f\hsklMap\hsklList{l}):(\hsklList{g}\hsklApplicativeListMap\hsklList{l}))\\
\hsklEmptyList\hsklApplicativeListMap\hsklList{l}&=\hsklEmptyList
\end{align*}
である．

Maybeバージョンのアプリカティブマップ演算子は，Maybeバージョンのマップ演算子から実装できる．
その実装は
\begin{equation*}
\hsklMaybe{m}\hsklApplicativeMaybeMap\hsklMaybe{n}=\begin{cases}
f\hsklMaybeMap\hsklMaybe{n}&\mathIf\hsklMaybe{m}\equiv\hsklJust{f}\\
\hsklNothing&\mathOtherwise
\end{cases}
\end{equation*}
であり，さらにMaybeバージョンのマップ演算子を展開すると
\begin{equation*}
\hsklMaybe{m}\hsklApplicativeMaybeMap\hsklMaybe{n}=\begin{cases}
\left\{
\begin{array}{ll}
\hsklJust{fx}&\mathIf\hsklMaybe{n}\equiv\hsklJust{x}\\
\hsklNothing&\mathOtherwise
\end{array}\right\}&\mathIf\hsklMaybe{m}\equiv\hsklJust{f}\\
\hsklNothing&\mathOtherwise
\end{cases}
\end{equation*}
である．

ピュア演算子とは型コンストラクタを利用した「最もシンプルな」型変換演算子である．
例えばリストのピュア演算子は単に$[x]$であるし，Maybeのピュア演算子は$\hsklJust{x}$である．
一般のピュア演算子は$\hsklPure{x}$と書くものとする．
ピュア演算子は，いまのところ便宜上導入されたものと考えて差し支えない．
というのも，その主たる使い道が（アプリカティブではない）関手との後方互換性のためだからである．\footnote{Haskellは一般のピュア演算子の実装を与えていない．}

関手における一般マップ演算子($\hsklFmap$)は，ピュア演算子と一般アプリカティブマップ演算子を使って$$f\hsklFmap x=\hsklPure{f}\hsklApplicativeMap x$$と再定義できる．



\section{関数と関手の関係*}

\section*{余計な話：アプリカティブスタイル}

関数適用演算子$\mathApply$とよく似た演算子$\hsklApplicativeApply$ただし$$f\hsklApplicativeApply g=\hsklPure{f\mathCompose g}$$なる演算子を導入する．
この演算子は特別に\keyword{アプリカティブ関数適用演算子}と呼ぶ．\footnote{Haskellでは\code{<\$>}と書く．}

アプリカティブ関数適用演算子があると，わざわざピュア演算子を用いなくとも連続的に「普通の」関数をコンテナ型の引数に適用できる．
いま変数$x$がコンテナ型とし，関数$f$と関数$g$が「普通」であるとすると$$f\hsklApplicativeApply g\hsklApplicativeMap x$$のようにして変数$x$に関数$g$，関数$f$を順に作用させることができる．
このような書き方を\keyword{アプリカティブスタイル}と呼ぶ．

アプリカティブスタイルのいいところは，「普通の」関数が増えてもスタイルを変えなくて良いことである．
例えば$$f\hsklApplicativeApply g\hsklApplicativeMap h\hsklApplicativeMap x$$は期待通りコンテナ型変数$x$に関数$h$，関数$g$，関数$f$を順に作用させる．
これは$f\hsklApplicativeApply g\hsklApplicativeMap h$と$\hsklPure{f\mathCompose g\mathCompose h}$が同値だからである．

アプリカティブスタイルは，計算の流れを明確にしているとも言える．
例えば$f\hsklApplicativeApply g\hsklApplicativeMap h\hsklApplicativeMap x$は$$x\leadsto h\leadsto g\leadsto f$$という計算の流れを示す．
もちろん関数合成演算子と関数適用演算子でも似たことはできるが，関数合成演算子と関数適用演算子だけでは$x$が例えば$\hsklNothing$でる可能性を扱えないし，また計算の途中経過がなんらかのエラーで$\hsklNothing$になるような系も扱えない．
（後者はアプリカティブスタイルでも扱えない．そのために次章で述べる「モナド」が登場する．）




\chapter{モナド}

\section{もうひとつの関手*}


アプリカティブ関手は関手の一般マップ演算子をピュア演算子と一般アプリカティブマップ演算子に分解することで，式の見通しを良くすることができるアプリカティブスタイルという記法を採用できた．
しかしながら，アプリカティブスタイル変数に文脈を与えるタイミングは最初すなわち式の右端の1回に限られている．
任意のタイミングで変数に文脈を与えられるように関手を改造したものが\keyword{モナド}である．

リストのマップ演算子$$\hsklList{l}'=f\hsklMap\hsklList{l}$$を思い出そう．
もし$\hsklList{l}\equiv\hsklEmptyList$ならば$\hsklList{l}'=\hsklEmptyList$になる．
もし$\hsklList{l}\equiv[x_0,x_1\dots]$ならば$\hsklList{l}'=[fx_0,fx_1\dots]$になる．

Maybeのマップ演算子$$\hsklMaybe{m}'=g\hsklMaybeMap\hsklMaybe{m}$$を思い出そう．
もし$\hsklMaybe{m}\equiv\hsklNothing$ならば$\hsklMaybe{m}'=\hsklNothing$になる．
もし$\hsklMaybe{m}\equiv\hsklJust{y}$ならば$\hsklMaybe{m}'=\hsklJust{fy}$になる．

これらをまとめた一般マップ演算子$$z'=h\hsklFmap z$$を思い出そう．
関数$h$は「普通の」関数である．

リストのアプリカティブマップ演算子$$\hsklList{l}'=\hsklList{f}\hsklApplicativeListMap\hsklList{l}$$を思い出そう．
もし$\hsklList{f}\equiv\hsklEmptyList$ならば$\hsklList{l}'=\hsklEmptyList$になる．
もし$\hsklList{f}\equiv[u_0,u_1\dots]$ならば$\hsklList{l}'=[u_0\hsklMap\hsklList{l},u_1\hsklMap\hsklList{l}\dots]$になる．

Maybeのアプリカティブマップ演算子$$\hsklMaybe{m}'=\hsklMaybe{g}\hsklApplicativeMaybeMap\hsklMaybe{m}$$を思い出そう．
もし$\hsklMaybe{g}\equiv\hsklNothing$ならば$\hsklMaybe{m}'=\hsklNothing$になる．
もし$\hsklMaybe{g}\equiv\hsklJust{v}$ならば$\hsklMaybe{m}'=\hsklJust{vy}$になる．

これらをまとめた一般アプリカティブマップ演算子$$z'=h\hsklApplicativeMap z$$を思い出そう．
関数$h$は「普通の」関数をコンテナにつめたものである．
ピュア演算子を用いると，元の一般マップ演算子との互換性が$$w\hsklFmap z=\hsklPure{w}\hsklApplicativeMap z$$のようにとれる．
ここに$w$は「普通の」関数である．

では「普通ではない」関数はどうしたらいいだろうか．
最も考えられる「普通ではない」関数とは「普通の」（コンテナに入っていない裸の）引数をとり，コンテナにつめた戻り値を返す関数である．
そのような関数$\phi$があるとしよう．
% ユニット演算子の説明
$$\phi x=\begin{cases}\hsklUnit{\text{result}}&\text{if nothing happened}\\
\text{some context}&\text{when something happened}\end{cases}$$
ちょっと待った．
$\hsklUnit{x}$とは何だろうか．
$\hsklUnit{x}$は\keyword{ユニット演算子}と言って，変数を最もシンプルな形でコンテナに納めるものである．
どこかで聞いた話ではないだろうか．
その通り，ユニット演算子は事実上ピュア演算子と同じものである．
ではなぜユニット演算子とピュア演算子を字面上区別しておくかというと，ひとつはモナドにより強い柔軟性を持たせるため，もう一つは，簡潔さのためである．
というのも，もしモナドがアプリカティブ関手とピュア演算子を共有するとなると，同時に一般アプリカティブマップ演算子も共有することになるが，モナドなマップ演算子から一般アプリカティブマップ演算子は合成できないため，モナドが「焼け太り」してしまうからである．
%!!!!!!!!!! CHECK !!!!!!!!!!

\begin{align*}
\hsklFmap&\mathIn{}\mathMorphII{(\mathMorph{\hsklType{a}}{\hsklType{b}})}{\langle\hsklType{a}\rangle}{\langle\hsklType{b}
\rangle}\\
\hsklApplicativeMap&\mathIn{}\mathMorphII{\langle\mathMorph{\hsklType{a}}{\hsklType{b}}\rangle}{\langle\hsklType{a}\rangle}{\langle\hsklType{b}\rangle}\\
\hsklMonadMap&\mathIn{}\mathMorphII{(\mathMorph{\hsklType{a}}{\langle\hsklType{b}\rangle})}{\langle\hsklType{a}\rangle}{\langle{\hsklType{b}}\rangle}
\end{align*}

$$\hsklPure{\mathSomething}\mathIn\mathMorph{\hsklType{a}}{\langle\hsklType{a}\rangle}$$

この関数$\phi$をコンテナにつめられた変数$x$に適用するための「モナドな」マップ演算子$\hsklMonadMap$を導入する．
$$x'=\phi\hsklMonadMap x$$

関手とは
$$f\hsklFmap x=\hsklUnit{f}\hsklMonadMap x$$
とすれば互換性がとれる．


ピュア演算子，ユニット演算子．


\section{モナドな関数*}


具体例として引数が$2^{32}$未満なら引数の値をそのまま，それ以上なら$\hsklNothing$を返す関数$a$を考えてみよう．
\begin{equation*}
ax=\begin{cases}
\hsklJust{x}&\mathIf x<2^{32}\\
\hsklNothing&\mathOtherwise
\end{cases}
\end{equation*}


もうひとつの具体例として「安全な」割り算演算子$\div$を定義してみよう．
ここで
\begin{equation*}
\hsklMaybe{m}\div y=\begin{cases}\hsklJust{x/y}&\mathIf m\neq\hsklNothing\mathAnd y\neq0\\
\hsklNothing&\mathOtherwise\end{cases}
\end{equation*}
とする．
ただし$\hsklMaybe{m}$は$\hsklJust{x}$か，あるいは$\hsklNothing$かのどちらかの値が入っている．
$x\neq\hsklNothing$かつ$y\neq0$のときの戻り値が$x/y$ではなく$\hsklJust{x/y}$なのは，計算結果が汚染の可能性を持つからである．


\begin{table*}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c|c||}
\hline
\multirow{2}{*}{型クラス}
    &\multicolumn{3}{|c|}{$\hsklApplicative$}
    &\multicolumn{4}{|c||}{$\hsklMonadplus$}\\
\cline{4-8}
\multirow{1}{*}{}
    &\multicolumn{2}{|c|}{ }
    &$\hsklFunctor$
    &\multicolumn{2}{|c}{$\hsklMonad$}
    &\multicolumn{2}{|c||}{$\hsklMonoid$}\\
\hline\hline
型$\backslash$要素と演算子
    &$\hsklPure{x}$
    &$\hsklApplicativeMap$
    &$\hsklFmap$
    &$\hsklUnit{x}$
    &$\hsklMonadMap$
    &$O$
    &$\mathAnyBinaryOperator$\\
\hline
リスト
    &$[x]$
    &$\hsklApplicativeListMap$
    &$\hsklMap$
    &$[x]$
    &$\clubsuit$
    &$\hsklEmptyList$
    &$\hsklAppend$\\
\hline
Maybe
    &$\hsklJust{x}$
    &$\hsklApplicativeMaybeMap$
    &$\hsklMaybeMap$
    &$\hsklJust{x}$
    &$\spadesuit$
    &$\hsklNothing$
    &$\hsklMaybeAppend$\\
\hline
関数
    &$\langle\!\langle x\rangle\!\rangle$
    &$\bowtie$
    &$\mathCompose$
    &$\langle\!\langle x\rangle\!\rangle$
    &$\circ$
    &$\mathLambdaAnonymousParameter$
    &$\mathCompose$\\
\hline
Int（参考）
    &
    &
    &
    &
    &
    &$0$
    &$+$\\
\hline
\end{tabular}
\end{center}
\end{table*}


\section{モナド則*}

\section*{余計な話：モナドプラス}


---









\part{モナドから見る世界}

\chapter{IO}

\chapter{例外}

\chapter{乱数}

\chapter{状態}

\chapter{非決定性}

\chapter{継続}

\chapter{X}

\chapter{Y}

\chapter{Z}


\part{圏とモナド}


\end{document}
