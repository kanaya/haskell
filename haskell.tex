\documentclass[twocolumn]{jsbook}
\usepackage{amsmath,amssymb,ascmac,bm,multirow,fancyvrb,eulervm}
\makeindex

\title{プログラマのための代数構造}
\author{Ichi Kanaya}
\date{2016}

\def\[{[\![}
\def\]{]\!]}
% \def\keyword#1{#1\index{#1}}

\newcommand{\cxx}{\textrm{C}\texttt{++}}

\newcommand{\keyword}[1]{{\emph{#1}}}
% \newcommand{\keyword}[1]{\underline{\emph{#1}}}

\newcommand{\code}[1]{\texttt{#1}}
\newenvironment{leader}{\begingroup\bf}{\endgroup}
\newenvironment{point}{\begin{screen}}{\end{screen}}
\newenvironment{cxxcode}{\begin{itembox}[r]{\cxx}}{\end{itembox}}
\newenvironment{javacode}{\begin{itembox}[r]{Java}}{\end{itembox}}
\newenvironment{pythoncode}{\begin{itembox}[r]{Python}}{\end{itembox}}
\newenvironment{rubycode}{\begin{itembox}[r]{Ruby}}{\end{itembox}}
\newenvironment{python}{\begin{tabbing}\hspace*{1em}\=\hspace*{1em}\=\hspace*{1em}\=\hspace*{1em}\=\kill}{\end{tabbing}}

% \newenvironment{footnotecode}{\begin{Verbatim}[xleftmargin=10mm]}{\end{Verbatim}}

\newcommand{\pthnClassname}[1]{\textrm{#1}}
\newcommand{\pthnId}[1]{\textit{#1}}
\newcommand{\pthnKeyword}[1]{\textbf{#1}}
\newcommand{\pthnOp}[1]{\texttt{#1}}
\newcommand{\pthnString}[1]{\texttt{#1}}

\DeclareMathOperator{\pthnDef}{\pthnKeyword{def}}
\DeclareMathOperator{\pthnElse}{\pthnKeyword{else}}
\DeclareMathOperator{\pthnFor}{\pthnKeyword{for}}
\DeclareMathOperator{\pthnIf}{\pthnKeyword{if}}
\DeclareMathOperator{\pthnIn}{\pthnKeyword{in}}
\DeclareMathOperator{\pthnLambda}{\pthnKeyword{lambda}}
\DeclareMathOperator{\pthnMap}{map}
\DeclareMathOperator{\pthnPrint}{print}
\DeclareMathOperator{\pthnReturn}{\pthnKeyword{return}}
\DeclareMathOperator{\pthnRange}{range}
\DeclareMathOperator{\pthnReduce}{reduce}
\DeclareMathOperator{\pthnUp}{**}


\newcommand{\pthnNextLine}{$\blacktriangleright\blacktriangleright$}

\newcommand{\hsklType}[1]{\textbf{#1}}
\newcommand{\hsklTypeclass}[1]{\textsl{#1}}
\newcommand{\hsklTypeConstructor}[1]{\mathop{\mathrm{#1}}}

\DeclareMathOperator{\hsklApplicativeApply}{\S}
\DeclareMathOperator{\hsklApplicativeMap}{\times}
\DeclareMathOperator{\hsklApplicativeListMap}{\otimes}
\DeclareMathOperator{\hsklApplicativeMaybeMap}{\boxtimes}
\DeclareMathOperator{\hsklConcat}{\flat}
\DeclareMathOperator{\hsklFmap}{\cdot}
\DeclareMathOperator{\hsklHead}{head}
\DeclareMathOperator{\hsklListConstructor}{\hsklTypeConstructor{List}}
\DeclareMathOperator{\hsklMap}{\odot}
\DeclareMathOperator{\hsklMaybeConstructor}{\hsklTypeConstructor{Maybe}}
\DeclareMathOperator{\hsklMaybeAppend}{\boxplus}
\DeclareMathOperator{\hsklMaybeMap}{\boxdot}
\DeclareMathOperator{\hsklMonadMap}{\heartsuit}
\DeclareMathOperator{\hsklOf}{::}
\DeclareMathOperator{\hsklPred}{pred}
\DeclareMathOperator{\hsklSucc}{succ}
\DeclareMathOperator{\hsklTail}{tail}

\newcommand{\hsklAppend}{\oplus}
\newcommand{\hsklApplicative}{\hsklTypeclass{Applicative}}
\newcommand{\hsklBool}{\hsklType{Bool}}
\newcommand{\hsklChar}{\hsklType{Char}}
\newcommand{\hsklEmptyList}{\emptyset}
\newcommand{\hsklEnum}{\hsklTypeclass{Enum}}
\newcommand{\hsklInt}{\hsklType{Int}}
\newcommand{\hsklIntegral}{\hsklTypeclass{Integral}}
\newcommand{\hsklEq}{\hsklTypeclass{Eq}}
\newcommand{\hsklFloat}{\hsklType{Float}}
\newcommand{\hsklFunctor}{\hsklTypeclass{Functor}}
\newcommand{\hsklMonad}{\hsklTypeclass{Monad}}
\newcommand{\hsklMonadplus}{\hsklTypeclass{Monadplus}}
\newcommand{\hsklMonoid}{\hsklTypeclass{Monoid}}
\newcommand{\hsklNothing}{\varnothing}
\newcommand{\hsklNum}{\hsklTypeclass{Num}}
\newcommand{\hsklOrd}{\hsklTypeclass{Ord}}
\newcommand{\hsklReal}{\hsklTypeclass{Real}}

\newcommand{\hsklFunction}[1]{\Hat{#1}}
\newcommand{\hsklJust}[1]{\[#1\]}
\newcommand{\hsklList}[1]{\Bar{#1}}
\newcommand{\hsklListType}[1]{[#1]}
\newcommand{\hsklMaybe}[1]{\Tilde{#1}}
\newcommand{\hsklMaybeW}[1]{\widetilde{#1}}
\newcommand{\hsklMaybeType}[1]{\[#1\]}
\newcommand{\hsklPure}[1]{\langle#1\rangle_\textsf{pure}}
\newcommand{\hsklUnit}[1]{\langle#1\rangle_\textsf{unit}}

\newcommand{\hsklTypeConstruct}[2]{#1\,#2}

\newcommand{\mathKeyword}[1]{\mathbf{#1}}
\newcommand{\mathVarKeyword}[1]{\mathsf{#1}}

\DeclareMathOperator{\mathAnyBinaryOperator}{\bigstar}
\DeclareMathOperator{\mathInverse}{\sharp}
\DeclareMathOperator{\mathAnd}{\wedge}
\DeclareMathOperator{\mathApply}{\$}
\DeclareMathOperator{\mathAnyUnaryOperator}{\star}
\DeclareMathOperator{\mathCompose}{\bullet}
\DeclareMathOperator{\mathElse}{\mathKeyword{else}}
\DeclareMathOperator{\mathFactorial}{fact}
\DeclareMathOperator*{\mathFold}{\bigcup}
\DeclareMathOperator*{\mathFoldRight}{\bigsqcup}
\DeclareMathOperator{\mathFrom}{\in}
\DeclareMathOperator{\mathI}{i}
\DeclareMathOperator{\mathIf}{\mathKeyword{if}}
\DeclareMathOperator{\mathIn}{::}
\DeclareMathOperator{\mathInverse}{\neg}
\DeclareMathOperator{\mathLambda}{\backslash}
\DeclareMathOperator{\mathLet}{\mathKeyword{let}}
\DeclareMathOperator{\mathLetIn}{\mathKeyword{in}}
\DeclareMathOperator{\mathMapsTo}{\mapsto}
\DeclareMathOperator{\mathOr}{\vee}
\DeclareMathOperator{\mathSetTimes}{\circledast}
\DeclareMathOperator{\mathThen}{\mathKeyword{then}}
\DeclareMathOperator{\mathWhere}{\mathKeyword{where}}

\newcommand{\mathFirst}{\mathVarKeyword{first}}
\newcommand{\mathLambdaAnonymousParameter}{\lozenge}
\newcommand{\mathLambdaArrow}{\rightarrow}
\newcommand{\mathLeft}{\mathKeyword{left}}
\newcommand{\mathOtherwise}{\mathKeyword{otherwise}}
\newcommand{\mathRest}{\mathVarKeyword{rest}}
\newcommand{\mathRight}{\mathKeyword{right}}
\newcommand{\mathSomething}{\square}

\newcommand{\mathFunctor}[1]{\mathrm{#1}}
\newcommand{\mathGuard}[1]{\mathop{\mid_{#1}}}
\newcommand{\mathSet}[1]{\mathbf{#1}}
\newcommand{\mathSpecialSet}[1]{\mathbb{#1}}
\newcommand{\mathVector}[1]{\vec{#1}}

\newcommand{\mathCategoryShort}[2]{(#1,#2)}
\newcommand{\mathLambdaExpression}[2]{\mathLambda#1\mathLambdaArrow#2}
\newcommand{\mathMorph}[2]{#1\mathMapsTo#2}

\newcommand{\mathMonoid}[3]{(#1,#2,#3)}
\newcommand{\mathMorphII}[3]{#1\mathMapsTo#2\mathMapsTo#3}
\newcommand{\mathMorphIIWithParenthesis}[3]{#1\mathMapsTo(#2\mathMapsTo#3)}

\newcommand{\mathCategory}[4]{(#1,#2,#3,#4)}
\newcommand{\mathGroup}[4]{(#1,#2,#3,#4)}
\newcommand{\mathMorphIII}[4]{#1\mathMapsTo#2\mathMapsTo#3\mathMapsTo#4}

\newcommand{\mathField}[7]{(#1,#2,#3,#4,#5,#6,#7)}

\begin{document}
% \setlength{\baselineskip}{17pt}
\maketitle
\tableofcontents

\begin{table*}
\caption{凡例}
\begin{center}
\begin{tabular}{||c|c|c||}
\hline
種類&字体・表記法&例\\
\hline
定数&オイラー書体，大文字（1文字）&$T$, $F$, $I$\\
変数&オイラー書体，小文字（1文字）&$x$, $y$, $z$\\
関数&オイラー書体，小文字（1文字）&$f$, $g$, $h$\\
有名な関数&ローマン体，小文字で始める&$\sin$, $\cos$, $\tan$\\
集合と型&ボールドローマン体，大文字で始める&$\mathSet{S}$, $\hsklInt$, $\hsklFloat$\\
型パラメタ&ボールドローマン体，小文字（1文字）&$\hsklType{a}$, $\hsklType{b}$, $\hsklType{c}$\\
有名な集合&ブラックボード体，大文字（1文字）&$\mathSpecialSet{R}$, $\mathSpecialSet{Q}$, $\mathSpecialSet{Z}$\\
関手と型コンストラクタ&ローマン体，大文字で始める&$\mathFunctor{F}$, $\hsklListConstructor$, $\hsklMaybeConstructor$\\
型クラス&スラント体，大文字で始める&$\hsklEq$, $\hsklIntegral$\\
キーワード&ボールドローマン体，小文字で始める&$\mathIf$, $\mathOtherwise$\\
リストの構造&サンセリフ体&$\mathFirst$, $\mathRest$\\
\hline
リスト&ブラケットで包む&$[x,y,z]$\\
集合&ブレースで包む&$\{x,y,z\}$\\
組み合わせ（タプル）&丸括弧で包む&$(x,y,z)$\\
\hline
リスト変数&名前にバーをつける&$\hsklList{x}$\\
Maybe変数&名前にチルダをつける&$\hsklMaybe{x}$\\
関数変数&名前にハットをつける&$\hsklFunction{x}$\\
ベクトル変数&名前に矢印をつける&$\mathVector{x}$\\
\hline
Python定数&イタリック体，大文字で始める&\pthnId{True}, \pthnId{False}, \pthnId{None}\\
Python変数&イタリック体，小文字で始める&\pthnId{x}, \pthnId{y}, \pthnId{z}\\
Python関数&イタリック体，小文字で始める&\pthnId{f}, \pthnId{g}, \pthnId{h}\\
Pythonクラス名&ローマン体，大文字で始める&Perhaps\\
Pythonキーワード&ボールドローマン体，小文字で始める&\pthnKeyword{def}, \pthnKeyword{return}\\
Python演算子&タイプライタ体&\pthnOp{=}, \pthnOp{+}, \pthnOp{*}\\
Python文字列リテラル&タイプライタ体&\pthnString{"Hello, world."}\\
\hline
\end{tabular}
\end{center}
\end{table*}

\part{代数的構造とプログラミング}

\chapter{はじめに}

\begin{leader}
A...
\end{leader}

\section{数学とプログラミングの関係*}

A...

\section{Haskellという森}

Haskellというプログラミング言語を知ろうとすると，従来のプログラミング言語の知識が邪魔をする．モダンで，人気があって，Haskellから影響を受けた言語，例えばRubyやSwiftの知識さえ，Haskellを学ぶ障害になり得る．ではどのようにしてHaskellの深みに到達すればいいのだろうか．

その答えは，一見遠回りに見えるが，一度抽象数学の高みに登ることである．

と言っても，あわてる必要はない．

近代的なプログラミング言語を知っていれば，すでにある程度抽象数学に足を踏み入れているからである．

そこで，本書では近代的なプログラマを対象に，プログラミング言語を登山口に抽象数学の山を登り，その高みからHaskellという森を見下ろすことにする．

さて，登山口にどのプログラミング言語を選ぶのが適当であろうか．IEEE Spectrum による ``The 2015 Top Ten Programming Languages'' という記事によると「ビッグファイブ」として Java, C, \cxx, Python, C\texttt{\#} が挙げられている．そこで本書では，多くのプログラマが読めて，シンプルに記述ができ，なおかつHaskellと対極にある言語であるPython（バージョン3）を登山口に選ぶことにした．Pythonコードはこのように登場する．
\begin{pythoncode}
\begin{python}
\pthnId{print}(\pthnString{"Hello, world."})
\end{python}
\end{pythoncode}
本文中に登場するPythonコードは文字通り打ち込めばそのまま使える．
% が，比較演算子$\equiv$だけはキーボードにない記号なので\code{==}に置き換えてもらいたい．

また，一部の章でどうしても型に触れないといけない部分がある．Pythonは動的型付け言語であり，型の説明には不適切であるため，この部分だけ理解の助けとして\cxx によるコードを例示した．この部分はコードを読まなくても先に進める． （Javaではなく\cxx を採用したのは OS X がJavaを排除するからである．型システムに関する限り\cxx よりもJavaのほうが簡潔に記述できるが，致し方無い．）

本書は3部構成になっている．第I部はプログラミング言語から抽象数学への登山である．第II部は抽象数学の山頂からHaskellの森へ下っていく道である．第III部はこれまで歩いた道全体を俯瞰する．

第I部は対応するHaskellのコードを脚注に記載している．脚注部分はHaskellを一通り覚えた後で読み返してもらいたい．\footnote{Haskellのコードは\code{x = 1}のようにタイプライタ体で書く．}

\section{関数型プログラミング*}

\keyword{破壊的代入}はだめ．

\section{余計な話*}

A...

\chapter{カリー風な書き方}

\begin{leader}
本書では一般の数学書やプログラミングの教科書からは少し異なった記法を用いる．ある概念が発明されてからずっと後になって正しい記法が見つかり，それがきっかけとなって正しく理解されるという現象は歴史上よくあることである．本書でも様々な新しい記号，記法を導入するが，この章では既に比較的広く知られている記法を紹介する．
\end{leader}

\section{関数}

数学やプログラミミング言語には書き方に一定の決まりがある．この章ではまず「カリー風の」数式記述方式を見てみることにする．「カリー風」というのは，数学者ハスケル・カリーから名前を借りた言い方で，筆者が勝手に命名したものだ．

カリー風の書き方は数学の教科書やプログラミングの教科書で見かけるものとは若干違うが，圧倒的にシンプルで，Haskellとの親和性も高く，慣れてくると非常に読みやすいものなので，本書でも全面的に採用する．

まずは\keyword{関数}から見ていくことにしよう．Pythonや一般的な数学書では引数$x$をとる関数$f$を
\begin{pythoncode}
\begin{python}
\pthnId{f}(\pthnId{x})
\end{python}
\end{pythoncode}
と書くが，括弧は冗長なので今後は$fx$と書くことにする．

本書ではPythonのコード片は上述のように囲みにいれることにし，Pythonコードに現れる変数名や関数名は\pthnId{f}や\pthnId{x}のようにイタリック体で書くことにする．またカリー風の数式記法ではオイラー書体を使って$f$や$x$のように書くことにする．

関数$f$に引数$x$を「食わせる」ことを\keyword{関数適用}と呼ぶ．もし$fx$と書いてあったら，それは$f*x$ではなくて従来の$f(x)$すなわち関数$f$に引数$x$を与えているものと解釈する．\footnote{Haskellでは関数\code{f}に引数\code{x}を適用させることを \code{f x} と書く．}

複数引数をとる関数をPythonでは
\begin{pythoncode}
\begin{python}
\pthnId{g}(\pthnId{x}, \pthnId{y})
\end{python}
\end{pythoncode}
と書くが，これも括弧が冗長なので今後は$gxy$と書く．この場合式$gxy$は左を優先して結合する．つまり
\begin{equation}
gxy=(gx)y
\end{equation}
である．引数に「飢えた」関数$(gx)$を\keyword{部分適用}された関数と呼ぶ．

このように式の左側を優先的に演算していくことを\keyword{左結合}と呼ぶ．関数適用は左結合である．

\section{ラムダ式}

引数$x$をとり値$1+x$を返す\keyword{ラムダ式}をPythonでは
\begin{pythoncode}
\begin{python}
\pthnKeyword{lambda} \pthnId{x}: $1$ \pthnOp{+} \pthnId{x}
\end{python}
\end{pythoncode}
と書くが，我々は
\begin{equation*}
\mathLambdaExpression{x}{1+x}
\end{equation*}
と書くことにする．この式はラムダ式を発明したチャーチのオリジナルの論文の記法であれば$\Hat x\,.\,1+x$と書かれたところであり，現在でも多くの書物で$\lambda x\,.\,1+x$と記述されるところである．
しかし我々はすべてのギリシア文字を変数名のために予約しておきたいのと，ピリオド記号$(.)$が今後登場する二項演算子$\cdot$と紛らわしいため，上述の記法を用いる．\footnote{Haskellではラムダ式$\mathLambdaExpression{x}{1+x}$を \code{\textbackslash x -> 1 + x} と書く．}

ラムダ式は関数である．ラムダ式を適用するには，ラムダ式を括弧で包む必要がある．例を挙げる．
\begin{equation*}
\left(\mathLambdaExpression{x}{1+x}\right)2
\end{equation*}
この式は結果として$3$を返す．

複数引数をとるラムダ式は例えば
\begin{equation*}
\mathLambdaExpression{xy}{x+y}
\end{equation*}
のように引数を並べて書く．

本書では新たに，次のラムダ式記法も導入する．式中に記号$\mathLambdaAnonymousParameter$が現れた場合，その式全体がラムダ式であるとみなす．記号$\mathLambdaAnonymousParameter$の部分には引数が入る．第$n$番目の$\mathLambdaAnonymousParameter$には第$n$番目の引数が入る．例えばラムダ式$\mathLambdaExpression{xy}{x+y}$は
\begin{equation*}
\mathLambdaAnonymousParameter+\mathLambdaAnonymousParameter
\end{equation*}
と書いても良い．式を左から読んで1番目の$\mathLambdaAnonymousParameter$が元々の$x$すなわち第1引数を，2番目の$\mathLambdaAnonymousParameter$が元々の$y$すなわち第2引数を意味する．この省略記法はプログラミング言語Schemeにおけるcutプロシジャに由来する．\footnote{この記法はHaskellにはない．}

% let, where.


\section{関数定義}

関数$f$を$fx=1+x$としたいときに，Pythonでは
\begin{pythoncode}
\begin{python}
\pthnKeyword{def} \pthnId{f}(\pthnId{x}):\\
\>\pthnKeyword{return} $1$ \pthnOp{+} \pthnId{x}
\end{python}
\end{pythoncode}
と書くことが普通である．これは，ある値をとってある値を返す関数の記述方法としてはいささかオーバーキルである．事実，ラムダ式を用いた
\begin{pythoncode}
\begin{python}
\pthnId{f} \pthnOp{=} \pthnKeyword{lambda} \pthnId{x}: $1$ \pthnOp{+} \pthnId{x}
\end{python}
\end{pythoncode}
も全く同じ意味になるので，ラムダ式を使う方法を基本に据えよう．

関数の定義は，基本的にはラムダ式の変数への代入である．引数$x$をとり値$1+x$を返す関数$f$は
\begin{equation}
f=\mathLambdaExpression{x}{1+x}
\end{equation}
と定義できる．ただし，この省略形として
\begin{equation}
fx=1+x
\end{equation}
と書いても良い．\footnote{Haskellでは$f=\mathLambdaExpression{x}{1+x}$を\code{f = \textbackslash x -> 1 + x}，$fx=1+x$を\code{f x = 1 + x}と書く．}

関数に\keyword{スペシャルバージョン}がある場合はそれらを列挙する．例えば引数が$0$の場合は特別に戻り値も$0$であり，その他の場合は関数$f$と同じ振る舞いをする関数$f'$を考える．このとき$f'$は
\begin{equation}
\left\{
\begin{split}
f'0&=0\\
f'x&=1+x
\end{split}
\right.
\end{equation}
ように定義する．\footnote{Haskellでは
\begin{Verbatim}[xleftmargin=10mm]
f' 0 = 0
f' x = 1 + x
\end{Verbatim}
と書く．}

関数定義に\keyword{場合分け}が必要な場合は\keyword{ガード}を用いる．例えば引数の値が負の場合は$-1$を，$0$の場合は$0$を，それ以外の場合は関数$f$と同じ振る舞いをする関数$f''$は
\begin{equation}
\begin{split}
f''x&\mathGuard{x<0}=-1\\
&\mathGuard{x\equiv 0}=0\\
&\mathGuard{\mathOtherwise}=1+x
\end{split}
\end{equation}
という風に定義する．\footnote{Haskellでは
\begin{Verbatim}[xleftmargin=10mm]
f'' x | x < 0     = -1
      | x == 0    = 0
      | otherwise = 1 + x
\end{Verbatim}
と書く．}

Pythonにはスペシャルバージョンやガードに相当する文法はない．

\section{余計な話：局所変数}

数式が長く続くとき，読みやすさのために局所変数を導入すると便利である．例えば
\begin{equation}
y=f(100*x+50)
\end{equation}
という式のうち，先に$100*x+50$の部分に名前をつけておきたいこともあるであろう．そんなときは
\begin{equation}
\label{eq:letin}
y=\mathLet(x'=100*x+50)\mathLetIn fx'
\end{equation}
と書くことにする．このようにして導入された$x'$を\keyword{局所変数}と呼ぶ．

式\eqref{eq:letin}は局所変数を後ろに回して
\begin{equation}
y=fx'\mathWhere x'=100*x+50
\end{equation}
のように書いても良い．式\eqref{eq:letin}はラムダ式を使った糖衣構文であり，一般に
\begin{equation}
\mathLet(x'=gx)\mathLetIn fx'=(\mathLambdaExpression{x'}{fx'})(gx)
\end{equation}
である．\footnote{Haskellでは\code{y = let x' = 100 * x + 50 in f x'}および\code{y = f x' where x' = 100 * x + 50}のように書く．}


\chapter{さらにカリー風な書き方}

\begin{leader}
A...
\end{leader}

\section{演算子}

\keyword{演算子}は関数の特別な姿である．演算子は作用素と呼んでも良い．どちらも英語のoperatorの和訳である．演算子は普通アルファベット以外のシンボル1個で表現し，変数や関数の前に置いて直後の変数や関数に作用させるか，2個の変数や関数の中間に置いてその両者に作用させる．簡単に言うと$-x$のマイナス記号$(-)$は変数の前に置いて直後の変数$(x)$に作用する演算子であり，$x+y$のプラス記号$(+)$は2個の変数の間に置いてその両者$(x,y)$に作用する．

1個の変数または関数に作用する演算子を\keyword{単項演算子}と呼び，2個の変数または関数に作用する演算子を\keyword{二項演算子}と呼ぶ．本書では単項演算子いつも変数の前に置く，すなわち\keyword{前置}する．わざわざこう断るのは，数学者がたまに単項演算子を変数の前以外に置くからである．例えば自然数$n$の階乗を数学者はしばしば$n!$と書くし，実数$x$の逆数（乗法逆元）を$x^{-1}$と書く．実際，このふたつだけは本書でも例外的に前置しない単項演算子とする．

二項演算子のうちよく使われるものは和$(+)$，積$(*)$，論理和$(\vee)$，論理積$(\wedge)$，同値$(\equiv)$，大なり$(>)$，小なり$(<)$等である．二項演算子はたとえ積記号であっても省略できない．二項演算子は多数あるので，その都度説明する．

二項演算子は中置することが基本であるが，括弧で包むことで前置することも可能である．任意の二項演算子$\mathAnyBinaryOperator$について$x\mathAnyBinaryOperator y$及び$(\mathAnyBinaryOperator)xy$は全く同じ意味である．すなわち
\begin{equation}
(\mathAnyBinaryOperator)xy=x\mathAnyBinaryOperator y
\end{equation}
である．従って，二項演算子と2引数関数に本質的な差はない．本書では演算子と関数という用語は全く同じ意味で用いる．\footnote{Haskellでは任意の二項演算子を括弧で包むことで前置演算子として使うことができる．例えば\code{x + y}と \code{(+)x y} は同じ結果を返す．逆に任意の二引数関数\code{f}は \code{x `f` y} と書くことで中置することができる．}

二項演算子の結合性，すなわち左結合か右結合かは，演算子によって異なる．

演算の優先順位を明示的に与えるために括弧が用いられる．

本書では3個の変数に同時に作用する演算子は扱わない．

\section{関数合成演算子と関数適用演算子}

ある変数に複数の関数を順に適用することはよくあることである．例えば
\begin{pythoncode}
\begin{python}
$y=g(x)$\\
$z=f(y)$
\end{python}
\end{pythoncode}
あるいは，同じことであるが
\begin{pythoncode}
\begin{python}
$z=f(g(x))$
\end{python}
\end{pythoncode}
とすることがある．

ここで，引数のことは忘れて，関数$f$と関数$g$を先に\keyword{合成}しておきたいとしよう．その合成を$f\mathCompose g$と書く．合成はラムダ式を使って
\begin{equation}
f\mathCompose g=f(g\mathLambdaAnonymousParameter)
\end{equation}
と定義できる．関数合成の演算子$\mathCompose$は関数適用よりも優先順位が高く，$(f\mathCompose g)x$は単に$f\mathCompose g\,x$と書いても良い．この記法は括弧の数を減らすためにしばしば用いられる．\footnote{Haskellでは関数\code{f}と関数\code{g}の合成は\code{f.g}である．}

関数合成演算子とは逆に，優先順位の低い\keyword{関数適用演算子}も考えておくと括弧の数を減らすのに便利である．関数適用演算子$\mathApply$を次のように定義しておく．
\begin{equation}
f\mathApply gx=f(gx)
\end{equation}

演算子$\mathApply$の優先順位は足し算演算子よりも低いものとする．よって$f(x+1)$は$f\mathApply x+1$と書くこともできる．\footnote{Haskellでは$f\mathApply gx$を\code{f \$ g x}と書く．}

\section{条件分岐と再帰}

関数のスペシャルバージョン，場合分けを駆使すれば\keyword{条件式}はなくても構わないが，条件式の記法があるのは便利である．Pythonには
\begin{pythoncode}
\begin{python}
\pthnKeyword{def} \pthnId{f}(\pthnId{x})\\
\>\pthnKeyword{if} \pthnId{x} \pthnOp{==} $0$:\\
\>\>\pthnKeyword{return} $0$\\
\>\pthnKeyword{else}:\\
\>\>\pthnKeyword{return} $1$ \pthnOp{+} \pthnId{x}
\end{python}
\end{pythoncode}
のような\keyword{制御構造}としての条件文があるが，我々は値を持つ条件式を考える．

我々の条件式とは
\begin{equation}
fx=\mathIf x\equiv0\mathThen0\mathElse1+x
\end{equation}
のように$\mathIf$節，$\mathThen$節，及び$\mathElse$節からなるものであって，$\mathThen$節も$\mathElse$節も省略できないものとする．$\mathIf$節の式の値が真$(T)$であれば$\mathThen$節の式が評価され，偽$(F)$であれば$\mathElse$節の式が評価される．\footnote{Haskellでは$fx=\mathIf x\equiv0\mathThen0\mathElse1+x$を\code{f x = if x == 0 then 0 else 1+x}と書く．}

$\mathIf$節の中身は真理値を返す関数であれば良いので，関数$p$を
\begin{equation}
p=(\equiv)0
\end{equation}
としておき，
\begin{equation}
fx=\mathIf px\mathThen0\mathElse1+x
\end{equation}
と書く方法もしばしば用いられる．

条件式は紙面が許せば次のように書いても良い．
\begin{equation}
fx=\begin{cases}
0&\mathIf x\equiv0\\
1+x&\mathOtherwise
\end{cases}
\end{equation}
左ブレース（中括弧）の位置が関数のスペシャルバージョンの定義の時と異なっていることに注目しよう．

関数は内部で自分自身を呼んでも良い．例えば$x$の階乗$(x!)$を返す関数$\mathFactorial x=x!$は
\begin{equation}
\mathFactorial x=\begin{cases}
1&\mathIf x\equiv0\\
x*\mathFactorial(x-1)&\mathOtherwise
\end{cases}
\end{equation}
と定義できる．関数が自分自身を呼び出すことを関数の\keyword{再帰呼び出し}と呼ぶ．

我々は関数の適用，変数の代入，ラムダ式，条件式，再帰の方法を学んだわけである．これだけあれば，原理的にはどのようなアルゴリズムも書くことができる．今日からはカリー風な数学であらゆるアルゴリズムを表現できるのである！

\section{余計な話：末尾再帰}

計算機科学者は，同じ再帰でも\keyword{末尾再帰}という再帰のスタイルを好む．末尾再帰とは，関数の再帰呼び出しを関数定義の末尾にすることである．この章に出てきた階乗関数$\mathFactorial$を例にとろう．階乗関数$\mathFactorial$は
\begin{equation*}
\mathFactorial x=\begin{cases}
1&\mathIf x\equiv0\\
x*\mathFactorial(x-1)&\mathOtherwise
\end{cases}
\end{equation*}
のような形をしていた．末尾の関数をよりはっきりさせるために演算子$*$を前置にして
\begin{equation}
\mathFactorial x=\begin{cases}
1&\mathIf x\equiv0\\
(*)x\mathFactorial(x-1)&\mathOtherwise
\end{cases}
\end{equation}
と書いてみよう．この定義の末尾の式は
\begin{equation*}
(*)x\mathFactorial(x-1)
\end{equation*}
である．これだと末尾の関数は$\mathFactorial$ではなく演算子$(*)$なので，末尾に再帰呼び出しを行ったことにはならない．

そこで，次のように形を変えた階乗関数$\mathFactorial'$を考えてみる．
\begin{equation}
\mathFactorial'ax=\begin{cases}
1&\mathIf x\equiv0\\
\mathFactorial'(a*x)(x-1)&\mathOtherwise
\end{cases}
\end{equation}
こうすれば末尾の関数が大元の$\mathFactorial'$と一致する．

関数$\mathFactorial$と違い関数$\mathFactorial'$は引数を2個とる．関数$\mathFactorial'$を使って$x$の階乗を求める場合は$\mathFactorial'1x$と第1引数に$1$を与えることにする．この第1引数$a$はアキュムレータという．アキュムレータが演算の途中経過を引き渡していくイメージを描けば，末尾再帰の意味が理解できる．

計算機科学者が末尾再帰を好む理由は，幾つかのプログラミング言語処理系が\keyword{末尾再帰最適化}を行うからである．末尾再帰最適化とは，一言で言うと再帰をコンピュータが扱いやすいループに置き換えることである．では最初から我々もループで関数を表現しておけば，と思われるかもしれないが，再帰以外の方法でループを表現する場合には必ず変数への破壊的代入が必要になるため，我々は末尾再帰に慎ましくループを隠すのである．

% Y combinator

\chapter{代数的構造}

\begin{leader}
この章では「代数的構造」を見ていくことにする．代数的構造とは，四則演算のような数に関する基本的な性質を抽象化していくことで，数の背後にある基本的なメカニズムを抽出したものである．代数的構造はあらゆるプログラミング言語に明示的，あるいは非明示的に見られる要素である．
\end{leader}

\section{数}

これから各種の\keyword{代数的構造}を見ていくことにする．代数的構造と言っても，身構える必要はない．それは，我々プログラマが日々接している概念に，共通した名前を与えたにすぎない．

まず最初に，我々にとって一番身近な代数的構造である\keyword{数}を見てみよう．数の代表例は\keyword{実数}であるから，実数を例にとって考えてみよう．実数全体の集合を$\mathSpecialSet{R}$で表すことにする．また任意の実数を$x,y,z$で表すこととする．このことを数学者は$x,y,z\in\mathSpecialSet{R}$と書くが，我々は記号$\in$を別の用途に使いたいので，本書では
\begin{equation*}
x,y,z\mathIn\mathSpecialSet{R}
\end{equation*}
と表すことにする．

以下に実数の備える代数的性質を列挙する．どれも当たり前のことに見えるが，ひとつひとつ見ていこう．ここで$x,y,z\mathIn\mathSpecialSet{R}$とする．
\begin{description}
\item[実数の性質1. 足し算] 任意の$x$と任意の$y$の足し算（\keyword{加法}）の結果（\keyword{和}）$x+y$は$\mathSpecialSet{R}$の元すなわち実数である．
\item[実数の性質2. 足し算の結合則] 任意の$x,y,z$について
\begin{equation}
(x+y)+z=x+(y+z)
\end{equation}
である．これを\keyword{結合則}と呼ぶ．
\item[実数の性質3. 零元（加法単位元）の存在] 特別な実数$0\mathIn\mathSpecialSet{R}$があり
\begin{equation}
0+x=x+0=x
\end{equation}
である．この$0$は足し算の\keyword{単位元}である．\keyword{零元}または\keyword{加法単位元}と呼ぶこともある．
\item[実数の性質4. 負元（加法逆元）の存在] 任意の$x$に対して$-x\mathIn\mathSpecialSet{R}$があり
\begin{equation}
-x+x=0
\end{equation}
である．この$-x$は$x$の足し算の\keyword{逆元}である．\keyword{負元}または\keyword{加法逆元}と呼ぶこともある．
\item[実数の性質5. 足し算の可換性] 任意の$x,y$について
\begin{equation}
x+y=y+x
\end{equation}
である．このことを足し算の\keyword{可換性}と呼ぶ．
\item[実数の性質6. 掛け算] 任意の$x$と任意の$y$の掛け算（\keyword{乗法}）の結果（\keyword{積}）$x*y$は$\mathSpecialSet{R}$の元すなわち実数である．
\item[実数の性質7. 掛け算の結合則] 任意の$x,y,z$について
\begin{equation}
(x*y)*z=x*(y*z)
\end{equation}
である．
\item[実数の性質8. 単位元の存在] 特別な実数$1\mathIn\mathSpecialSet{R}$があり
\begin{equation}
1*x=x*1=x
\end{equation}
である．この$1$を掛け算の単位元または\keyword{乗法単位元}と呼ぶ．
\item[実数の性質9. 逆元の存在] 任意の$x$に対して$x^{-1}\mathIn\mathSpecialSet{R}$があり
\begin{equation}
x^{-1}*x=1
\end{equation}
である．この$x^{-1}$は$x$の掛け算の逆元である．\keyword{乗法逆元}と呼ぶこともある．ただし性質11で述べる通り，加法単位元については逆元がなくても良い．
\item[実数の性質10. 掛け算の可換性] 任意の$x,y$について
\begin{equation}
x*y=y*x
\end{equation}
である．このことを掛け算の可換性と呼ぶ．
\item[実数の性質11. 加法単位元の乗法逆元] 加法単位元に対する掛け算の逆元は存在しなくても良い．（つまり$0^{-1}$のことは考えなくて良い．）
\item[実数の性質12. 分配則] 足し算と掛け算が混在する場合
\begin{equation}
(x+y)*z=(x*z)+(y*z)
\end{equation}
と掛け算を\keyword{分配}する．
\end{description}
以上が実数の代数的性質の全てである．我々がよく使う引き算，割り算は数学上は糖衣構文 (syntax sugar) である．

上述の12個の条件が当てはまる数には，\keyword{有理数}や\keyword{複素数}がある．この12個の性質をまとめて，数学では\keyword{体}と呼ぶ．

体の要素は，集合$\mathSet{K}$，二項演算子$+$，二項演算子$+$の単位元$0$，二項演算子$+$の逆元生成演算子$-$，もう一つの二項演算子$*$，二項演算子$*$の単位元$1$，二項演算子$*$の逆元生成演算子$\mathSomething^{-1}$であるから，体はそれらを列挙して$\mathField{\mathSet{K}}{+}{0}{-}{*}{1}{\mathSomething^{-1}}$と表現する．

体の性質から言えることを一つ紹介しよう．これから
\begin{equation}
z\uparrow n=\underbrace{z*\dotsb*z}_n
\end{equation}
なる二項演算子$\uparrow$（\keyword{クヌースの矢印}）を使う．ここに$z$を体$\mathField{\mathSet{K}}{+}{0}{-}{*}{1}{\mathSomething^{-1}}$の$\mathSet{K}$の元，$n$を自然数とした．さて$z\uparrow2$は
\begin{equation}
z\uparrow2=z*z
\end{equation}
であるから，いま$z=x+y$とすると
\begin{align}
z\uparrow2&=z*z\\
&=z*(x+y)\\
&=z*x+z*y\;\dots\;\text{分配則}\\
&=(x+y)*x+(x+y)*y\\
&=x*x+y*x+x*y+y*y\;\dots\;\text{分配則}\\
&=x\uparrow2+x*y+y*x+y\uparrow2
\end{align}
となり
\begin{equation}
\label{eq:xysq}
(x+y)\uparrow2=x\uparrow2+x*y+y*x+y\uparrow2
\end{equation}
を得る．式\eqref{eq:xysq}は体の性質だけを使って導いた関係なので，実数だけでなく有理数や複素数にもそのまま使える．実際には式\eqref{eq:xysq}は体の性質のうち分配則だけを使っいるので，体以外にも応用が利く式である．

\begin{table*}
\caption{代表的な代数的構造の性質(1)}
\label{tab:field-and-ring}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c||}
\hline
代数的構造&$\mathAnyBinaryOperator_1$&$\mathAnyBinaryOperator_1$の単位元&$\mathAnyBinaryOperator_1$の逆元&$\mathAnyBinaryOperator_2$&$\mathAnyBinaryOperator_2$の単位元&$\mathAnyBinaryOperator_2$の逆元\\
\hline\hline
体&可換&あり&あり&可換&あり&あり\\
環&可換&あり&あり&非可換&あり&なし\\
\hline
\end{tabular}
\end{center}
\end{table*}

\section{群}

体の性質を若干緩めたい場合がある．さもなければ，\keyword{整数}，\keyword{正方行列}，\keyword{クォータニオン}（四元数），\keyword{論理値}，\keyword{ベクトル}，ベクトルの\keyword{変換}，集合から集合への\keyword{写像}と言った重要な概念が数の概念からこぼれてしまうからである．例えば整数の掛け算の逆元は（単位元の逆元を除いて）整数の中には存在しないし，正則行列やクォータニオンの場合は掛け算が可換ではない．

だいたいどの辺まで制約を緩めたものを数の仲間に入れるかというのは見解の分かれるところでもあるが，体から性質9（掛け算の逆元），性質10（掛け算の可換性），性質11（加法単位元の乗法逆元）を取り除いたものを\keyword{環}と呼び，環の性質を持つものを数の仲間に入れることが一般的である．環の性質を持つものは，体である実数，有理数，複素数に加えて，整数，正方行列，クォータニオン，論理値などがある．

制約を少しずつ緩める代わりに，制約をその構成要素に分解するほうがさらなる応用が利きそうである．体には二つの二項演算子$+$と$*$が登場した．その片方にのみ注目してみたらどうなるだろう．それがこの節で取り上げる\keyword{群}である．

形式的に二項演算子$+$を$\mathAnyBinaryOperator_1$とし，二項演算子$*$を$\mathAnyBinaryOperator_2$として，体と環の性質を並べたものが表\ref{tab:field-and-ring}である．これを見ると，演算子$\mathAnyBinaryOperator$について「可換・単位元あり・逆元あり」の組み合わせが二つペアになったもの（体）か，「可換・単位元あり・逆元あり」の組み合わせと「非可換・単位元あり・逆元なし」の組み合わせがペアになったもの（環）があり，その構成要素は二項演算子$\mathAnyBinaryOperator$について「可換・単位元あり・逆元あり」と「非可換・単位元あり・逆元なし」の2種類であることがわかる．

いま集合$\mathSet{G}$があり，$x,y,z\mathIn\mathSet{G}$であるとし，二項演算子を$\mathAnyBinaryOperator$と書くことにして，体の性質の前半分を書き下してみよう．
\begin{description}
\item[性質1.] 任意の$x$と任意の$y$の演算の結果$x\mathAnyBinaryOperator y$は$\mathSet{G}$の元である．
\item[性質2.] 任意の$x,y,z$について
\begin{equation}
(x\mathAnyBinaryOperator y)\mathAnyBinaryOperator z=x\mathAnyBinaryOperator(y\mathAnyBinaryOperator z)
\end{equation}
である．
\item[性質3.] 特別な元$O\mathIn\mathSet{G}$があり
\begin{equation}
O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x
\end{equation}
である．
\item[性質4.] 任意の$x$に対して$\mathInverse x\mathIn\mathSet{G}$があり
\begin{equation}
\mathInverse x\mathAnyBinaryOperator x=O
\end{equation}
である．
\item[性質5.] 任意の$x,y$について
\begin{equation}
x\mathAnyBinaryOperator y=y\mathAnyBinaryOperator x
\end{equation}
である．
\end{description}
このような性質が満たされる時，組み合わせ$\mathGroup{\mathSet{G}}{\mathAnyBinaryOperator}{O}{\mathInverse}$を\keyword{可換群}または\keyword{加群}と呼ぶ．この可換群が最初の構成要素「可換・単位元あり・逆元あり」の正体である．

例えば$\mathGroup{\mathSpecialSet{R}}{+}{0}{-}$は可換群である．整数全体の集合を$\mathSpecialSet{Z}$とすると$\mathGroup{\mathSpecialSet{Z}}{+}{0}{-}$も可換群である．また，集合$\mathSpecialSet{R}$から$0$だけを取り除いた集合を$\mathSpecialSet{R}\setminus0$とするとき$\mathGroup{\mathSpecialSet{R}\setminus0}{*}{1}{\mathSomething^{-1}}$も可換群である．

可換群は代表的な代数的構造のひとつであり，他にも数学のあちこちに顔を出している．例えば回転角を$t$とする二次元の回転変換を$R_t$として，回転変換$R_t$すべてからなる集合$\mathSet{R}$を考えてみよう．回転の合成を$\bullet$で表すとすると
\begin{equation}
\label{eq:rotation}
R_{t_1}\bullet R_{t_2}=R_{(t_1+t_2)}
\end{equation}
であるから，回転を合成した結果も回転である．また式\eqref{eq:rotation}から
\begin{equation}
R_{t_1}\bullet\left(R_{t_2}\bullet R_{t_3}\right)=\left(R_{t_1}\bullet R_{t_2}\right)\bullet R_{t_3}
\end{equation}
であるから，回転変換は結合則も満たしている．

次にに回転変換に単位元があるかどうか調べてみよう．回転しない変換は\keyword{恒等変換}とも言い，しばしば$I$で表す．何もしない回転変換は$0$度の回転であるから$I=R_0$である．このとき式\eqref{eq:rotation}から
\begin{equation}
I\bullet R_t=R_t\bullet I=R_t
\end{equation}
であるから，$I$は回転変換の単位元であると言える．

最後に回転変換に逆元があるかも調べてみよう．$t$回転の逆は明らかに$-t$であるから
\begin{equation}
R_{-t}\bullet R_t=R_t\bullet R_{-t}=I
\end{equation}
が成り立つ．そこで
\begin{equation}
{R_t}^{-1}=R_{-t}
\end{equation}
として$R_t$の逆元${R_t}^{-1}$を定義することができる．

このように，組み合わせ$\mathGroup{\mathSet{R}}{\bullet}{I}{\mathSomething^{-1}}$も可換群である．（回転$R_t$全体の集合$\mathSet{R}$が群を形成することは，パラメタ$t$が所属する実数全体の集合$\mathSpecialSet{R}$が群を形成することに大いに頼っている．この部分を詳細に調べるとリー群という美しい代数的構造が見つかる．）

回転されるものをベクトルと呼ぶ．ベクトルや回転変換の実装方法はいくつかあり，例えば第1座標値を$u$，第2座標値を$v$としたときにベクトル$\mathVector{p}$を
\begin{equation}
\mathVector{p}=\begin{bmatrix}u\\v\end{bmatrix}
\end{equation}
と表した場合，回転変換は
\begin{equation}
R_t=\begin{bmatrix}\cos t&-\sin t\\\sin t&\cos t\end{bmatrix}
\end{equation}
と行列で表すことになり，回転後のベクトル$\mathVector{p'}$は
\begin{equation}
\mathVector{p'}=R_t*\mathVector{p}
\end{equation}
となる．ここに演算子$*$は行列の積である．また，この場合変換の合成$\mathCompose$は行列積$*$となる．

他にもベクトルを複素数で表現する方法もある．いま$\mathVector{p}$を
\begin{equation}
\mathVector{p}=u+\mathI v
\end{equation}
と表して，回転変換$R_t$を
\begin{equation}
R_t=\cos t+\mathI\sin t
\end{equation}
とすると，回転後の$\mathVector{p'}$はやはり
\begin{equation}
\mathVector{p'}=R_t*\mathVector{p}
\end{equation}
と書ける．ここに演算子$*$は複素数の積である．また，この場合変換の合成$\mathCompose$も複素数積$*$となる．

任意次元のベクトル全体からなる集合を$\mathSet{V}$として，零ベクトルを$\mathVector{z}$で表すことにしよう．ここでも矢印はベクトルであることを忘れないようにするための飾りである．ベクトル同士の加算を二項演算子$+$で表し，向きを反転させた逆ベクトル作る演算子を$-$とすると，組み合わせ$\mathGroup{\mathSet{V}}{+}{\mathVector{z}}{-}$もまた可換群である．

可換群の性質のうち最初の4項目だけを満たすものを群と呼ぶ．可換群は群の特別な場合である．現代の数学では$x\mathAnyBinaryOperator y\neq y\mathAnyBinaryOperator x$のように演算子の前後を入れ替えると結果が異なるような演算をよく取り扱うので，一般の群は可換群よりもよく取り上げられ，それ故より短い名前が付けられている．

もう一度組み合わせ$\mathGroup{\mathSet{G}}{\mathAnyBinaryOperator}{O}{\mathInverse}$が群である条件を見ておこう．それは
\begin{description}
\item[群の性質1.] 任意の$x$と任意の$y$の演算の結果$x\mathAnyBinaryOperator y$は$\mathSet{G}$の元である．
\item[群の性質2. 結合則] 任意の$x,y,z$について
\begin{equation}
(x\mathAnyBinaryOperator y)\mathAnyBinaryOperator z=x\mathAnyBinaryOperator(y\mathAnyBinaryOperator z)
\end{equation}
である．
\item[群の性質3. 単位元の存在] 特別な元$O\mathIn\mathSet{G}$があり
\begin{equation}
O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x
\end{equation}
である．
\item[群の性質4. 逆元の存在] 任意の$x$に対して$\mathInverse x\mathIn\mathSet{G}$があり
\begin{equation}
\mathInverse x\mathAnyBinaryOperator x=O
\end{equation}
である．
\end{description}
であった．これらの条件を少し緩め，逆元が存在しなくても良い「緩やかな群」を考えてみる．この「緩やかな群」のことを\keyword{単位的半群}または\keyword{モノイド}と呼ぶ．これが構成要素「非可換・単位元あり・逆元なし」の正体である．

\begin{table}
\caption{代表的な代数的構造の性質 (2)}
\label{tab:group-and-monoid}
\begin{center}
\begin{tabular}{||c||c|c|c||}
\hline
代数的構造&$\mathAnyBinaryOperator$&$\mathAnyBinaryOperator$の単位元&$\mathAnyBinaryOperator$の逆元\\
\hline\hline
可換群&可換&あり&あり\\
群&非可換&あり&あり\\
単位的半群&非可換&あり&なし\\
半群&非可換&なし&なし\\
\hline
\end{tabular}
\end{center}
\end{table}

単位的半群の性質は次の三つである．ただし$x,y,z$が集合$\mathSet{M}$の元であるとする．
\begin{description}
\item[単位的半群の性質1.] 任意の$x$と任意の$y$の演算の結果$x\mathAnyBinaryOperator y$は$\mathSet{M}$の元である．
\item[単位的半群の性質2. 結合則] 任意の$x,y,z$について
\begin{equation}
(x\mathAnyBinaryOperator y)\mathAnyBinaryOperator z=x\mathAnyBinaryOperator(y\mathAnyBinaryOperator z)
\end{equation}
である．
\item[単位的半群の性質3. 単位元の存在] 特別な元$O\mathIn\mathSet{M}$があり
\begin{equation}
O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x
\end{equation}
である．
\end{description}
このとき，組み合わせ$\mathMonoid{\mathSet{M}}{\mathAnyBinaryOperator}{O}$が単位的半群である．可換群とこの単位的半群を組み合わせたのが環，可換群二つを組み合わせたのが体であった．

なお，これまで単位元の定義として
\begin{equation*}
O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x
\end{equation*}
を掲げているが，厳密には単位元は
\begin{equation}
O_\mathLeft\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O_\mathRight=x
\end{equation}
のように，\keyword{左単位元}と\keyword{右単位元}を区別しても良い．

単位的半群の性質からさらに性質3を消したものを\keyword{半群}と呼ぶ．可換群，群，単位的半群，半群を一覧にしたものを表\ref{tab:group-and-monoid}に掲げる．

\section{圏}

これまでは集合の元同士に対する二項演算を考えてきた．集合$\mathSet{M}$が単位的半群であるとき，集合$\mathSet{M}$の元$x,y\mathIn\mathSet{M}$に対して$x\mathAnyBinaryOperator y\mathIn\mathSet{M}$であった．見方を変えると，演算子$\mathAnyBinaryOperator$とは集合$\mathSet{M}$の元2個から出発して，集合$\mathSet{M}$の元1個へとジャンプさせる\keyword{写像}であると言える．これを
\begin{equation}
\mathAnyBinaryOperator\mathIn{}\mathMorph{(\mathSet{M}\mathSetTimes\mathSet{M})}{\mathSet{M}}
\end{equation}
と書く．ここに$\mathSet{X}\mathSetTimes\mathSet{Y}$は集合$\mathSet{X}$と集合$\mathSet{Y}$の\keyword{直積集合}である．直積集合と元の集合はもはや別な集合であることに注意しよう．

写像は$\mathMorph{\mathSet{M}\mathSetTimes\mathSet{M}}{\mathSet{M}}$に限ったもの出はなく，集合$\mathSet{M}$から集合$\mathSet{M}$への写像$\mathAnyUnaryOperator$ただし
\begin{equation}
\mathAnyUnaryOperator\mathIn\mathMorph{\mathSet{M}}{\mathSet{M}}
\end{equation}
があっても良い．実はこれまでにも登場した逆元を作る演算子はまさに$\mathMorph{\mathSet{M}}{\mathSet{M}}$という写像である．

またベクトルには，実数倍や回転といった写像がある．これらは実数のパラメタを一つとるので，ベクトル全体の集合を$\mathSet{V}$，実数全体の集合を$\mathSpecialSet{R}$として，実数のパラメタを$r$としたときに
\begin{equation}
\mathAnyUnaryOperator_r\mathIn{}\mathMorph{(\mathSpecialSet{R}\mathSetTimes\mathSet{V})}{\mathSet{V}}
\end{equation}
と書ける．例えば回転の場合は$\mathAnyUnaryOperator_r=U_r$である．

このようにとある集合（例えば$\mathSet{M}\mathSetTimes\mathSet{M}$や$\mathSpecialSet{R}\mathSetTimes\mathSet{V}$）から異なる別な集合（例えば$\mathSet{M}$や$\mathSet{V}$）へという写像を一般化するとどうなるだろうか．いま，集合$\mathSet{X}$から集合$\mathSet{Y}$への写像$f$があり，集合$\mathSet{Y}$から集合$\mathSet{Z}$への写像$g$があるとする．すなわち
\begin{align}
f&\mathIn\mathMorph{\mathSet{X}}{\mathSet{Y}}\\
g&\mathIn\mathMorph{\mathSet{Y}}{\mathSet{Z}}
\end{align}
があるとする．また写像同士を二項演算子$\mathCompose$で\keyword{合成}できるものとする．例えば$f$と$g$の合成写像は$\mathSet{X}$を出発点に$\mathSet{Y}$を経由して$\mathSet{Z}$へと行くので
\begin{equation}
f\mathCompose g\mathIn\mathMorph{\mathSet{X}}{\mathSet{Z}}
\end{equation}
と書ける．ここで合成演算子は結合則を満たすものとしておこう．

さらに
\begin{equation}
I_\mathSet{X}\mathIn\mathMorph{\mathSet{X}}{\mathSet{X}},\;I_\mathSet{Y}\mathIn\mathMorph{\mathSet{Y}}{\mathSet{Y}},\;I_\mathSet{Z}\mathIn\mathMorph{\mathSet{Z}}{\mathSet{Z}}
\end{equation}
という写像もあるとしよう．ここで
\begin{equation}
I_\mathSet{Y}\mathCompose f=f\mathCompose I_\mathSet{X}
\end{equation}
とすると，写像$I_\mathSet{X}$と写像$I_\mathSet{Y}$はそれぞれ写像の合成演算子$\mathCompose$に対して単位元のように振る舞う．写像$g$については
\begin{equation}
I_\mathSet{Z}\mathCompose g=g\mathCompose I_\mathSet{Y}
\end{equation}
であるとする．このような写像$I_\mathSet{X},I_\mathSet{Y},I_\mathSet{Z}$を\keyword{恒等写像}と呼ぶ．

集合$\mathSet{X}$，集合$\mathSet{Y}$，集合$\mathSet{Z}$の集合$\mathSet{C}$と，写像$f$と写像$g$の集合$\mathSet{P}$と，写像合成演算子$\mathCompose$と，恒等写像の集合$\mathSet{I}$の組み合わせ$\mathCategory{\mathSet{C}}{\mathSet{P}}{\mathCompose}{\mathSet{I}}$を\keyword{圏}と呼ぶ．写像合成演算子$(\mathCompose)$と恒等写像の集合$(\mathSet{I})$は自明であるためしばしば省略され，組み合わせ$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$を圏とする書き方もよくされる．

圏を考えるとき，変換や写像は全て\keyword{射}と呼ぶ決まりである．

いまある単位的半群$\mathMonoid{\mathSet{M}}{\mathAnyBinaryOperator}{O}$があるとする．集合$\mathSet{C}$を$\mathSet{M}$及び$\mathSet{M}\mathSetTimes\mathSet{M}$を元とする集合すなわち
\begin{equation}
\mathSet{C}=\{\mathSet{M},\mathSet{M}\mathSetTimes\mathSet{M}\}
\end{equation}
とし，集合$\mathSet{P}$を$\mathAnyBinaryOperator$のみを元とする集合すなわち
\begin{equation}
\mathSet{P}=\{\mathAnyBinaryOperator\}
\end{equation}
とすると，組み合わせ$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$は圏になっている．

\section{余計な話：束*}

A...

\chapter{型}


\begin{leader}
プログラマのいう型とは，数学者のいう集合のことである．
\end{leader}


\section{型*}

型とは変数が取りうる値に与えた制約のことである．数学者がよく扱う型は論理型$(\mathSpecialSet{B})$，整数型$(\mathSpecialSet{Z})$，実数型$(\mathSpecialSet{R})$といったところであろう．ただし数学者たちは型ではなく集合と呼ぶ．括弧内に示した記号は数学者たちが慣用的に用いているものである．

我々は計算機での実装を考慮して，数学者たちとは若干異なる型と表記方法を扱うことにする．まず論理型$(\mathSet{B})$はそのまま論理型として$\hsklBool$で表す．

計算機にとって都合の良い整数の範囲を考慮した整数型を$\hsklInt$で表す．計算機にとって都合の良い整数の範囲とは，例えば64ビット計算機の場合$-2^{63}$から$2^{63}-1$までの範囲のことである．

計算機は残念ながら無限精度の実数を扱えない．そこで標準精度の浮動小数点数を表す型を$\hsklFloat$で表す．

もう一つ，計算機ならではの型を導入しておこう．それは$\hsklInt$とよく似ているが，特別に文字を扱うために考えられた型$\hsklChar$である．文字といってもその中身は整数である．整数ではあるが，わざわざ別な型とするのには理由がある．歴史的には文字は小さな整数として表現されることが多かったため，計算機のメモリが高価であった時代背景もあり，メモリの節約のために文字を表す型が存在した．現在では，文字が数値にエンコードされる方式がより複雑になってきたために，文字を通常の数値と区別するために特別な型が用意さてれいる．

\section{関数の型*}

関数にも型がある．例えば整数引数を一つ取り，整数を返す関数$f$は
\begin{equation*}
f\mathIn\mathMorph{\hsklInt}{\hsklInt}
\end{equation*}
という型を持つ．これは関数$f$が集合$\hsklInt$から集合$\hsklInt$への写像であると読む．

整数引数を二つ取り，整数を返す関数$f'$は
\begin{equation*}
f'\mathIn\mathMorphII{\hsklInt}{\hsklInt}{\hsklInt}
\end{equation*}
という型を持つ．写像の矢印記号は右結合するので，これは
\begin{equation*}
f'\mathIn\mathMorphIIWithParenthesis{\hsklInt}{\hsklInt}{\hsklInt}
\end{equation*}
と同じ意味である．自然言語で考えると，$\hsklInt$型の引数を一つ取り，$\hsklInt$型の引数を一つ取って$\hsklInt$型の値を返す関数を返す，と読める．

\begin{table}
\caption{単位的半群}
\label{tab:monoids}
\begin{center}
\begin{tabular}{||c||c|c||}
\hline
型クラス
    &\multicolumn{2}{|c||}{$\hsklMonoid$}\\
\hline\hline
型$\backslash$演算子と単位元
    &演算子
    &単位元\\
\hline
$\hsklChar$
    &---
    &---\\
\hline
$\hsklBool$
    &$\vee$
    &$F$\\
\hline
$\hsklBool$
    &$\wedge$
    &$T$\\
\hline
$\hsklInt$
    &$+$
    &$0$\\
\hline
$\hsklInt$
    &$*$
    &$1$\\
\hline
$\hsklFloat$
    &$+$
    &$0$\\
\hline
$\hsklFloat$
    &$*$
    &$1$\\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{table*}
\caption{型と型クラス}
\label{tab:type-and-typeclass}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c|c|c|c|c|c|c||}
\hline
\multirow{4}{*}{型クラス}
    &\multicolumn{12}{|c||}{$\hsklIntegral$}\\
\cline{2-13}
\multirow{3}{*}{}
    &\multicolumn{10}{|c|}{$\hsklReal$}
    &\multicolumn{2}{|c||}{$\hsklEnum$}\\
\cline{2-11}
\multirow{2}{*}{}
    &\multicolumn{5}{|c|}{$\hsklOrd$}
    &\multicolumn{5}{|c|}{$\hsklNum$}
    &\multicolumn{2}{|c||}{ }\\
\cline{2-2}\cline{7-7}
{ }
    &$\hsklEq$
    &\multicolumn{4}{|c|}{ }
    &$\hsklEq$
    &\multicolumn{4}{|c|}{ }
    &\multicolumn{2}{|c||}{ }\\
\hline\hline
型$\backslash$演算子
    &$\equiv$
    &$<$
    &$\le$
    &$\ge$
    &$>$
    &$\equiv$
    &$+$
    &$-$
    &$*$
    &$/$
    &$\hsklPred$
    &$\hsklSucc$\\
\hline
$\hsklChar$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---
    &---
    &---
    &$\checkmark$
    &$\checkmark$\\
\hline
$\hsklBool$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---
    &---
    &---
    &$\checkmark$
    &$\checkmark$\\
\hline
$\hsklInt$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$\\
\hline
$\hsklFloat$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---\\
\hline
\end{tabular}
\end{center}
\end{table*}

\section{型クラス*}

組み合わせ$\mathMonoid{\hsklInt}{+}{0}$は単位的半群である．同様に$\mathMonoid{\hsklInt}{*}{1}$, $\mathMonoid{\hsklFloat}{+}{0}$, $\mathMonoid{\hsklFloat}{*}{1}$, $\mathMonoid{\hsklBool}{\vee}{F}$, $\mathMonoid{\hsklBool}{\wedge}{T}$ も単位的半群である．そこで，任意の型$\hsklType{a}$について，組み合わせ$\mathMonoid{\hsklType{a}}{\mathAnyBinaryOperator}{O}$が単位的半群である場合には
\begin{equation*}
\mathMonoid{\hsklType{a}}{\mathAnyBinaryOperator}{O}\mathIn\hsklMonoid
\end{equation*}
と書くことにする．二項演算子，単位元が自明な場合は簡略化して
\begin{equation*}
\hsklType{a}\mathIn\hsklMonoid
\end{equation*}
と書くことにする．

このような型をより抽象化した型のようなものを\keyword{型クラス}と呼ぶ．単位的半群は型クラスの例である．表\ref{tab:monoids}に型と対応する単位的半群の単位元，演算子の一覧を示す．

もっと身近な型クラスもある．例えば，型$\hsklType{a}$の変数どうしの間で等値性が定義されている場合，その型は型クラス$\hsklEq$に属することになる．型クラス$\hsklEq$に属する型は等値演算子$\equiv$を提供する．

型$\hsklType{a}$の変数どうしの間で大小関係が定義されている場合，かつその型が型クラス$\hsklEq$に属する場合，その型は型クラス$\hsklOrd$にも属する．型クラス$\hsklOrd$に属する型は比較演算子$<,\le,\ge,>$を提供する．

型$\hsklType{a}$の変数どうしの間で四則演算関係が定義されている場合，かつその型が型クラス$\hsklEq$に属する場合，その型は型クラス$\hsklNum$にも属する．型クラス$\hsklNum$に属する型は二項演算子$+,-,*,/$を提供する．ここに$-$は二項演算子のマイナスである．

型$\hsklType{a}$が型クラス$\hsklOrd$及び型クラス$\hsklNum$に属しているとき，かつそのときに限り，型$\hsklType{a}$は型クラス$\hsklReal$にも属する．

型$\hsklType{a}$の変数について，一つ小さい値を返す関数$\hsklPred$と一つ大きい値を返す関数$\hsklSucc$が定義されているとき，かつそのときに限り，型$\hsklType{a}$は型クラス$\hsklEnum$に属する．

型$\hsklType{a}$が型クラス$\hsklReal$及び型クラス$\hsklEnum$に属しているとき，かつそのときに限り，型$\hsklType{a}$は型クラス$\hsklIntegral$にも属する．

これらの関係を表にまとめたものが表\ref{tab:type-and-typeclass}である．

\section{余計な話：カリー化}

どのような関数であれ，引数は1個しかとらない．引数が2個あるように見える関数として，例えば$fxy$があったとしよう．関数適用が左結合であるから，これは$(fx)y$である．ここに$(fx)$は引数$y$をとる関数であると見ることができる．つまり，関数$f$とは引数$x$をとり「引数$y$をとって値を返す関数$(fx)$を返す」関数であると言える．

二項演算$x+y$は$(+)xy$とも書けたことを思い出そう．これも左結合を思い出すと
\begin{equation}
(+)xy=((+)x)y
\end{equation}
であるから，$y$という引数を$((+)x)$という関数に食わせていると解釈できる．

ラムダ式の場合は話はもっと単純で，機械的に
\begin{equation}
\mathLambdaExpression{xy}{x+y}=\mathLambdaExpression{x}{(\mathLambdaExpression{y}{x+y})}
\end{equation}
のように展開するだけである．矢印$\mathLambdaArrow$は右結合であるから，このラムダ式は括弧を省略して
\begin{equation}
\mathLambdaExpression{xy}{x+y}=\mathLambdaExpression{x}{\mathLambdaExpression{y}{x+y}}
\end{equation}
とも書かれる．

複数引数をとる関数を1引数関数に分解することを\keyword{カリー化}と呼ぶ．これはこの分野の先駆者であるハスケル・カリーの名前に由来する．



\chapter{リスト}
\begin{leader}
型から作る型をコンテナと呼ぶ．代表的なコンテナはある型のホモジニアスな配列であるリストである．この章ではリストと，リストに対する重要な演算である畳み込み，マップを取り扱う．
\end{leader}


\section{Pythonのリスト}

同じ型の値を一列に並べたもの，つまりホモジニアスな配列のことを\keyword{リスト}と呼ぶ．Pythonではリスト\pthnId{t}を
\begin{pythoncode}
\begin{python}
\pthnId{t} \pthnOp{=} [$0$, $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$, $9$]
\end{python}
\end{pythoncode}
のように定義できる．

我々もPythonのように，例えば$0$から始まり$9$まで続く整数のリストを$[0,1,2,3,4,5,6,7,8,9]$と書くことにしよう．ただし，これでは冗長なので，等差数列に限って，簡略化した書き方を許す．例えば$0$から$9$までのリストは$[0,1\dots9]$と書いても良い．\footnote{Haskellでは\code{l = [0,1..9]}と書く．ピリオドの数に注意しよう．}

リストの中身の一つ一つの値のことを\keyword{要素}と呼ぶ．要素のことは元と呼んでも良いが，本書では要素と呼ぶことにする．要素も元も英語のelementの和訳である．

複数の型の要素が混在してもよい配列のことをヘテロジニアスな配列と呼び，ホモジニアスな配列とは区別する．

今後，リストを指す変数にはバーをつけて$\hsklList{t}$と書くことにして
\begin{equation}
\hsklList{t}=[0,1\dots9]
\end{equation}
のように書くことにしよう．\footnote{Haskellコンパイラは人間よりも記憶力が優れているため，変数名にバーをつける必要はない．}

Pythonではリスト内包表記が使える．例えば$0$から$9$までの平方数のリストは次のように作った．
\begin{pythoncode}
\begin{python}
\pthnId{t} \pthnOp{=} [\pthnId{x} \pthnOp{**} $2$ \pthnKeyword{for} \pthnId{x} \pthnKeyword{in} \pthnId{range}($0$, $10$)]
\end{python}
\end{pythoncode}
ここに\pthnId{range}(\pthnId{a}, \pthnId{b})は\pthnId{a}から増加する方向に連続する\pthnId{b}個の整数からなるリストを返すPythonの関数である．

我々は内包表記のかわりにガードを使って
\begin{equation}
\hsklList{t}=\left[x^2\mathGuard{x\mathFrom{[0,1\dots9]}}\right]
\end{equation}
のように書こう．ここに右辺のリストから一つずつ要素を取り出して左辺に代入する演算子$\mathFrom$を用いた．

ガードの中の式は複数あっても良い．例えば
\begin{equation}
\hsklList{t}=\left[x+y\mathGuard{x\mathFrom[0,1\dots9],\,y\mathFrom[0,1\dots5],\,x+y>3}\right]
\end{equation}
は$0\le x\le9$かつ$0\le y\le5$の範囲で$x+y>3$となる$x$及び$y$から$x+y$を並べたリストである．これはPythonでいう
\begin{pythoncode}
\begin{python}
\pthnId{t} \pthnOp{=} [\pthnId{x} \pthnOp{+} \pthnId{y} \pthnNextLine\\
\>\pthnKeyword{for} \pthnId{x} \pthnKeyword{in} \pthnId{range}($0$, $10$) \pthnNextLine\\
\>\pthnKeyword{for} \pthnId{y} \pthnKeyword{in} \pthnId{range}($0$, $6$) \pthnNextLine\\
\>\pthnKeyword{if} \pthnId{x} \pthnOp{+} \pthnId{y} \pthnOp{>} $3$]
\end{python}
\end{pythoncode}
のことである．\footnote{Haskellでは\code{t = [x + y | x <- [0, 1..9], y <- [0, 1..5], x + y > 3]}と書く．}

リストは\keyword{結合}できる．例えばリスト$\hsklList{t}$とリスト$\hsklList{u}$を結合したリストは
\begin{equation*}
\hsklList{t}\hsklAppend\hsklList{u}
\end{equation*}
と表現する．\footnote{Haskellでは\code{t ++ u}と書く．}

リストは無限個の要素を持っても良い．例えば自然数全体を表すリスト$\hsklList{n}$は
\begin{equation}
\hsklList{n}=[1,2\dots]
\end{equation}
のように定義して良い．\footnote{Haskellでは\code{n = [1,2..]}と書く．}

\keyword{空リスト}は$\hsklEmptyList$で表す．\footnote{Haskellでは空リストを\code{[]}で表す．}

任意の型を$\hsklType{a}$とするとき，$\hsklType{a}$型のリスト型を$\hsklListType{\hsklType{a}}$と書く．型$\hsklType{a}$から型$\hsklListType{\hsklType{a}}$を生成する演算子を\keyword{リスト型コンストラクタ}と呼んで$\hsklListConstructor$と書き
\begin{equation}
\hsklListType{\hsklType{a}}=\hsklTypeConstruct{\hsklListConstructor}{\hsklType{a}}
\end{equation}
とする．この等式の両辺は変数ではなく型名であることに注意しよう．型コンストラクタの概念はPythonには無い（必要無い）が，静的型付け言語であるJavaの「総称型」や\cxx の「クラステンプレート」が相当する．\footnote{Haskellでは表記上コンテナ型$\hsklListType{a}$と型コンストラクタ式$\hsklTypeConstruct{\hsklListConstructor}{\hsklType{a}}$を区別せず，両者とも\code{[a]}と書く．}

$\hsklType{a}$型の変数$x$を入れた$\hsklListType{\hsklType{a}}$型の変数（リスト変数）を作る演算子を\keyword{リスト値コンストラクタ}と呼ぶ．$\hsklType{a}$型の変数$x$からリスト値コンストラクタを使ってリスト$\hsklList{t}$を作ることは
\begin{equation}
\hsklList{t}=[x]
\end{equation}
と書く．\footnote{Haskellでは\code{t = [x]}と書く．}

リスト型を表す$\hsklListType{\hsklType{a}}$と，1要素のリストである$[x]$の違いにはいつも気をつけておこう．本書では中身がボールドローマン体ならばリスト型，中身がオイラー体ならリスト値である．またリストを保持する変数にも，本書では$\hsklList{t}$のようにバーをつけておくことにする．

ある型を包み込んだ別の型を一般に\keyword{コンテナ型}または単に\keyword{コンテナ}と呼ぶ．

\section{畳み込みとマップ*}

我々はよくリストの総和を表現するためにシグマ記号($\sum$)を使う．リスト$[x_0,x_1\dots x_n]$の総和を
\begin{equation}
\sum[x_0,x_1\dots x_n]=x_0+x_1+\dotsb+x_n
\end{equation}
とするようなシグマ記号である．この表現を一般化してみよう．
リスト$[x_0,x_1\dots x_n]$が与えられたとき
\begin{equation}
\mathFold^{\mathAnyBinaryOperator}_{a}[x_0,x_1\dots x_n]=a\mathAnyBinaryOperator x_0\mathAnyBinaryOperator x_1\mathAnyBinaryOperator\dotsb\mathAnyBinaryOperator x_n
\end{equation}
であると定義する．

この新しい記号$\mathFold$は\keyword{畳み込み演算子}と呼ばれる．変数$a$はアキュムレータと呼ぶ．アキュムレータは右側の引数が空であった場合のデフォルト値と考えても良い．\footnote{Haskellでは$\mathFold^{*}_{a}\hsklList{t}$を\code{foldl * a t}と書く．}
% !!!!!!!!!! CHECK !!!!!!!!!!

Python 2.7 には畳み込み演算子に相当する\pthnId{reduce}関数があり，リスト\pthnId{t}の総和\pthnId{s}を
\begin{pythoncode}
\begin{python}
\texttt{\# Python 2.7}\\
\pthnId{t} \pthnOp{=} [$0$, $1$, $2$, $3$, $4$, $5$]\\
\pthnId{s} \pthnOp{=} \pthnId{reduce}(\pthnKeyword{lambda} \pthnId{x}, \pthnId{y}: \pthnId{x} \pthnOp{+} \pthnId{y}, \pthnId{t}, $0$)
\end{python}
\end{pythoncode}
のように求めることができる．この\pthnId{reduce}関数はPythonバージョン3では非推奨になっているが，Rubyには受け継がれていて，Rubyでは
\begin{rubycode}
\begin{Verbatim}
t = [0, 1, 2, 3, 4, 5]
s = t.inject(0) { |x, y| x + y }
\end{Verbatim}
\end{rubycode}
と書ける．

リストの総和をとる演算子$\sum$は
\begin{equation}
\sum=\mathFold^+_0
\end{equation}
とすれば得られる．同じようにリストの要素のすべての積をとる演算子$\prod$は
\begin{equation}
\prod=\mathFold^*_1
\end{equation}
とすれば得られる．

畳み込み演算子は第1（上）引数に$\hsklType{a}$型と$\hsklType{b}$型の引数を取り$\hsklType{a}$型の戻り値を返す二項演算子，第2（下）引数に$\hsklType{a}$型，第3（右）引数に$\hsklType{b}$型のリストすなわち$\hsklListType{\hsklType{b}}$型を取り，$\hsklType{a}$型の値を返す．従って畳み込み演算子の型は
\begin{equation}
\mathFold\mathIn\mathMorphIII{(\mathMorphII{\hsklType{a}}{\hsklType{b}}{\hsklType{a}})}{\hsklType{a}}{\hsklListType{\hsklType{b}}}{\hsklType{a}}
\end{equation}
である．

畳み込み演算子には次のようなもう一つのバリエーションがある．
\begin{equation}
\mathFoldRight^{\mathAnyBinaryOperator}_{a}[x_0,x_1\dotsb x_n]=\left(x_0\mathAnyBinaryOperator\left(x_1\mathAnyBinaryOperator\dotsb\mathAnyBinaryOperator\left(x_n\mathAnyBinaryOperator a\right)\right)\right)
\end{equation}
これは右畳み込みと呼ばれる演算子である．\footnote{Haskellでは$\mathFoldRight^{*}_{a}l$を\code{foldr l a *}と書く．}
% !!!!!!!!!! CHECK !!!!!!!!!!

畳み込み演算子の面白い応用例を示そう．リストの結合演算子$(\hsklAppend)$を使うと
\begin{equation}
\mathFold_\hsklEmptyList^\hsklAppend[[0,1,2],[3,4,5],\dots]=[0,1,2,3,4,5,\dots]
\end{equation}
であるから，演算子
\begin{equation}
\mathFold_\hsklEmptyList^\hsklAppend
\end{equation}
はリストを平坦化する\keyword{平坦化演算子}である．平坦化演算子はconcat演算子とも呼ばれることもあるが，基本的な演算子であるため特別な記号をつけておこう．我々は
\begin{equation}
\hsklConcat=\mathFold_\hsklEmptyList^\hsklAppend
\end{equation}
と定義することにする．\footnote{Haskellでは演算子$\hsklConcat$の代わりに\code{concat}関数を使う．}
% !!!!!!!!!! CHECK !!!!!!!!!!

リストの各要素に決まった関数を適用したい場合がある．Pythonではリスト\pthnId{t}に関数\pthnId{f}を適用するときには
\begin{pythoncode}
\begin{python}
\pthnId{map}(\pthnId{f}, \pthnId{t})
\end{python}
\end{pythoncode}
のように\pthnId{map}関数を用いる．

このように引数として関数$f$とリスト$[x_0,x_1\dots x_n]$を取り，戻り値として$[fx_0,fx_1\dots fx_n]$を返す演算子$\hsklMap$を考えよう．このとき
\begin{equation}
f\hsklMap[x_0,x_1\dots x_n]=[fx_0,fx_1\dots fx_n]
\end{equation}
であると定義する．この演算子$\hsklMap$を\keyword{マップ演算子}と呼ぶ．\footnote{Haskellでは$f\hsklMap l$を\code{map f l}または\code{f `map` l}と書く．}

マップ演算子の型は
\begin{equation*}
\hsklMap\hsklOf{}\mathMorphII{(\mathMorph{\hsklType{a}}{\hsklType{b}})}{\hsklListType{\hsklType{a}}}{\hsklListType{\hsklType{b}}}
\end{equation*}
である．矢印$\mathMapsTo$は右結合なので，これは
\begin{equation*}
\hsklMap\hsklOf{}\mathMorph{(\mathMorph{\hsklType{a}}{\hsklType{b}})}{(\mathMorph{\hsklListType{\hsklType{a}}}{\hsklListType{\hsklType{b}}})}
\end{equation*}
の意味でもある．ここで$f$と$f\hsklMap$の型を並べてみると
\begin{align*}
f&\mathIn\mathMorph{\hsklType{a}}{\hsklType{b}}\\
f\hsklMap&\mathIn\mathMorph{\hsklListType{\hsklType{a}}}{\hsklListType{\hsklType{b}}}
\end{align*}
となり，マップ演算子が何をしているのか一目瞭然になる．

\section{リストの実装}

ここでリストの実装について述べておかねばならない．紙上ではリストは自由に考えられるが，計算機上ではそれほど自由ではないからである．我々はリストをLISPにおけるリストと同じ構造を持つものとする．LISPにおけるリストとはリファレンス$\mathFirst$とリファレンス$\mathRest$からなるペアの集合である．リファレンス$\mathFirst$がリストの要素を参照し，リファレンス$\mathRest$が次のペアを参照する．リストの最後のペアの$\mathRest$は空リストを参照する特別な値を持つ．

リストのための特別な表現
\begin{equation*}
\mathFirst:\mathRest
\end{equation*}
を用い，リファレンス$\mathFirst$はリストが保持する型，リファレンス$\mathRest$はリスト型であるとする．演算子$:$を\keyword{結合演算子}と呼ぶ．\footnote{Haskellでも要素\code{x}をリスト\code{t}の先頭に追加することを\code{x:t}と書く．}

要素$\mathRest$はリストまたは空リストであるから，一般にリストは次のように展開できることになる．
\begin{align*}
[x_0,x_1,x_2\dots x_n]&=x_0:[x_1,x_2\dots x_n]\\
&=x_0:x_1:[x_2\dots x_n]\\
&=x_0:x_1:x_2:\dots:x_n:\hsklEmptyList
\end{align*}
結合演算子$:$は右結合する．すなわち$$x_0:x_1:x_2=x_0:(x_1:x_2)$$である．

マップ演算子の実装は，リストの実装に踏み込めば簡単である．空でないリストは必ず$x:\hsklList{t}$へと分解できるから
\begin{equation}
\left\{
\begin{split}
f\hsklMap(x:\hsklList{t})&=(fx):(f\hsklMap\hsklList{t})\\
f\hsklMap\hsklEmptyList&=\hsklEmptyList
\end{split}
\right.
\end{equation}
とマップ演算子($\hsklMap$)を定義できる．つまりマップ演算子($\hsklMap$)は結合演算子(:)から作ることができる．換言すれば，マップ演算子は糖衣構文である．

任意のリスト$\hsklList{t}$に対し，次の関数が用意されている．
\begin{align*}
\hsklHead\hsklList{t}&\dots\text{$\hsklList{t}$の先頭要素}\\
\hsklTail\hsklList{t}&\dots\text{$\hsklList{t}$の2番目以降の要素からなるリスト}
\end{align*}
これらはLISPのcar関数，cdr関数と同じものである．

\section{余計な話：リストを引数にとる関数}

リストを分解する関数$\hsklHead$と$\hsklTail$さえあればどのようなリスト処理も可能であるが，リストを引数にとる関数を考えると最初から分解されたリストを渡された方が何かと便利である．そこで結合演算子を関数引数のパタンにも使えることにしよう．これで，例えばリストの和をとる関数$f$は
\begin{equation}
\left\{
\begin{split}
f\hsklEmptyList&=0\\
% fx:\hsklEmptyList&=x\\
f(x:\hsklList{t})&=x+f\hsklList{t}
\end{split}
\right.
\end{equation}
のようにも定義できる．


\chapter{Maybe}

\begin{leader}
この章では計算結果が正しいかもしれないし，正しくないかもしれないという曖昧な状況を表す型を導入する．手始めにPythonでクラスPossiblyを実装し，それがカリー風の数式で綺麗に書けることを示す．またリストとの共通点についても見ていくことにする．
\end{leader}

\section{Possibly}

計算の途中で，計算にまつわる状態を残りの計算に引き継ぎたくなる場合がある．例えば，整数$x$と整数$y$があり$z=y/x$なる値を続く計算で利用したいとする．だが$x\equiv0$のときには$z$は正しく計算されない．こんなときプログラマが取れる手段は
\begin{itemize}
\item $z=y/x$を計算した時点で$0$除算例外を発生させ，プログラムの制御を他の場所へ移す（大域ジャンプを行う）
\item グローバル変数に$0$除算エラーが起こったことを記録しておき，$z$にはとりあえずの数値，例えば$0$を代入しておいて，計算を続行させる
\item $z$にエラー状態を示す印をつけておいて，計算を続行させる
\end{itemize}
といったところだろう．

大域ジャンプも，グローバル変数の書き換えも破壊的代入を伴うものであり，受け入れがたい．そこで我々は第3のエラー状態を示す印をつける方法を採用することにする．普通変数が整数だろうが実数だろうが，計算機表現には余分なビットが残っていないので，次のようなクラス\pthnClassname{Possibly}を導入することにしよう．メンバ変数\pthnId{value}が値を，メンバ変数\pthnId{valid}がエラーの有無を表す．
\begin{pythoncode}
\begin{python}
\pthnKeyword{class} \pthnClassname{Possibly}:\\
\>\pthnKeyword{def} \pthnId{\_\_init\_\_}(\pthnKeyword{self}, \pthnId{a\_valid}, \pthnId{a\_value} \pthnOp{=} $0$):\\
\>\>\pthnKeyword{self}.\pthnId{valid} \pthnOp{=} \pthnId{a\_valid}\\
\>\>\pthnKeyword{self}.\pthnId{value} \pthnOp{=} \pthnId{a\_value}
\end{python}
\end{pythoncode}

例えば整数値$123$を持つPossibly値\pthnId{m}は
\begin{pythoncode}
\begin{python}
\pthnId{m} \pthnOp{=} \pthnClassname{Possibly}(\pthnId{True}, 123)
\end{python}
\end{pythoncode}
として生成できるし，\pthnClassname{Possibly}値\pthnId{m}が計算エラーを表す場合は
\begin{pythoncode}
\begin{python}
\pthnId{m} \pthnOp{=} \pthnClassname{Possibly}(\pthnId{False})
\end{python}
\end{pythoncode}
と初期化できる．

ここで，引数を$100$倍にして返す関数\pthnId{f}があるとしよう．関数\pthnId{f}の定義は次の通りである．
\begin{pythoncode}
\begin{python}
\pthnId{f} \pthnOp{=} \pthnKeyword{lambda} \pthnId{x}: $100$ \pthnOp{*} \pthnId{x}
\end{python}
\end{pythoncode}

関数\pthnId{f}に直接\pthnClassname{Possibly}値\pthnId{m}を食わせるとランタイムエラーを引き起こす．
\begin{pythoncode}
\begin{python}
\pthnId{n} \pthnOp{=} \pthnId{f}(\pthnId{m}) \texttt{\#} エラー!! 
\end{python}
\end{pythoncode}
これは関数\pthnId{f}が引数として数値を期待していたにもかかわらず，\pthnClassname{Possibly}値が渡されたからである．もし関数\pthnId{f}のほうをいじりたくないとすれば，次のような関数\pthnId{map\_over}を使って
\begin{pythoncode}
\begin{python}
\pthnId{n} \pthnOp{=} \pthnId{map\_over}(\pthnId{f}, \pthnId{m}) 
\end{python}
\end{pythoncode}
というふうに間接的に関数適用を行う必要がある．

関数\pthnId{map\_over}(\pthnId{f}, \pthnId{m})はもし\pthnId{m}がエラーを表す値でなければ中身の値を関数\pthnId{f}に適用し，その結果を\pthnClassname{Possibly}クラスに包んで返す．もし\pthnId{m}がエラー値を表す値であれば，結果もエラー値である．関数\pthnId{map\_over}の実装は次のようになる．
\begin{pythoncode}
\begin{python}
\pthnKeyword{def} \pthnId{map\_over}(\pthnId{f}, \pthnId{m}):\\
\>\pthnKeyword{if} \pthnId{m}.\pthnId{valid} \pthnOp{==} \pthnId{True}:\\
\>\>\pthnKeyword{return} \pthnClassname{Possibly}(\pthnId{True}, \pthnId{f}(\pthnId{m}.\pthnId{value}))\\
\>\pthnKeyword{else}:\\
\>\>\pthnKeyword{return} \pthnClassname{Possibly}(\pthnId{False})
\end{python}
\end{pythoncode}

さて，次節では以上のようなことを抽象数学的に綺麗に描いてみよう．

\section{Maybeコンテナ}

もう一度振り出しに戻る．

整数$x$と整数$y$があり$z=y/x$という式があるとする．この式は$x\equiv0$のときには$0$除算エラーである．しかし「例外」は内部状態の書き換えであり，我々の計算に入れたくない．そこで変数$z$が正しく計算されたかもしれないし，されていないかもしれないということを，$\hsklMaybe{m}$のように印をつけた別の変数に入れて，忘れないようにしておこう．ここで変数$\hsklMaybe{m}$が取り得る値は正しく計算された値$z$か，あるいはエラーを表す値$\hsklNothing$である．このように計算結果に「意味付け」をすることを\keyword{文脈}に入れると言う．

この変数$\hsklMaybe{m}$はもはや整数型とは言えない．そこでこの$\hsklMaybe{m}$の型を$\hsklMaybeType{\hsklInt}$と表して「きっと整数」型と呼ぶことにしよう．
型$\hsklType{a}$から型$\hsklMaybeType{\hsklType{a}}$を生成する型コンストラクタを$\hsklMaybeConstructor$と呼び$$\hsklMaybeType{\hsklType{a}}=\hsklTypeConstruct{\hsklMaybeConstructor}{\hsklType{a}}$$とする．\footnote{Haskellでは表記上コンテナ型$\hsklMaybeType{a}$と型コンストラクタ式$\hsklTypeConstruct{\hsklMaybeConstructor}{\hsklType{a}}$を区別せず，両者とも\code{Maybe a}と書く．}

$\hsklType{a}$型の変数を$\hsklMaybeType{\hsklType{a}}$型の変数に代入するには，次の値コンストラクタを用いて$$\hsklMaybe{m}=\hsklJust{z}$$と書く．\footnote{Haskellでは\code{m = Just z}と書く．}

変数$z$が一度$0$除算の危険性に汚染された場合，その後ずっと$\hsklMaybe{m}$というコンテナに入れ続けなければいけない．
このきっと整数$\hsklMaybe{m}$に対して整数を引数にとる関数$f$を適用させるには，何らかの関数マップ演算子が必要である．
そこできっと整数の中身に直接関数を適用する演算子を$\hsklMaybeMap$としよう．具体的には$$f\hsklMaybeMap\hsklMaybe{m}=\hsklMaybeW{fz}$$のように関数$f$を変数$\hsklMaybe{m}$に適用させる．その結果はまた$\hsklMaybeType{\hsklInt}$型である．

いま引数の$100$倍の値を返す関数$fz=100*z$があるとしよう．これを「きっと整数」な$\hsklMaybe{m}$に適用するには，$\hsklMaybe{m}$がもし$\hsklMaybe{m}=\hsklJust{z}$ならば中身$z$を取り出して$fz$を計算し，もし$\hsklMaybe{m}=\hsklNothing$であれば$\hsklNothing$を返すような適用演算子である．引数$\hsklMaybe{m}$がいつ$\hsklJust{z}$でいつ$\hsklNothing$になるのかは，いまは問わないことにする．

そこで我々が欲しいのは
\begin{equation*}
f\hsklMaybeMap\hsklMaybe{m}=\begin{cases}
\hsklJust{fz}&\mathIf\hsklMaybe{m}\equiv\hsklJust{z}\\
\hsklNothing&\mathOtherwise
\end{cases}
\end{equation*}
であるようなMaybeバージョンのマップ演算子$\hsklMaybeMap$である．ゆえに我々は演算子$\hsklMaybeMap$を
\begin{equation*}
\left\{
\begin{split}
f\hsklMaybeMap\hsklJust{z}&=\hsklJust{fz}\\
f\hsklMaybeMap\hsklNothing&=\hsklNothing
\end{split}
\right.
\end{equation*}
のように定義する．

今後，普通の（引数にMaybeが来ることを想定していない）関数$f$をMaybe型である変数$\hsklMaybe{m}$に適用させるときには，必ず$$\hsklMaybe{n}=f\hsklMaybeMap\hsklMaybe{m}$$のようにMaybeバージョンのマップ演算子$\hsklMaybeMap$を用いることにする．\footnote{HaskellではMaybeバージョンのマップ演算子に特別な記号，関数名が与えられていない．その代わり第\ref{ch:functor}章で述べる一般化マップ演算子$\hsklFmap$に相当する\code{fmap}関数を用い\code{n = fmap f m}または\code{n = f `fmap` m}のようにする．Haskellは型推論を行なうため変数\code{m}がMaybeであればMaybeバージョンのマップ演算子（関数）が適用される．（もし\code{m}がリストであれば通常のマップ関数である\code{map}が適用される．）}

PythonでMaybeの概念を忠実になぞることは難しい．と言うのもPythonは動的型付け言語であるため，型コンストラクタという概念が無いからだ．一方で，Maybeの概念を静的型付け言語である\cxx やJavaで実現することは出来る．そこで\cxx の本物のコードで示しておこう．ただし参照を使わないでおいたので\cxx プログラマもJavaプログラマも参考にできるだろう．

Maybeは次の\pthnClassname{maybe}クラステンプレートで表現できる．（Javaプログラマへの注意：これは\pthnClassname{maybe}$\langle$\pthnClassname{a}$\rangle$クラスの定義と同じ意味である．）
\begin{cxxcode}
\begin{python}
\pthnKeyword{template} $\langle$\pthnKeyword{typename} \pthnClassname{a}$\rangle$ \pthnKeyword{class} \pthnClassname{maybe} \{\\
\pthnKeyword{private}:\\
\>\pthnClassname{a} \pthnId{value};\\
\>\pthnKeyword{bool} \pthnId{valid};\\
\pthnKeyword{public}:\\
\>\pthnClassname{maybe}(): \pthnId{value}($0$), \pthnId{valid}(\pthnId{false}) \{ \}\\
\>\pthnClassname{maybe}(\pthnClassname{a} \pthnId{a\_value}):\\
\>\>\pthnId{value}(\pthnId{a\_value}), \pthnId{valid}(\pthnId{true}) \{ \}\\
\>\pthnClassname{a} \pthnId{get\_value}() \pthnKeyword{const} \{ \pthnKeyword{return} \pthnId{value}; \}\\
\>\pthnKeyword{bool} \pthnId{is\_valid}() \pthnKeyword{const} \{ \pthnKeyword{return} \pthnId{valid}; \}\\
\};
\end{python}
\end{cxxcode}
デフォルトコンストラクタは例外的な状況を表す$\hsklNothing$を生成し，1引数コンストラクタは\pthnClassname{maybe}で包んだ引数値を生成する．

\cxx プログラムで良く見かけるクラス設計と違い，この\pthnClassname{maybe}クラスはコンストラクタ以外に中身を書き換える手段が提供されていない．これが破壊的代入の禁止が意味することである．

当然我々にはMaybeバージョンのマップ演算子が必要である．ここでは関数\pthnId{map\_over}として書いてみよう．（Javaプログラマへの注意：関数\pthnId{map\_over}はどのクラスにも属していないが，それで正解なのである．）
\begin{cxxcode}
\begin{python}
\pthnKeyword{template} $\langle$\pthnKeyword{typename} \pthnClassname{a}, \pthnKeyword{typename} \pthnClassname{fn}$\rangle$\\
\pthnClassname{maybe}$\langle$\pthnClassname{a}$\rangle$ \pthnId{map\_over}(\pthnClassname{fn} \pthnId{f}, \pthnClassname{maybe}$\langle$\pthnClassname{a}$\rangle$ \pthnId{m}) \{\\
\>\pthnKeyword{if} (\pthnId{m}.\pthnId{is\_valid}())\\
\>\>\pthnKeyword{return} \pthnClassname{maybe}$\langle$\pthnClassname{a}$\rangle$(\pthnId{f}(\pthnId{m}.\pthnId{get\_value}()));\\
\>\pthnKeyword{else}\\
\>\>\pthnKeyword{return} \pthnClassname{maybe}$\langle$\pthnClassname{a}$\rangle$();\\
\}
\end{python}
\end{cxxcode}
テンプレートの2番目の引数\pthnClassname{fn}は関数\pthnId{f}を受け取るために必要である．\cxx はコンパイル時までにすべての変数の型が決定していないといけないが，関数\pthnId{f}の型は関数\pthnId{map\_over}設計時には確定できないため，このようにテンプレートにしている．
% （\cxx03プログラマへの注意：関数\pthnId{f}には関数オブジェクトを渡しても良い．）
% こうすることで，Cスタイルの関数ポインタも，\cxx03スタイルの関数オブジェクトも，\cxx11スタイルのラムダ式も受け取ることができる．

整数$z$からMaybe値$\hsklMaybe{m}=\hsklJust{z}$を作り，関数$fx=100*x$をMaybe値$\hsklMaybe{m}$に食わせてMaybe値$\hsklMaybe{n}$ただし$$\hsklMaybe{n}=f\hsklMaybeMap\hsklMaybe{m}$$を得ることを，\cxx では次のように書くことになる．
\begin{cxxcode}
\begin{python}
\pthnKeyword{int} \pthnId{z} \pthnOp{=} $123$;\\
\pthnClassname{maybe}$\langle$\pthnKeyword{int}$\rangle$ \pthnId{m}(\pthnId{z});\\
\pthnKeyword{auto} \pthnId{f} \pthnOp{=} \pthnOp{[]}(\pthnKeyword{int} \pthnId{x}) $\rightarrow$ \pthnKeyword{int} \{ \pthnKeyword{return} \pthnId{x} \pthnOp{*} $100$; \};\\
\pthnClassname{maybe}$\langle$\pthnKeyword{int}$\rangle$ \pthnId{n} \pthnOp{=} \pthnId{map\_over}(\pthnId{f}, \pthnId{m});
\end{python}
\end{cxxcode}
注意してほしいのは\pthnId{f}(\pthnId{z})も\pthnId{map\_over}(\pthnId{f}, \pthnId{m})も正当なコードだが\pthnId{f}(\pthnId{m})は型エラーであることだ．また\pthnId{f}(\pthnId{m}.\pthnId{get\_value}())は正当なコードだが，わざわざ\pthnId{m}が持つ文脈を捨てることになる．（\cxx プログラマへの注意：$\pthnKeyword{int}$型の使用は現在では非推奨である．）

% ところで，関数\pthnId{f}の実装は，ラムダ式の使えない\cxx03ではファンクター (functor) という機構を使うことになる．このファンクターは第\ref{ch:functor}章の関手 (functor) とは全く別な概念である．

\section{リストとMaybe*}

関数$f$をMayby値$\hsklMaybe{m}$に適用するために$$\hsklMaybe{n}=f\hsklMaybeMap\hsklMaybe{m}$$のようなMaybeバージョンのマップ演算子($\hsklMaybeMap$)を使った．一方で，同じ関数$f$をリスト$\hsklList{t}$に適用するには$$\hsklList{u}=f\hsklMap\hsklList{t}$$

リストバージョンのマップ演算子($\hsklMap$)をもし\cxx で書くとしたら，次のようなコードになる．ここでリスト型として\cxx の標準テンプレートライブラリ(STL)の\pthnClassname{list}クラスを流用した．
\begin{cxxcode}
\begin{python}
\pthnKeyword{template} $\langle$\pthnKeyword{typename} \pthnClassname{a}, \pthnKeyword{typename} \pthnClassname{fn}$\rangle$\\
\pthnId{std}::\pthnClassname{list}$\langle$\pthnClassname{a}$\rangle$ \pthnId{map\_over}(\pthnClassname{fn} \pthnId{f}, \pthnId{std}::\pthnClassname{list}$\langle$\pthnClassname{a}$\rangle$ \pthnId{t}) \{\\
\>\pthnId{std}::\pthnClassname{list}$\langle$\pthnClassname{a}$\rangle$ \pthnId{r}(\pthnId{t}.\pthnId{size}());\\
% \>\pthnKeyword{typename} \pthnId{std}::\pthnClassname{list}$\langle$\pthnClassname{a}$\rangle$::\pthnClassname{const\_iterator}\\
% \>\>\pthnId{i} \pthnOp{=} \pthnId{l}.\pthnId{cbegin}();\\
% \>\pthnKeyword{typename} \pthnId{std}::\pthnClassname{list}$\langle$\pthnClassname{a}$\rangle$::\pthnClassname{iterator} \pthnId{j} \pthnOp{=} \pthnId{r}.\pthnId{begin}();\\
\>\pthnKeyword{auto} \pthnId{i} \pthnOp{=} \pthnId{t}.\pthnId{cbegin}();\\
\>\pthnKeyword{auto} \pthnId{j} \pthnOp{=} \pthnId{r}.\pthnId{begin}();\\
\>\pthnKeyword{while} (\pthnId{i} \pthnOp{!=} \pthnId{l}.\pthnId{cend}())\\
\>\>\pthnOp{*}\pthnId{j}\pthnOp{++} \pthnOp{=} \pthnId{f}(\pthnOp{*}\pthnId{i}\pthnOp{++});\\
\>\pthnKeyword{return} \pthnId{r};\\
\}
\end{python}
\end{cxxcode}
この関数\pthnId{map\_over}の中身部分はどうでもよろしい．それよりも，リストバージョンのマップ演算子の\cxx 関数のインタフェースと，Maybeバージョンのマップ演算子の\cxx 関数のインタフェースを見比べてみよう．
\begin{cxxcode}
\begin{python}
\verb|//| List\\
\pthnKeyword{template} $\langle$\pthnKeyword{typename} \pthnClassname{a}, \pthnKeyword{typename} \pthnClassname{fn}$\rangle$\\
\pthnId{std}::\pthnClassname{list}$\langle$\pthnClassname{a}$\rangle$ \pthnId{map\_over}(\pthnClassname{fn} \pthnId{f}, \pthnId{std}::\pthnClassname{list}$\langle$\pthnClassname{a}$\rangle$ \pthnId{t});\\
\verb|//| Maybe\\
\pthnKeyword{template} $\langle$\pthnKeyword{typename} \pthnClassname{a}, \pthnKeyword{typename} \pthnClassname{fn}$\rangle$\\
\pthnClassname{maybe}$\langle$\pthnClassname{a}$\rangle$ \pthnId{map\_over}(\pthnClassname{fn} \pthnId{f}, \pthnClassname{maybe}$\langle$\pthnClassname{a}$\rangle$ \pthnId{m});
\end{python}
\end{cxxcode}
やはりそっくりである．であるならば
\begin{cxxcode}
\begin{python}
\verb|//| \pthnClassname{X} \pthnOp{=} \pthnClassname{list}$\langle$\pthnClassname{a}$\rangle$ or \pthnClassname{maybe}$\langle$\pthnClassname{a}$\rangle$ \\
\pthnKeyword{template} $\langle$\pthnKeyword{typename} \pthnClassname{X}, \pthnKeyword{typename} \pthnClassname{fn}$\rangle$\\
\pthnClassname{X} \pthnId{map\_over}(\pthnClassname{fn} \pthnId{f}, \pthnClassname{X} \pthnId{x});
\end{python}
\end{cxxcode}
として，型\pthnClassname{X}に応じてリストバージョンかMaybeバージョンを切り替えられると便利である．

残念ながら，\cxx で楽に進める道はここら辺までである．型\pthnClassname{X}がマップ可能なコンテナであることをテンプレート機構を使って保証することができないため，この\pthnId{map\_over}関数を誤った型に対して使った場合のコンパイル時エラーはひどく読みにくいものになる．ヒューマンエラーを防ぐための型システムが，まさに型無しになってしまうのだ．

一方で，数学者たちが見つけた圏という代数的構造が，リストもMaybeも統一的に扱うことを可能にしている．これを発見したのは Eugenio Moggi を始めとする計算機科学者たちである．この人類の英知は第\ref{ch:functor}章から見ていくことにしよう．


\section{余計な話：単位的半群としてのコンテナ}

$$\mathMonoid{\hsklListType{\hsklType{a}}}{\hsklAppend}{\hsklEmptyList}$$

$$\mathMonoid{\hsklMaybeType{\hsklType{a}}}{\hsklMaybeAppend}{\hsklNothing}$$


\chapter{関手}
\label{ch:functor}

\begin{leader}
a
\end{leader}

\begin{boxnote}
\begin{center}
注意
\end{center}
関手は英語でファンクター(functor)と言うが，\cxx の関数オブジェクト(functional)もかつてはファンクター(functor)と呼ばれていた．\cxx のファンクターとはラムダ式の粗末な代用品のことで，本書で述べる関手とは異なる概念である．混同しないように注意しよう．
\end{boxnote}


\section{型コンストラクタと関手*}

圏$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$があるとする．
ここに集合$\mathSet{C}$は射の\keyword{対象}となる集合の集合であり，集合$\mathSet{P}$は射の集合である．
例えば$$\mathSet{C}=\{\hsklInt\},\;\mathSet{P}=\{-\}$$というのも圏の一つである．
この場合，整数と，その符号を反転させる写像（の集合）が圏の要素である．

ここにもう一つの圏$\mathCategoryShort{\mathSet{C}'}{\mathSet{P}'}$があるとする．
対象$\mathSet{C}$の各元と対象$\mathSet{C}'$の各元の間に一対一対応があり，また射$\mathSet{F}$の各元と射$\mathSet{P}'$の各元の間に一対一対応があるとき，圏$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$から圏$\mathCategoryShort{\mathSet{C}'}{\mathSet{P}'}$への「射」が存在する．
この射を\keyword{関手}と呼ぶ．
例えば$$\mathSet{C}'=\{\hsklListType{\hsklInt}\},\;\mathSet{P}'=\{(-\hsklMap)\}$$であるとき，整数($\hsklInt$)に対する単項演算($-$)と，整数のリスト($\hsklListType{\hsklInt}$)全体に対する単項演算($-\hsklMap$)は一対一に対応する．

つまり，$\hsklInt$型から$\hsklListType{\hsklInt}$型を作る型コンストラクタ$\hsklListConstructor$とマップ演算子$\hsklMap$があれば，圏$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$から圏$\mathCategoryShort{\mathSet{C}'}{\mathSet{P}'}$へとジャンプできるのである．

型コンストラクタ$\hsklListConstructor$とマップ演算子$\hsklMap$の組み合わせ$(\hsklListConstructor,\hsklMap)$は関手の一例である．

同じことが型コンストラクタ$\hsklMaybeConstructor$とMaybeバージョンのマップ演算子$\hsklMaybeMap$の組み合わせ$(\hsklMaybeConstructor,\hsklMaybeMap)$にも言える．

そこでリストのマップ演算子($\hsklMap$)，Maybeのマップ演算子($\hsklMaybeMap$)をひとくくりにして抽象的な\keyword{一般マップ演算子} ($\hsklFmap$)とする．一般マップ演算子は，右引数がリストであればリストのマップ演算子を，右引数がMaybeであればMaybeのマップ演算子に「化ける」．右引数がただの数であれば，ただの空白になる．

この意味は，もし$f\hsklFmap\hsklList{t}$と書いてあれば$f\hsklMap\hsklList{t}$のことであるし，もし$f\hsklFmap\hsklMaybe{m}$と書いてあれば$f\hsklMaybeMap\hsklMaybe{m}$のことであると，自動的に解釈することである．そして，何の飾りもつけられていない変数$x$がふらっと現れ，目の前に$f\hsklFmap x$という式が登場しても，落ち着いて変数$x$の型を調べ，変数$x$がリストならば$\hsklFmap$の部分に$\hsklMap$を，変数$x$がMaybeならば$\hsklFmap$の部分に$\hsklMaybeMap$をはめ込むのだ．\footnote{Haskellでは一般マップ演算子は\code{fmap}である．ただしその実装は与えられず，対象とする型に応じて定義されるものとする．例えばリストに対しては\code{fmap = map}と定義されている．}

つまり，型コンストラクタ$\hsklTypeConstructor{List}$は
\begin{equation*}
\left\{
\begin{split}
\hsklFmap&\xrightarrow{\;\hsklTypeConstructor{List}\;}\hsklMap\\
\hsklType{a}&\xrightarrow{\;\hsklTypeConstructor{List}\;}\hsklListType{\hsklType{a}}
\end{split}
\right.
\end{equation*}
という射であり，型コンストラクタ$\hsklTypeConstructor{Maybe}$は
\begin{equation*}
\left\{
\begin{split}
\hsklFmap&\xrightarrow{\;\hsklTypeConstructor{Maybe}\;}\hsklMaybeMap\\
\hsklType{a}&\xrightarrow{\;\hsklTypeConstructor{Maybe}\;}\hsklMaybeType{\hsklType{a}}
\end{split}
\right.
\end{equation*}
という射である．

\section{アプリカティブ関手}

関手の一般化マップ演算子をさらに汎用性のあるものにするために，二つの要素に分解する．
その要素とは\keyword{ピュア演算子}と\keyword{一般アプリカティブマップ演算子} $(\hsklApplicativeMap)$である．\footnote{Haskellでは一般アプリカティブマップ演算子を\code{<*>}と書く．}

一般マップ演算子が「普通の関数」$f$をコンテナの中の変数に適用するのに対し，一般アプリカティブマップ演算子はコンテナの中の関数をコンテナの中の変数へ適用する．

一般マップ演算子の実装に（リストバージョンの）マップ演算子，Maybeバージョンのマップ演算子があったように，一般アプリカティブマップ演算子にもリストバージョンのアプリカティブマップ演算子，Maybeバージョンのアプリカティブマップ演算子がある．

リストバージョンのアプリカティブマップ演算子$(\hsklApplicativeListMap)$は左引数のリスト内のすべての関数を順番に右引数のリスト内の変数に適用し，その結果をリストとして返す．
例えば$$[f,g,h]\hsklApplicativeMap[x,y,z]$$とした場合，左引数，右引数ともリストであるため$$[f,g,h]\hsklApplicativeMap[x,y,z]=[f,g,h]\hsklApplicativeListMap[x,y,z]$$となり，その結果は
\begin{align*}
[f,g,h]\hsklApplicativeMap[x,y,z]&=[f,g,h]\hsklApplicativeListMap[x,y,z]\\
&=[fx,fy,fz,gx,gy,gz,hx,hy,hz]
\end{align*}
である．

リストバージョンのアプリカティブマップ演算子は，（リストバージョンの）マップ演算子から再帰的に実装できる．リストバージョンのアプリカティブマップ演算子の実装は
\begin{equation*}
\left\{
\begin{split}
(f:\hsklList{g})\hsklApplicativeListMap\hsklList{t}&=\hsklConcat((f\hsklMap\hsklList{t}):(\hsklList{g}\hsklApplicativeListMap\hsklList{t}))\\
\hsklEmptyList\hsklApplicativeListMap\hsklList{t}&=\hsklEmptyList
\end{split}
\right.
\end{equation*}
である．

Maybeバージョンのアプリカティブマップ演算子($\hsklApplicativeMaybeMap$)は左引数がもし$\hsklJust{f}$の形をしていれば，その$f$を右変数$\hsklMaybe{m}$に対して$f\hsklMaybeMap\hsklMaybe{m}$と適用する．具体的には，もし$\hsklJust{(*)100}\hsklApplicativeMaybeMap{}\hsklJust{68}$という式が現れたとすると，アプリカティブマップ演算子の左引数から中身の関数$((*)100)$を抜き出して，右引数の中身$68$に適用し，その結果を再びMaybe値にして返す．式で書けば$$\hsklJust{(*)100}\hsklApplicativeMaybeMap{}\hsklJust{68}=\hsklJust{68000}$$となる．

Maybeバージョンのアプリカティブマップ演算子は，Maybeバージョンのマップ演算子から実装できる．その実装は
\begin{equation*}
\hsklMaybe{n}\hsklApplicativeMaybeMap\hsklMaybe{m}=\begin{cases}
f\hsklMaybeMap\hsklMaybe{m}&\mathIf\hsklMaybe{n}\equiv\hsklJust{f}\\
\hsklNothing&\mathOtherwise
\end{cases}
\end{equation*}
であり，さらにMaybeバージョンのマップ演算子を展開すると
\begin{align*}
\hsklMaybe{n}\hsklApplicativeMaybeMap\hsklMaybe{m}&=\begin{cases}
\left\{
\begin{array}{ll}
\hsklJust{fx}&\mathIf\hsklMaybe{m}\equiv\hsklJust{x}\\
\hsklNothing&\mathOtherwise
\end{array}\right\}&\mathIf\hsklMaybe{n}\equiv\hsklJust{f}\\
\hsklNothing&\mathOtherwise
\end{cases}\\
&=\begin{cases}
\hsklJust{fx}&\mathIf\hsklMaybe{m}\equiv\hsklJust{x}\wedge\hsklMaybe{n}\equiv\hsklJust{f}\\
\hsklNothing&\mathOtherwise
\end{cases}
\end{align*}
である．

ピュア演算子とは型コンストラクタを利用した「最もシンプルな」型変換演算子である．例えばリストのピュア演算子は単に$[x]$であるし，Maybeのピュア演算子は$\hsklJust{x}$である．一般のピュア演算子は$\hsklPure{x}$と書くものとする．ピュア演算子は，いまのところ便宜上導入されたものと考えて差し支えない．というのも，その主たる使い道が（アプリカティブではない）関手との後方互換性のためだからである．\footnote{Haskellは一般のピュア演算子の実装を与えていない．変数の型に応じて対応する関数が適用される．}

関手における一般マップ演算子$(\hsklFmap)$は，ピュア演算子と一般アプリカティブマップ演算子を使って$$f\hsklFmap x=\hsklPure{f}\hsklApplicativeMap x$$と再定義できる．

\section{関数と関手の関係*}

A...

\section{余計な話：アプリカティブスタイル}

関数適用演算子$\mathApply$とよく似た演算子$\hsklApplicativeApply$ただし$$f\hsklApplicativeApply g=\hsklPure{f\mathCompose g}$$なる演算子を導入する．この演算子は特別に\keyword{アプリカティブ関数適用演算子}と呼ぶ．\footnote{Haskellでは\code{<\$>}と書く．}

アプリカティブ関数適用演算子があると，わざわざピュア演算子を用いなくとも連続的に「普通の」関数をコンテナ型の引数に適用できる．いま変数$x$をコンテナ型とし，関数$f$と関数$g$が「普通」であるとすると$$f\hsklApplicativeApply g\hsklApplicativeMap x$$のようにして変数$x$に関数$g$，関数$f$を順に作用させることができる．このような書き方を\keyword{アプリカティブスタイル}と呼ぶ．

アプリカティブスタイルのいいところは，「普通の」関数が増えてもスタイルを変えなくて良いことである．例えば$$f\hsklApplicativeApply g\hsklApplicativeMap h\hsklApplicativeMap x$$は期待通りコンテナ型変数$x$に関数$h$，関数$g$，関数$f$を順に作用させる．これは$f\hsklApplicativeApply g\hsklApplicativeMap h$と$\hsklPure{f\mathCompose g\mathCompose h}$が同値だからである．

アプリカティブスタイルは，計算の流れを明確にしているとも言える．例えば$f\hsklApplicativeApply g\hsklApplicativeMap h\hsklApplicativeMap x$は$$x\leadsto h\leadsto g\leadsto f$$という計算の流れを示す．もちろん関数合成演算子と関数適用演算子でも似たことはできるが，関数合成演算子と関数適用演算子だけでは$x$が例えば$\hsklNothing$でる可能性を扱えないし，また計算の途中経過がなんらかのエラーで$\hsklNothing$になるような系も扱えない．（後者はアプリカティブスタイルでも扱えない．そのために次章で述べる「モナド」が登場する．）

\chapter{モナド}

\begin{leader}
A.
\end{leader}


\section{もうひとつの関手*}


アプリカティブ関手は関手の一般マップ演算子をピュア演算子と一般アプリカティブマップ演算子に分解することで，式の見通しを良くすることができるアプリカティブスタイルという記法を採用できた．しかしながら，アプリカティブスタイル変数に文脈を与えるタイミングは最初すなわち式の右端の1回に限られている．そこで，任意のタイミングで変数に文脈を与えられるように関手を改造したものが\keyword{モナド}である．

普通の（コンテナに入っていない）変数$x$をとり，普通の（コンテナに入っていない）戻り値を返す関数$f$があるとしよう．マップ演算子はコンテナに入れられた変数，例えば$\hsklList{t}=[x]$から中身$x$を取り出して関数$f$を適用し，その結果$fx$を再びコンテナに入れて$[fx]$を返す演算子であった．

もし，普通の変数$x$をとり，なんらかの不都合があった時には空のコンテナを返す関数$\phi$があればどうだろう．不都合があった時には空のコンテナを返すということは，不都合がなくても計算結果をコンテナにに詰めることになる．さもなければ関数の型がひとつに決まらないことになる．

関数$\phi$は次のような形になるだろう．
$$\phi x=\begin{cases}\hsklUnit{fx}&\text{普通に計算をしたとき}\\
\mathcal{O}&\text{不都合があったとき}\end{cases}$$
ここでコンテナに入れる演算を$\hsklUnit{\mathSomething}$とし，空のコンテナを$\mathcal{O}$とした．

---

では「普通ではない」関数はどうしたらいいだろうか．最も考えられる「普通ではない」関数とは「普通の」（コンテナに入っていない裸の）引数をとり，コンテナにつめた戻り値を返す関数である．

ここでようやく$0$除算の課題を扱える．
$$x\mathop{\%}y=\begin{cases}
\hsklJust{x/y}&\mathIf y\neq0\\
\hsklNothing&\mathOtherwise
\end{cases}
$$

---

リストのマップ演算子$$\hsklList{t}'=f\hsklMap\hsklList{t}$$を思い出そう．もし$\hsklList{t}\equiv\hsklEmptyList$ならば$\hsklList{t}'=\hsklEmptyList$になる．もし$\hsklList{t}\equiv[x_0,x_1\dots]$ならば$\hsklList{t}'=[fx_0,fx_1\dots]$になる．

Maybeのマップ演算子$$\hsklMaybe{m}'=g\hsklMaybeMap\hsklMaybe{m}$$を思い出そう．もし$\hsklMaybe{m}\equiv\hsklNothing$ならば$\hsklMaybe{m}'=\hsklNothing$になる．もし$\hsklMaybe{m}\equiv\hsklJust{y}$ならば$\hsklMaybe{m}'=\hsklJust{fy}$になる．

これらをまとめた一般マップ演算子$$z'=h\hsklFmap z$$も思い出そう．関数$h$は「普通の」関数である．

リストのアプリカティブマップ演算子$$\hsklList{t}'=\hsklList{f}\hsklApplicativeListMap\hsklList{t}$$を思い出そう．もし$\hsklList{f}\equiv\hsklEmptyList$ならば$\hsklList{t}'=\hsklEmptyList$になる．もし$\hsklList{f}\equiv[u_0,u_1\dots]$ならば$\hsklList{t}'=[u_0\hsklMap\hsklList{t},u_1\hsklMap\hsklList{t}\dots]$になる．

Maybeのアプリカティブマップ演算子$$\hsklMaybe{m}'=\hsklMaybe{g}\hsklApplicativeMaybeMap\hsklMaybe{m}$$を思い出そう．もし$\hsklMaybe{g}\equiv\hsklNothing$ならば$\hsklMaybe{m}'=\hsklNothing$になる．もし$\hsklMaybe{g}\equiv\hsklJust{v}$ならば$\hsklMaybe{m}'=\hsklJust{vy}$になる．

これらをまとめた一般アプリカティブマップ演算子$$z'=h\hsklApplicativeMap z$$も思い出そう．関数$h$は「普通の」関数をコンテナにつめたものである．
% ピュア演算子を用いると，元の一般マップ演算子との互換性が$$w\hsklFmap z=\hsklPure{w}\hsklApplicativeMap z$$のようにとれる．ここに$w$は「普通の」関数である．


---

そのような関数$\phi$があるとしよう．
$$\phi x=\begin{cases}\hsklUnit{x}&\text{普通に計算をしたとき}\\
\text{空のコンテナ}&\text{何かあったとき}\end{cases}$$
ちょっと待った．
$\hsklUnit{x}$とは何だろうか．
$\hsklUnit{x}$は\keyword{ユニット演算子}と言って，変数を最もシンプルな形でコンテナに納めるものである．
どこかで聞いた話ではないだろうか．
その通り，ユニット演算子は事実上ピュア演算子と同じものである．
ではなぜユニット演算子とピュア演算子を字面上区別しておくかというと，ひとつはモナドにより強い柔軟性を持たせるため，もう一つは，簡潔さのためである．
というのも，もしモナドがアプリカティブ関手とピュア演算子を共有するとなると，同時に一般アプリカティブマップ演算子も共有することになるが，モナドなマップ演算子から一般アプリカティブマップ演算子は合成できないため，モナドが「焼け太り」してしまうからである．
%!!!!!!!!!! CHECK !!!!!!!!!!

\begin{align*}
\hsklFmap&\mathIn{}\mathMorphII{(\mathMorph{\hsklType{a}}{\hsklType{b}})}{\langle\hsklType{a}\rangle}{\langle\hsklType{b}
\rangle}\\
\hsklApplicativeMap&\mathIn{}\mathMorphII{\langle\mathMorph{\hsklType{a}}{\hsklType{b}}\rangle}{\langle\hsklType{a}\rangle}{\langle\hsklType{b}\rangle}\\
\hsklMonadMap&\mathIn{}\mathMorphII{(\mathMorph{\hsklType{a}}{\langle\hsklType{b}\rangle})}{\langle\hsklType{a}\rangle}{\langle{\hsklType{b}}\rangle}
\end{align*}

$$\hsklPure{\mathSomething}\mathIn\mathMorph{\hsklType{a}}{\langle\hsklType{a}\rangle}$$

この関数$\phi$をコンテナにつめられた変数$x$に適用するための「モナドな」マップ演算子$\hsklMonadMap$を導入する．
$$x'=\phi\hsklMonadMap x$$

関手とは
$$f\hsklFmap x=\hsklUnit{f}\hsklMonadMap x$$
とすれば互換性がとれる．


ピュア演算子，ユニット演算子．


\section{モナドな関数*}


具体例として引数が$2^{32}$未満なら引数の値をそのまま，それ以上なら$\hsklNothing$を返す関数$a$を考えてみよう．
\begin{equation*}
ax=\begin{cases}
\hsklJust{x}&\mathIf x<2^{32}\\
\hsklNothing&\mathOtherwise
\end{cases}
\end{equation*}


もうひとつの具体例として「安全な」割り算演算子$\div$を定義してみよう．
ここで
\begin{equation*}
\hsklMaybe{m}\div y=\begin{cases}\hsklJust{x/y}&\mathIf m\neq\hsklNothing\mathAnd y\neq0\\
\hsklNothing&\mathOtherwise\end{cases}
\end{equation*}
とする．
ただし$\hsklMaybe{m}$は$\hsklJust{x}$か，あるいは$\hsklNothing$かのどちらかの値が入っている．
$x\neq\hsklNothing$かつ$y\neq0$のときの戻り値が$x/y$ではなく$\hsklJust{x/y}$なのは，計算結果が汚染の可能性を持つからである．


\begin{table*}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c|c||}
\hline
\multirow{2}{*}{型クラス}
    &\multicolumn{3}{|c|}{$\hsklApplicative$}
    &\multicolumn{4}{|c||}{$\hsklMonadplus$}\\
\cline{4-8}
\multirow{1}{*}{}
    &\multicolumn{2}{|c|}{ }
    &$\hsklFunctor$
    &\multicolumn{2}{|c}{$\hsklMonad$}
    &\multicolumn{2}{|c||}{$\hsklMonoid$}\\
\hline\hline
型$\backslash$要素と演算子
    &$\hsklPure{x}$
    &$\hsklApplicativeMap$
    &$\hsklFmap$
    &$\hsklUnit{x}$
    &$\hsklMonadMap$
    &$O$
    &$\mathAnyBinaryOperator$\\
\hline
リスト
    &$[x]$
    &$\hsklApplicativeListMap$
    &$\hsklMap$
    &$[x]$
    &$\clubsuit$
    &$\hsklEmptyList$
    &$\hsklAppend$\\
\hline
Maybe
    &$\hsklJust{x}$
    &$\hsklApplicativeMaybeMap$
    &$\hsklMaybeMap$
    &$\hsklJust{x}$
    &$\spadesuit$
    &$\hsklNothing$
    &$\hsklMaybeAppend$\\
\hline
関数
    &$\langle\!\langle x\rangle\!\rangle$
    &$\bowtie$
    &$\mathCompose$
    &$\langle\!\langle x\rangle\!\rangle$
    &$\circ$
    &$\mathLambdaAnonymousParameter$
    &$\mathCompose$\\
\hline
Int（参考）
    &
    &
    &
    &
    &
    &$0$
    &$+$\\
\hline
\end{tabular}
\end{center}
\end{table*}


\section{Haskellのモナド*}

\section{余計な話：モナドプラス}


---

\part{モナドから見る世界}

\chapter{IO}

\section{参照透過性}

\section{アクション}

\section{IOモナド}

\chapter{例外}

\section{例外}

\section{do記法}

\chapter{乱数}

\chapter{状態}

\chapter{非決定性}

\chapter{新しい型を作る}

\chapter{木構造}

\chapter{スペースの使い方}

\chapter{継続}

\section{継続とは}


\part{圏・モナド・プログラミング言語}

\chapter{クライスリ・トリプル}

\chapter{ラムダ}

\end{document}
