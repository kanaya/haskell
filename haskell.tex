\documentclass[twocolumn]{jsbook}
\usepackage{amsmath,amssymb,ascmac,bm,multirow}

\title{プログラマのための代数構造}
\author{Ichi Kanaya}
\date{2016}

\def\[{[\![}
\def\]{]\!]}

\newcommand{\hsklType}[1]{\textbf{#1}}
\newcommand{\hsklOf}[1]{\mathop{::}#1}

\newcommand{\mathAnyBinaryOperator}{\mathop{\bigstar}}
\newcommand{\mathAnyUnaryOperator}{\star}
\newcommand{\mathLambda}{\backslash}
\newcommand{\mathLambdaAnonymousParameter}{\lozenge}
\newcommand{\mathMapsTo}{\mapsto}
\newcommand{\mathSetTimes}{\circledast}
\newcommand{\mathSomething}{\square}

\newcommand{\mathIn}[1]{\mathop{::}#1}
\newcommand{\mathInverse}[1]{\Tilde{#1}}
\newcommand{\mathSet}[1]{\mathbf{#1}}
\newcommand{\mathVector}[1]{\boldsymbol{#1}}

\newcommand{\mathCategory}[2]{(#1,#2)}
\newcommand{\mathLambdaExpression}[2]{\mathLambda#1\rightarrow#2}

\newcommand{\mathGroup}[4]{(#1,#2,#3,#4)}

\newcommand{\mathField}[7]{(#1,#2,#3,#4,#5,#6,#7)}


% ---

\def\boxcirc{\mathrel{\mathchoice{\BOXCIRC}{\BOXCIRC}{\scriptsize\BOXCIRC}{\tiny\BOXCIRC}}}
\def\BOXCIRC{{\setbox0\hbox{$\circ$}\rlap{\hbox to \wd0{\hss$\square$\hss}}\box0}}

\newcommand{\keyword}[1]{\emph{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newenvironment{leader}{\begingroup\bf}{\endgroup}
\newenvironment{point}{\begin{screen}}{\end{screen}}
\newenvironment{footnotecode}{\begin{verbatim}}{\end{verbatim}}

% Lambda
\newcommand{\lambdasym}{\backslash}
\newcommand{\lambdadot}{\rightarrow}
\newcommand{\lambdaexp}[2]{\lambdasym#1\lambdadot#2}
\newcommand{\lambdacut}{\lozenge}

% Typeclasses
\newcommand{\typeclassname}[1]{\mathfrak{#1}}
\newcommand{\typeclassapplicative}{\typeclassname{Applicative}}
\newcommand{\typeclassbounded}{\typeclassname{Bounded}}
\newcommand{\typeclassenum}{\typeclassname{Enum}}
\newcommand{\typeclasseq}{\typeclassname{Eq}}
\newcommand{\typeclassfunctor}{\typeclassname{Functor}}
\newcommand{\typeclassintegral}{\typeclassname{Integral}}
\newcommand{\typeclassmonad}{\typeclassname{Monad}}
\newcommand{\typeclassmonadplus}{\typeclassname{Monadplus}}
\newcommand{\typeclassmonoid}{\typeclassname{Monoid}}
\newcommand{\typeclassnum}{\typeclassname{Num}}
\newcommand{\typeclassord}{\typeclassname{Ord}}
\newcommand{\typeclassreal}{\typeclassname{Real}}

% Types
\newcommand{\typename}[1]{\mathbf{#1}}
\newcommand{\typeconstructor}[2]{\mathop{#1}\,#2}
\newcommand{\typebool}{\typename{Bool}}
\newcommand{\typechar}{\typename{Char}}
\newcommand{\typefunction}{\typename{Function}}
\newcommand{\typeint}{\typename{Int}}
\newcommand{\typefloat}{\typename{Float}}
\newcommand{\typelist}{\typename{List}}
\newcommand{\typemaybe}{\typename{Maybe}}

% Morph
\newcommand{\morph}[2]{#1\mapsto#2}
\newcommand{\mmorph}[3]{#1\mapsto#2\mapsto#3}
\newcommand{\mmorphwithparenthesis}[3]{#1\mapsto(#2\mapsto#3)}
\newcommand{\mmmorph}[4]{#1\mapsto#2\mapsto#3\mapsto#4}

% Parameters
\newcommand{\anonymousparameter}{\lozenge}

% Constants
\newcommand{\constantname}[1]{\mathrm{#1}}
\newcommand{\constanttrue}{\constantname{T}}
\newcommand{\constantfalse}{\constantname{F}}
\newcommand{\constantempty}{\emptyset}
\newcommand{\constantnothing}{\varnothing}
\newcommand{\constantidentityfunction}{\anonymousparameter}

% Unary ops.
\newcommand{\unarypred}{\blacktriangleleft}
\newcommand{\unarysucc}{\blacktriangleright}

% Binary ops.
\newcommand{\binaryeq}{\equiv}
\newcommand{\binaryl}{<}
\newcommand{\binaryle}{\le}
\newcommand{\binaryge}{\ge}
\newcommand{\binaryg}{>}
\newcommand{\binaryadd}{+}
\newcommand{\binarysub}{-}
\newcommand{\binarymultiply}{*}
\newcommand{\binarydivide}{/}
\newcommand{\binaryor}{\vee}
\newcommand{\binaryand}{\wedge}
\newcommand{\binarycompose}{\bullet}
\newcommand{\binaryfunctormap}{\cdot}
\newcommand{\binaryapplicativemap}{\times}
\newcommand{\binarymonadmap}{\heartsuit}%{\Leftarrow}
\newcommand{\binarylistfunctormap}{\odot}
\newcommand{\binarylistapplicativemap}{\otimes}
\newcommand{\binarylistmonadmap}{\circ}%{\hookleftarrow}
\newcommand{\binarylistappend}{\oplus}
\newcommand{\binarymaybefunctormap}{\boxdot}
\newcommand{\binarymaybeapplicativemap}{\boxtimes}
\newcommand{\binarymaybemonadmap}{\Box}%{\leftleftarrows}
\newcommand{\binarymaybeappend}{\boxplus}
\newcommand{\binaryfunctionfunctormap}{\binarycompose}
\newcommand{\binaryfunctionapplicativemap}{\Join}%{\bowtie}
\newcommand{\binaryfunctionmonadmap}{\diamond}%{\blacktriangleright\!\blacktriangleleft}%{\twoheadleftarrow}
\newcommand{\binaryapply}{\mathop{\$}}
\newcommand{\binaryconcat}{:}

% Functions
\newcommand{\functionpred}{\mathop{\text{pred}}}
\newcommand{\functionsucc}{\mathop{\text{succ}}}

% Parenthesis ops.
\newcommand{\applicativetype}[1]{\left\langle#1\right\rangle}
\newcommand{\listtype}[1]{\left[#1\right]}
\newcommand{\maybetype}[1]{\left\{#1\right\}}
\newcommand{\functyontype}[1]{\[#1\]}

% Guard
\newcommand{\guard}[1]{\mathop{\mid_{#1}}}
\newcommand{\guardcomma}{,\,}

% Range
\newcommand{\isin}{\in}
\newcommand{\rangedots}{\dots}
\newcommand{\infinitydots}{\dots}

% Type and class
\newcommand{\istypeof}{\mathop{::}}
\newcommand{\isclassof}{\subset}

% Keywords
\newcommand{\keywordname}[1]{\mathbf{#1}}
\newcommand{\keywordotherwise}{\keywordname{otherwise}}
\newcommand{\keywordif}{\mathop{\keywordname{if}}}
\newcommand{\keywordthen}{\mathop{\keywordname{then}}}
\newcommand{\keywordelse}{\mathop{\keywordname{else}}}

% Special words
\newcommand{\specialwordname}[1]{\mathsf{#1}}
\newcommand{\specialwordfirst}{\specialwordname{First}}
\newcommand{\specialwordrest}{\specialwordname{Rest}}

% Math
\newcommand{\mathbinaryop}{\bigstar}
\newcommand{\mathidentity}{\mathcal{O}}
\newcommand{\mathidentitymorph}{\mathcal{I}}
\newcommand{\mathsetname}[1]{\boldsymbol{#1}}
\newcommand{\mathfunctorname}[1]{\mathbb{#1}}
\newcommand{\mathtriple}[3]{(#1,#2,#3)}
\newcommand{\mathcompose}{\bullet}
\newcommand{\mathfold}{\bigcup}
\newcommand{\mathfoldright}{\bigsqcup}
\newcommand{\mathwhere}{\mathop{\text{where}}}

\begin{document}
\maketitle
\tableofcontents

\part{代数構造とプログラミング}

\chapter{はじめに}

Haskellというプログラミング言語を知ろうとすると，従来のプログラミング言語の知識が邪魔をする．
モダンで，人気があって，Haskellから影響を受けた言語，例えばRubyやSwiftの知識さえ，Haskellを学ぶ障害になり得る．
ではどのようにしてHaskellの深みに到達すればいいのだろうか．

その答えは，一見遠回りに見えるが，一度抽象数学の高みに登ることである．

と言っても，あわてる必要はない．

近代的なプログラミング言語を知っていれば，すでにある程度抽象数学に足を踏み入れているからである．

\chapter{数学的準備}

\begin{leader}
この章では「代数的構造」を見ていくことにする．
代数的構造とは，四則演算のような数に関する基本的な性質を抽象化していくことで，数の背後にある基本的なメカニズムを抽出したものである．
代数的構造はあらゆるプログラミング言語に明示的，あるいは非明示的に見られる要素である．
\end{leader}

\section{数}

これから各種の\keyword{代数的構造}を見ていくことにする．
代数的構造と言っても，身構える必要はない．
それは，我々プログラマが日々接している概念に，共通した名前を与えたにすぎない．

まず最初に，我々にとって一番身近な代数的構造である\keyword{数}を見てみよう．
数の代表例は\keyword{実数}であるから，実数を例にとって考えてみよう．
実数全体の集合を$\mathSet{R}$で表すことにする．
また任意の実数を$x,y,z$で表すこととする．
このことを数学者は$x,y,z\in\mathSet{R}$と書くが，我々は記号$\in$を別の用途に使いたいので，本書では$$x,y,z\mathIn\mathSet{R}$$と表すことにする．

以下に実数の備える代数的性質を列挙する．
どれも当たり前のことに見えるが，ひとつひとつ見ていこう．
ここで$x,y,z\mathIn\mathSet{R}$とする．
\begin{description}
\item[実数の性質1. 足し算] $x$と$y$の足し算（\keyword{加法}）の結果（\keyword{和}）$x+y$は$\mathSet{R}$の元すなわち実数である．
\item[実数の性質2. 足し算の結合則] $x,y,z$について$$(x+y)+z=x+(y+z)$$である．これを\keyword{結合則}と呼ぶ．
\item[実数の性質3. 零元（加法単位元）の存在] $0\mathIn\mathSet{R}$があり$$0+x=x+0=x$$である．この$0$は足し算の\keyword{単位元}である．\keyword{零元}または\keyword{加法単位元}と呼ぶこともある．
\item[実数の性質4. 負元（加法逆元）の存在] $x$に対して$-x\mathIn\mathSet{R}$があり$$-x+x=0$$である．この$-x$は$x$の足し算の\keyword{逆元}である．\keyword{負元}または\keyword{加法逆元}と呼ぶこともある．
\item[実数の性質5. 足し算の可換性] $x,y$について$$x+y=y+x$$である．このことを足し算の\keyword{可換性}と呼ぶ．
\item[実数の性質6. 掛け算] $x$と$y$の掛け算（\keyword{乗法}）の結果（\keyword{積}）$x*y$は$\mathSet{R}$の元すなわち実数である．
\item[実数の性質7. 掛け算の結合則] $x,y,z$について$$(x*y)*z=x*(y*z)$$である．
\item[実数の性質8. 単位元の存在] $1\mathIn\mathSet{R}$があり$$1*x=x*1=x$$である．この$1$を掛け算の単位元または\keyword{乗法単位元}と呼ぶ．
\item[実数の性質9. 逆元] $x$に対して$x^{-1}\mathIn\mathSet{R}$があり$$x^{-1}*x=1$$である．この$x^{-1}$は$x$の掛け算の逆元である．\keyword{乗法逆元}と呼ぶこともある．ただし性質11で述べる通り，加法単位元については逆元がなくても良い．
\item[実数の性質10. 掛け算の可換性] $x,y$について$$x*y=y*x$$である．このことを掛け算の可換性と呼ぶ．
\item[実数の性質11. 加法単位元の乗法逆元] 加法単位元に対する掛け算の逆元は存在しなくても良い．（つまり$0^{-1}$のことは考えなくて良い．）
\item[実数の性質12. 分配則] 足し算と掛け算が混在する場合$$x*(y+z)=x*y+x*z$$と掛け算を\keyword{分配}する．
\end{description}
以上が実数の代数的性質の全てである．
我々がよく使う割り算，引き算はプログラミングでいう糖衣構文 (syntax sugar) である．

上述の12個の条件が当てはまる数には，\keyword{有理数}や\keyword{複素数}がある．
この12個の性質をまとめて，数学では\keyword{体}と呼ぶ．
わざわざ可換と断るのは，現代の数学では$x*y\neq y*x$であるような体系がよく用いられるからである．

体の要素は，集合$\mathSet{K}$，二項演算子$+$，二項演算子$+$の単位元$0$，二項演算子$+$の逆元生成演算子$-$，もう一つの二項演算子$*$，二項演算子$*$の単位元$1$，二項演算子$*$の逆元生成演算子${}^{-1}$であるから，体はそれらを列挙して$\mathField{\mathSet{K}}{+}{0}{-}{*}{1}{{}^{-1}}$と表現する．

体の性質から言えることを一つ紹介しよう．
これから$$z\uparrow n=\underbrace{z*\dotsb*z}_n$$なる二項演算子$\uparrow$（\keyword{クヌースの矢印}）を使う．
ここに$z$を体$\mathField{\mathSet{K}}{+}{0}{-}{*}{1}{{}^{-1}}$の$\mathSet{K}$の元，$n$を自然数とした．
さて$z\uparrow2$は$$z\uparrow2=z*z$$であるから，いま$z=x+y$とすると
\begin{align*}
z\uparrow2&=z*z\\
&=z*(x+y)\\
&=z*x+z*y\;\dots\;\text{分配則}\\
&=(x+y)*x+(x+y)*y\\
&=x*x+y*x+x*y+y*y\;\dots\;\text{分配則}\\
&=x\uparrow2+x*y+y*x+y\uparrow2
\end{align*}
となり
\begin{equation}
\label{eq:xysq}
(x+y)\uparrow2=x\uparrow2+x*y+y*x+y\uparrow2
\end{equation}
を得る．
式\eqref{eq:xysq}は体の性質だけを使って導いた関係なので，実数だけでなく有理数や複素数にもそのまま使える．
実際には式\eqref{eq:xysq}は体の性質のうち分配則だけを使っいるので，体以外にも応用が利く式である．

一方で，この体の性質を若干緩めたい場合もある．
さもなければ，\keyword{整数}，\keyword{正方行列}，\keyword{クォータニオン}（四元数），\keyword{論理値}，\keyword{ベクトル}，ベクトルの\keyword{変換}，\keyword{写像}と言った重要な概念が数の概念からこぼれてしまうからである．
例えば整数の掛け算の逆元は（単位元の逆元を除いて）整数の中には存在しないし，正則行列やクォータニオンの場合は掛け算が可換ではない．
だいたいどの辺まで制約を緩めたものを数の仲間に入れるかというのは見解の分かれるところでもあるが，体から性質9（掛け算の逆元），性質10（掛け算の可換性），性質11（加法単位元の乗法逆元）を取り除いたものを\keyword{環}と呼び，環の性質を持つものを数の仲間に入れることが一般的である．
環の性質を持つものは，体である実数，有理数，複素数に加えて，整数，正方行列，クォータニオン，論理値などがある．

制約を少しずつ緩める代わりに，制約をその構成要素に分解するほうがさらなる応用が利きそうである．
体には二つの二項演算子$+$と$*$が登場した．
その片方にのみ注目してみたらどうなるだろう．
それが次節で取り上げる\keyword{群}である．

\begin{table*}
\caption{代表的な代数的構造の性質(1)}
\label{tab:field-and-ring}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c||}
\hline
代数的構造&$\mathAnyBinaryOperator_1$&$\mathAnyBinaryOperator_1$の単位元&$\mathAnyBinaryOperator_1$の逆元&$\mathAnyBinaryOperator_2$&$\mathAnyBinaryOperator_2$の単位元&$\mathAnyBinaryOperator_2$の逆元\\
\hline\hline
体&可換&あり&あり&可換&あり&あり\\
環&可換&あり&あり&非可換&あり&なし\\
\hline
\end{tabular}
\end{center}
\end{table*}

\section{群}

形式的に二項演算子$+$を$\mathAnyBinaryOperator_1$とし，二項演算子$*$を$\mathAnyBinaryOperator_2$として，体と環の性質を並べたものが表\ref{tab:field-and-ring}である．
これを見ると，演算子$\mathAnyBinaryOperator$について「可換・単位元あり・逆元あり」の組み合わせが二つペアになったもの（体）か，「可換・単位元あり・逆元あり」の組み合わせと「非可換・単位元あり・逆元なし」の組み合わせがペアになったもの（環）があり，その構成要素は二項演算子$\mathAnyBinaryOperator$について「可換・単位元あり・逆元あり」と「非可換・単位元あり・逆元なし」の2種類であることがわかる．

いま集合$\mathSet{G}$があり，$x,y,z\mathIn\mathsetname{G}$であるとし，二項演算子を形式的に$\mathAnyBinaryOperator$と書くことにして，体の性質の前半分を書き下してみよう．
\begin{description}
\item[性質1.] $x$と$y$の演算の結果$x\mathAnyBinaryOperator y$は$\mathSet{G}$の元である．
\item[性質2.] $x,y,z$について$$(x\mathAnyBinaryOperator y)\mathAnyBinaryOperator z=x\mathAnyBinaryOperator(y\mathAnyBinaryOperator z)$$である．これを結合則と呼ぶ．
\item[性質3.] $O\mathIn\mathSet{G}$があり$$O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x$$である．この$O$は単位元である．
\item[性質4.] $x$に対して$\mathInverse{x}\mathIn\mathSet{G}$があり$$\mathInverse{x}\mathAnyBinaryOperator x=O$$である．この$\mathInverse{x}$は$x$の逆元である．
\item[性質5.] $x,y$について$$x\mathAnyBinaryOperator y=y\mathAnyBinaryOperator x$$である．
\end{description}
このような性質が満たされる時，組み合わせ$\mathGroup{\mathSet{G}}{O}{\mathInverse{\mathSomething}}{\mathAnyBinaryOperator}$を\keyword{可換群}または\keyword{加群}と呼ぶ．
この可換群が最初の構成要素「可換・単位元あり・逆元あり」の正体である．

例えば$\mathGroup{\mathSet{R}}{0}{-}{+}$は可換群である．
整数全体の集合を$\mathSet{Z}$とすると$\mathGroup{\mathSet{Z}}{0}{-}{+}$も可換群である．
また，集合$\mathSet{R}$から$0$だけを取り除いた集合を$\mathSet{R}\setminus0$とするとき$\mathGroup{\mathSet{R}\setminus0}{1}{\mathSomething^{-1}}{*}$も可換群である．

可換群は代表的な代数的構造のひとつであり，他にも数学のあちこちに顔を出している．
例えば回転角を$r$とする二次元の回転変換（行列）を$U_r$ただし$$U_r=\begin{bmatrix}\cos r&-\sin r\\\sin r&\cos r\end{bmatrix}$$として，回転変換$U_r$すべてからなる集合$\mathSet{U}$を考えてみよう．
回転の合成を$\bullet$で表すとすると
\begin{equation}
\label{eq:rotation}
U_{r_1}\bullet U_{r_2}=U_{(r_1+r_2)}
\end{equation}
であるから，回転を合成した結果も回転である．
また式\eqref{eq:rotation}から$$U_{r_1}\bullet\left(U_{r_2}\bullet U_{r_3}\right)=\left(U_{r_1}\bullet U_{r_2}\right)\bullet U_{r_3}$$
であるから，回転変換は結合則も満たしている．

次にに回転変換に単位元があるかどうか調べてみよう．
回転しない変換は\keyword{恒等変換}とも言い，しばしば$I$で表す．
何もしない回転変換は$0$度の回転であるから$I=U_0$である．
このとき$$I\bullet U_r=U_r\bullet I=U_r$$であるから，$I$は回転変換の単位元であると言える．

最後に回転変換に逆元があるかも調べてみよう．
$r$回転の逆は明らかに$-r$であるから$$U_{-r}\bullet U_r=U_r\bullet U_{-r}=I$$が成り立つ．
そこで$$U_{r}^{-1}=U_{-r}$$として$U_r$の逆元$U_r^{-1}$を定義することができる．

このように，組み合わせ$\mathGroup{\mathSet{U}}{I}{\mathSomething^{-1}}{\bullet}$も可換群である．

任意次元のベクトル全体からなる集合を$\mathSet{V}$として，零ベクトルを$\mathVector{o}$で表すことにしよう．
ベクトル同士の加算を二項演算子$+$で表し，向きを反転させた逆ベクトル作る演算子を$-$とすると，組み合わせ$\mathGroup{\mathSet{V}}{\mathVector{o}}{-}{+}$もまた可換群である．

可換群の性質のうち最初の4項目だけを満たすものを\keyword{群}と呼ぶ．
可換群は群の特別な場合である．
現代の数学では$x\mathAnyBinaryOperator y\neq y\mathAnyBinaryOperator x$のように演算子の前後を入れ替えると結果が異なるような演算をよく取り扱うので，一般の群は可換群よりもよく取り上げられ，それ故より短い名前が付けられている．

組み合わせ$\mathGroup{\mathSet{G}}{O}{\mathInverse{\mathSomething}}{\mathAnyBinaryOperator}$が群である条件は
\begin{description}
\item[群の性質1.] $x$と$y$の演算の結果$x\mathAnyBinaryOperator y$は$\mathSet{G}$の元である．
\item[群の性質2.] $x,y,z$について$$(x\mathAnyBinaryOperator y)\mathAnyBinaryOperator z=x\mathAnyBinaryOperator(y\mathAnyBinaryOperator z)$$である．
\item[群の性質3.] $O\mathIn\mathSet{G}$があり$$O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x$$である．
\item[群の性質4.] $x$に対して$\mathInverse{x}\mathIn\mathSet{G}$があり$$\mathInverse{x}\mathAnyBinaryOperator x=O$$である．
\end{description}
であった．
これらの条件を少し緩め，逆元が存在しなくても良い「緩やかな群」を考えてみる．
この「緩やかな群」のことを\keyword{単位的半群}または\keyword{モノイド}と呼ぶ．
これが構成要素「非可換・単位元あり・逆元なし」の正体である．

\begin{table}
\caption{代表的な代数的構造の性質 (2)}
\label{tab:group-and-monoid}
\begin{center}
\begin{tabular}{||c||c|c|c||}
\hline
代数的構造&$\mathAnyBinaryOperator$&$\mathAnyBinaryOperator$の単位元&$\mathAnyBinaryOperator$の逆元\\
\hline\hline
可換群&可換&あり&あり\\
群&非可換&あり&あり\\
単位的半群&非可換&あり&なし\\
半群&非可換&なし&なし\\
\hline
\end{tabular}
\end{center}
\end{table}

単位的半群の性質は次の三つである．ただし$x,y,z$が集合$\mathSet{M}$の元であるとする．
\begin{description}
\item[単位的半群の性質1.] $x$と$y$の演算の結果$x\mathAnyBinaryOperator y$は$\mathSet{M}$の元である．
\item[単位的半群の性質2.] $x,y,z$について$$(x\mathAnyBinaryOperator y)\mathAnyBinaryOperator z=x\mathAnyBinaryOperator(y\mathAnyBinaryOperator z)$$である．
\item[単位的半群の性質3.] $O\mathIn\mathSet{M}$があり$$O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x$$である．
\end{description}
可換群とこの単位的半群を組み合わせたのが環，可換群二つを組み合わせたのが体であった．

単位的半群の性質からさらに性質3を消したものを\keyword{半群}と呼ぶ．

\section{圏}

これまでは集合の元同士に対する二項演算を考えてきた．
集合$\mathSet{M}$が単位的半群であるとき，集合$\mathSet{M}$の元$x,y\mathIn\mathSet{M}$に対して$x\mathAnyBinaryOperator y\mathIn\mathSet{M}$であった．
これは演算子$\mathAnyBinaryOperator$に着目すると，この演算子$\mathAnyBinaryOperator$は集合$\mathSet{M}$の元2個から出発して，集合$\mathSet{M}$の元1個へとジャンプさせる\keyword{写像}であると言える．
これを$$\mathAnyBinaryOperator\mathIn\mathSet{M}\mathSetTimes\mathSet{M}\mathMapsTo\mathSet{M}$$と書く．
ここに$\mathSet{A}\mathSetTimes\mathSet{B}$を集合$\mathSet{A}$と集合$\mathSet{B}$の\keyword{直積集合}と言う．

写像は$\mathSet{M}\mathSetTimes\mathSet{M}\mathMapsTo\mathSet{M}$に限ったもの出はなく，集合$\mathSet{M}$から集合$\mathSet{M}$への写像$\mathAnyUnaryOperator$ただし$$\mathAnyUnaryOperator\mathIn\mathSet{M}\mathMapsTo\mathSet{M}$$があっても良い．
実はこれまでにも登場した逆元を作る演算子はまさに$\mathSet{M}\mathMapsTo\mathSet{M}$という写像である．

またベクトルには，実数倍や回転といった写像がある．
これらは実数のパラメタを一つとるので，ベクトル全体の集合を$\mathSet{V}$，実数全体の集合を$\mathSet{R}$として，実数のパラメタを$r$としたときに$$\mathAnyUnaryOperator_r\mathIn\mathSet{R}\mathSetTimes\mathSet{V}\mathMapsTo\mathSet{V}$$と書ける．
例えば回転の場合は$\mathAnyUnaryOperator_r=U_r$である．

このように一般化した演算子$\mathAnyUnaryOperator$と，それが定義される集合$\mathSet{C}$の組み合わせ$\mathCategory{\mathSet{C}}{\mathAnyUnaryOperator}$のことを\keyword{圏}と呼ぶ．
また写像（ここでは演算子$\mathAnyUnaryOperator$のこと）を一般に\keyword{射}と呼ぶ．

圏が非常に重要な概念であることは徐々に明らかになる．

\section*{余計な話}

ブール束について．

\chapter{記法}

\begin{leader}
本書では一般の数学書やプログラミングの教科書からは少し異なった記法を用いる．
ある概念が発明されてからずっと後になって正しい記法が見つかり，それがきっかけとなって正しく理解されるという現象は歴史上よくあることである．
本書でも様々な新しい記号，記法を導入するが，この章では既に比較的広く知られている記法を紹介する．
\end{leader}


\section{関数}

関数引数には括弧を付けない．我々はよく引数$x$をとる関数$f$を$f(x)$と書くが，括弧は冗長なので今後は$fx$と書くことにする．
引数$x$を関数$f$に「食わせる」ことを\keyword{関数適用}と呼ぶ．

複数引数をとる関数を我々はよく$f'(x,y)$と書くが，これも括弧が冗長なので今後は$f'xy$と書くことにする．
この場合式$f'xy$は左を優先して結合するものとする．つまり$$f'xy=(f'x)y$$である．
引数に「飢えた」関数$(fx)$を\keyword{部分適用}された関数と呼ぶ．\footnote{Haskellでは関数\code{f}に引数\code{x}を適用させることを \code{f x} と書く．}

このように式の左側を優先的に演算していくことを\keyword{左結合}と呼ぶ．
関数適用は左結合である．
他に式の右側を優先的に演算する\keyword{右結合}の演算子も存在する．

\section{演算子}

単項演算子には論理否定($\neg$)とマイナス($-$)がある．
本書で扱う基本的な単項演算子はこの2種類だけであるが，複数の演算子を組み合わせて単項演算子を新たに作ることはある．

二項演算子のうちよく使われるものは和($+$)，積($*$)，差($-$)，商（$/$），論理和($\vee$)，論理積($\wedge$)，同値($\equiv$)，大なり($>$)，小なり($<$)等である．
二項演算子はたとえ積記号であっても省略できない．
二項演算子は多数あるので，その都度説明する．

二項演算子は中置することが基本であるが，括弧で包むことで前置することも可能である．
任意の二項演算子$\mathAnyBinaryOperator$について$$x\mathAnyBinaryOperator y$$及び$$(\mathAnyBinaryOperator)xy$$は全く同じ意味である．\footnote{Haskellでは任意の二項演算子を括弧で包むことで前置演算子として使うことができる．例えば\code{x+y}と \code{(+)x y} は同じ結果を返す．逆に任意の二引数関数\code{f}は \code{x `f` y} と書くことで中置することができる．}

二項演算子の結合性，すなわち左結合か右結合かは，演算子によって異なる．

演算の優先順位を明示的に与えるために括弧が用いられる．

\begin{point}
任意の二項演算子$\mathAnyBinaryOperator$について$$x\mathAnyBinaryOperator y=(\mathAnyBinaryOperator)xy$$である．
\end{point}

\section{ラムダ式}
引数$x$をとり値$1+x$を返す\keyword{ラムダ式}は次のように書くことにする．
$$\mathLambdaExpression{x}{1+x}$$
この式はラムダ式を発明したチャーチのオリジナルの論文の記法であれば$\Hat x\,.\,1+x$と書かれたところであり，現在でも多くの書物で$\lambda x\,.\,1+x$と記述されるところである．
しかし我々はすべてのギリシア文字を変数名のために予約しておきたいのと，ピリオド記号($.$)が今後登場する二項演算子$\cdot$と紛らわしいため，上述の記法を用いる．\footnote{Haskellではこのラムダ式を \code{\textbackslash x->1+x} と書く．}

ラムダ式は関数である．
ラムダ式を適用するには，ラムダ式を括弧で包む必要がある．
例を挙げる．
$$\left(\mathLambdaExpression{x}{1+x}\right)2$$
この式は結果として$3$を返す．

複数引数をとるラムダ式は例えば$$\mathLambdaExpression{xy}{x+y}$$のように引数を並べて書く．

本書では新たに，次のラムダ式記法も導入する．
式中に記号$\mathLambdaAnonymousParameter$が現れた場合，その式全体がラムダ式であるとみなす．
記号$\mathLambdaAnonymousParameter$の部分には引数が入る．
第$n$番目の$\mathLambdaAnonymousParameter$には第$n$番目の引数が入る．
例えばラムダ式$\mathLambdaExpression{xy}{x+y}$は$$\mathLambdaAnonymousParameter+\mathLambdaAnonymousParameter$$と書いても良い．
式を左から読んで1番目の$\mathLambdaAnonymousParameter$が元々の$x$すなわち第1引数を，2番目の$\mathLambdaAnonymousParameter$が元々の$y$すなわち第2引数を意味する．この省略記法はプログラミング言語Schemeにおけるcutプロシジャに由来する．\footnote{この記法はHaskellにはない．}

\section*{余計な話}

Scheme.

\chapter{関数}

\begin{leader}
プログラムはひとつの関数であり，その関数はいくつかの部分的な関数から合成される．
つまり，関数はプログラムの全体であり，またビルディングブロックである．
プログラムという関数をより小さな関数の合成で作るのは，それらの小さな関数が他のプログラムに再利用されることを期待するためである．
このように関数と関数の合成はプログラミングの中心的な概念である．
% プログラミング言語Cは，プログラムが関数だけからでも構成できることを示した．
% Pascalの「手続き」はCでは値を返さない関数であり，Pascalの「本文」はmainという名前の関数である．
\end{leader}


\section{関数の定義}

ラムダ式を用いた\keyword{関数}の定義が可能である．
例えば引数$x$をとり値$1+x$を返す関数$f$は$$f=\lambdaexp{x}{1+x}$$と定義できる．
この省略形として$$fx=1+x$$と書いても良いし，さらに省略して$$f=(+)1$$と書いても良い．
もちろん$f=+1$でないことに注意しよう．\footnote{Haskellでは$f=\lambdaexp{x}{1+x}$を\code{f=\textbackslash x->1+x}，$fx=1+x$を\code{f x = 1+x}，$f=(+)1$を\code{f=(+)1}のように書く．}

関数に\keyword{スペシャルバージョン}がある場合はそれらを列挙する．
例えば引数が$0$の場合は特別に戻り値も$0$であり，その他の場合は関数$f$と同じ振る舞いをする関数$f'$を考える．
このとき$f'$は
\begin{equation*}
\begin{split}
f'0&=0\\
f'x&=1+x
\end{split}
\end{equation*}
ように定義することになる．\footnote{Haskellでは
\begin{verbatim}
f' 0 = 0
f' x = 1+x
\end{verbatim}
と書く．}

関数定義に\keyword{場合分け}が必要な場合は「ガード」を用いる．
例えば引数の値が負の場合は$-1$を，$0$の場合は$0$を，それ以外の場合は関数$f$と同じ振る舞いをする関数$f''$は
\begin{equation*}
\begin{split}
f''x&\guard{x\binaryl0}=-1\\
&\guard{x\binaryeq0}=0\\
&\guard{\keywordotherwise}=1+x
\end{split}
\end{equation*}
という風に定義することにする．\footnote{Haskellでは
\begin{verbatim}
f'' x | x<0       = -1
      | x==0      = 0
      | otherwise = 1+x
\end{verbatim}
と書く．}

\section{関数の合成}

関数は\keyword{合成}できる．関数$f$と関数$g$があって，その合成を$f\binarycompose g$と書くとき$$(f\binarycompose g)x=f(gx)$$である．
関数合成の演算子$\binarycompose$は関数適用よりも優先順位が高く，$(f\binarycompose g)x$は単に$f\binarycompose g\,x$と書いても良い．
この記法は括弧の数を減らすためにしばしば用いられる．\footnote{Haskellでは関数\code{f}と関数\code{g}の合成は\code{f.g}である．}

関数合成演算子とは逆に，優先順位の低い関数適用演算子も考えておくと括弧の数を減らすのに便利である．
関数適用演算子$\binaryapply$を次のように定義しておく．
$$f\binaryapply gx=f(gx)$$
演算子$\binaryapply$の優先順位は足し算演算子よりも低いものとする．
よって$f(x+1)$は$f\binaryapply x+1$と書くこともできる．\footnote{Haskellでは$f\binaryapply gx$を\code{f \$ g x}と書く．}

\section{条件式}

\keyword{条件式}とは場合分けを関数定義の右辺に書けるようにしたもので，
$$fx=\keywordif x\binaryeq0\keywordthen0\keywordelse1+x$$
のように$\keywordif$節，$\keywordthen$節，及び$\keywordelse$節からなるものである．
$\keywordif$節の中身は真理値を返す関数であれば良いので，関数$p$を$$p=(\equiv)0$$としておき，$$fx=\keywordif px\keywordthen0\keywordelse 1+x$$と書く方法もしばしば用いられる．\footnote{Haskellでは$fx=\keywordif x\binaryeq0\keywordthen0\keywordelse1+x$を\code{f x = if x == 0 then 0 else 1+x}と書く．}

\chapter{型と型クラス}

\begin{leader}
プログラマのいう型とは，数学者のいう代数構造のことである．
\end{leader}


\section{型}

型とは変数が取りうる値に与えた制約のことである．
数学者がよく扱う型は論理型($\mathsetname{B}$)，整数型($\mathsetname{Z}$)，実数型($\mathsetname{R}$)といったところであろう．
ただし数学者たちは型ではなく集合と呼ぶ．
括弧内に示した記号は数学者たちが慣用的に用いているものである．

我々は計算機での実装を考慮して，数学者たちとは若干異なる型と表記方法を扱うことにする．
まず論理型($\mathsetname{B}$)はそのまま論理型として$\typebool$で表す．

計算機にとって都合の良い整数の範囲を考慮した整数型を$\typeint$で表す．
計算機にとって都合の良い整数の範囲とは，例えば64ビット計算機の場合$-2^{32}$から$2^{32}-1$までの範囲のことである．

計算機は残念ながら無限精度の実数を扱えない．
そこで標準精度の浮動小数点数を表す型を$\typefloat$で表す．

もう一つ，計算機ならではの型を導入しておこう．
それは$\typeint$とよく似ているが，特別に文字を扱うために考えられた型$\typechar$である．
文字といってもその中身は整数である．
整数ではあるが，わざわざ別な型とするのには理由がある．
歴史的には文字は小さな整数として表現されることが多かったため，また計算機のメモリが高価であったため，文字を扱うための専用の型はもっぱらメモリの節約のために存在した．
現在では，文字が数値にエンコードされる方式がより複雑になってきたために，文字を通常の数値と区別するために特別な型が用意さてれいるのである．


\section{関数の型}

関数にも型がある．
例えば整数引数を一つ取り，整数を返す関数$f$は$$f\istypeof\morph{\typeint}{\typeint}$$という型を持つ．

整数引数を二つ取り，整数を返す関数$f'$は$$f'\istypeof\mmorph{\typeint}{\typeint}{\typeint}$$という型を持つ．
これは$$f'\istypeof\mmorphwithparenthesis{\typeint}{\typeint}{\typeint}$$と同じ意味である．

\begin{table}
\caption{モノイド}
\label{tab:monoids}
\begin{center}
\begin{tabular}{||c||c|c||}
\hline
型クラス
    &\multicolumn{2}{|c||}{$\typeclassmonoid$}\\
\hline\hline
型$\setminus$要素と演算子
    &$\mathidentity$
    &$\mathbinaryop$\\
\hline
$\typechar$
    &---
    &---\\
\hline
$\typebool$
    &$\constantfalse$
    &$\binaryor$\\
\hline
$\typebool$
    &$\constanttrue$
    &$\binaryand$\\
\hline
$\typeint$
    &$0$
    &$\binaryadd$\\
\hline
$\typeint$
    &$1$
    &$\binarymultiply$\\
\hline
$\typefloat$
    &$0$
    &$\binaryadd$\\
\hline
$\typefloat$
    &$1$
    &$\binarymultiply$\\
\hline
\end{tabular}
\end{center}
\end{table}

\section{型クラス}

$\mathtriple{\typeint}{+}{0}$はモノイドである．
同様に $\mathtriple{\typeint}{*}{1}$, $\mathtriple{\typefloat}{+}{0}$, $\mathtriple{\typefloat}{*}{1}$, $\mathtriple{\typebool}{\binaryor}{\constantfalse}$, $\mathtriple{\typebool}{\binaryand}{\constanttrue}$ もモノイドである．
そこで，任意の型$\typename{a}$について，組み合わせ$\mathtriple{\typename{a}}{\mathbinaryop}{\mathidentity}$がモノイドである場合には$$\mathtriple{\typename{a}}{\mathbinaryop}{\mathidentity}\isclassof\typeclassmonoid$$と書くことにする．
二項演算子，単位元が自明な場合は簡略化して$$\typename{a}\isclassof\typeclassmonoid$$と書くことにする．

このような型をより抽象化した型のようなものを型クラスと呼ぶ．
モノイドは型クラスの例である．
表\ref{tab:monoids}に型と対応するモノイドの単位元，演算子の一覧を示す．

もっと身近な型クラスもある．
例えば，型$\typename{a}$の変数どうしの間で等値性が定義されている場合，その型は型クラス$\typeclasseq$に属することになる．
型クラス$\typeclasseq$に属する型は等値演算子$\binaryeq$を提供する．

型$\typename{a}$の変数どうしの間で大小関係が定義されている場合，かつその型が型クラス$\typeclasseq$に属する場合，その型は型クラス$\typeclassord$にも属する．
型クラス$\typeclassord$に属する型は比較演算子$\binaryl,\binaryle,\binaryge,\binaryg$を提供する．

型$\typename{a}$の変数どうしの間で四則演算関係が定義されている場合，かつその型が型クラス$\typeclasseq$に属する場合，その型は型クラス$\typeclassnum$にも属する．
型クラス$\typeclassnum$に属する型は比較演算子$\binaryadd,\binarysub,\binarymultiply,\binarydivide$を提供する．

型$\typename{a}$が型クラス$\typeclassord$及び型クラス$\typeclassnum$に属しているとき，かつそのときに限り，型$\typename{a}$は型クラス$\typeclassreal$にも属する．

型$\typename{a}$の変数について，一つ小さい値を返す関数$\functionpred$と一つ大きい値を返す関数$\functionsucc$が定義されているとき，かつそのときに限り，型$\typename{a}$は型クラス$\typeclassenum$に属する．

型$\typename{a}$が型クラス$\typeclassreal$及び型クラス$\typeclassenum$に属しているとき，かつそのときに限り，型$\typename{a}$は型クラス$\typeclassintegral$にも属する．

これらの関係を表にまとめたものが表\ref{tab:type-and-typeclass}である．

\begin{table*}[tbp]
\caption{型と型クラス}
\label{tab:type-and-typeclass}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c|c|c|c|c|c|c||}
\hline
\multirow{4}{*}{型クラス}
    &\multicolumn{12}{|c||}{$\typeclassintegral$}\\
\cline{2-13}
\multirow{3}{*}{}
    &\multicolumn{10}{|c|}{$\typeclassreal$}
    &\multicolumn{2}{|c||}{$\typeclassenum$}\\
\cline{2-11}
\multirow{2}{*}{}
    &\multicolumn{5}{|c|}{$\typeclassord$}
    &\multicolumn{5}{|c|}{$\typeclassnum$}
    &\multicolumn{2}{|c||}{ }\\
\cline{2-2}\cline{7-7}
{ }
    &$\typeclasseq$
    &\multicolumn{4}{|c|}{ }
    &$\typeclasseq$
    &\multicolumn{4}{|c|}{ }
    &\multicolumn{2}{|c||}{ }\\
\hline\hline
型$\setminus$演算子
    &$\binaryeq$
    &$\binaryl$
    &$\binaryle$
    &$\binaryge$
    &$\binaryg$
    &$\binaryeq$
    &$\binaryadd$
    &$\binarysub$
    &$\binarymultiply$
    &$\binarydivide$
    &$\functionpred$
    &$\functionsucc$\\
\hline
$\typechar$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---
    &---
    &---
    &$\checkmark$
    &$\checkmark$\\
\hline
$\typebool$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---
    &---
    &---
    &$\checkmark$
    &$\checkmark$\\
\hline
$\typeint$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$\\
\hline
$\typefloat$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---\\
\hline
\end{tabular}
\end{center}
\end{table*}

\chapter{コンテナ}

\begin{leader}
型から作る型をコンテナと呼ぶ．
代表的なコンテナはある型のホモジニアスな配列であるリストである．
この章ではリストと，リストに対する重要な演算である畳み込み，マップを取り扱う．
\end{leader}


\section{リスト}

同じ型の値を一列に並べたもの，つまりホモジニアスな配列のことを\keyword{リスト}と呼ぶ．
例えば$0$から始まり$9$まで続く整数のリストは$\listtype{0,1,2,3,4,5,6,7,8,9}$と書く．
等差数列に限って，簡略化した書き方が許される．
$0$から$9$までのリストは$\listtype{0,1\rangedots9}$と書いても良い．
複数の型の要素が混在してもよい配列のことをヘテロジニアスな配列と呼び，ホモジニアスな配列とは区別する．

より高度なリスト，例えば$0$から$9$までの平方数のリストは$$\listtype{x^2\guard{x\isin\listtype{0,1\rangedots9}}}$$のようにガードを用いて書く．
ここに右辺のリストから一つずつ要素を取り出して左辺に代入する演算子$\isin$を用いた．

ガードの中の式は複数あっても良い．
例えば$$\listtype{x+y\guard{x\isin\listtype{0,1\rangedots9}\guardcomma y\isin\listtype{0,1\rangedots5}\guardcomma x+y\binaryg3}}$$は$0\le x\le 10$かつ$0\le y\le 5$の範囲で$x+y>3$となる$x$及び$y$から$x+y$を並べたリストである．

リストは\keyword{結合}できる．例えばリスト$l$とリスト$m$を結合したリストは$$l\binarylistappend m$$で得られる．

リストは無限個の要素を持っても良い．
例えば自然数全体を表すリスト$n$は$$n=[1,2\infinitydots]$$のように定義して良い．

\keyword{空リスト}は$\constantempty$で表す．

任意の型を$\typename{a}$とするとき，$\typename{a}$型のリストを$\typeconstructor{\typelist}{\typename{a}}$と書く．
$\typelist$のように型名$\typename{a}$を修飾するものを\keyword{型コンストラクタ}と呼ぶ．

ある型を包み込んだ別の型を一般に\keyword{コンテナ型}または単に\keyword{コンテナ}と呼ぶ．

\section{畳み込み}

我々はよくリストの総和を表現するためにシグマ記号($\sum$)を使う．
リスト$\listtype{x_0,x_1\rangedots x_n}$の総和を$$\sum\listtype{x_0,x_1\rangedots x_n}=x_0+x_1+\dotsb+x_n$$とするようなシグマ記号である．
この表現を一般化してみよう．
リスト$\listtype{x_0,x_1\rangedots x_n}$が与えられたとき，$$\mathfold^\mathbinaryop_a\listtype{x_0,x_1\rangedots x_n}=a\mathbinaryop x_0\mathbinaryop x_1\mathbinaryop\dotsb\mathbinaryop x_n$$であると定義する．
この新しい記号$\mathfold$は\keyword{畳み込み演算子}と呼ばれる．
変数$a$はアキュムレータと呼ぶ．
アキュムレータは右側の引数が空であった場合のデフォルト値と考えても良い．

リストの総和をとる演算子$\sum$は$$\sum=\mathfold^+_0$$とすれば得られる．
同じようにリストの要素のすべての積をとる演算子$\prod$は$$\prod=\mathfold^\binarymultiply_1$$とすれば得られる．

畳み込み演算子は第1（上）引数に$\typename{a}$型と$\typename{b}$型の引数を取り$\typename{a}$型の戻り値を返す二項演算子，第2（下）引数に$\typename{a}$型，第3（右）引数に$\typename{b}$型のリストすなわち$\listtype{\typename{b}}$型を取り，$\typename{a}$型の値を返す．
従って畳み込み演算子の型は$$\mathfold\istypeof\mmmorph{(\mmorph{\typename{a}}{\typename{b}}{\typename{a}})}{\typename{a}}{\listtype{\typename{b}}}{\typename{a}}$$と定義できる．

畳み込み演算子には次のようなもう一つのバリエーションがある．
$$\mathfoldright^\mathbinaryop_a\listtype{x_0,x_1\rangedots x_n}=\left(x_0\mathbinaryop\left(x_1\mathbinaryop\dotsb\mathbinaryop\left(x_n\mathbinaryop a\right)\right)\right)$$
これは右畳み込みと呼ばれる演算子である．

% concat

畳み込み演算子の面白い応用例を示そう．
$$\mathfold_\constantempty^\binarylistappend\listtype{\listtype{0,1,2},\listtype{3,4,5},\infinitydots}=\listtype{0,1,2,3,4,5,\infinitydots}$$
であるから，演算子$$\mathfold_\constantempty^\binarylistappend$$はリストを平坦化する\keyword{平坦化演算子}である．
平坦化演算子はconcat演算子とも呼ばれることもあるが，基本的な演算子であるため特別な記号をつけておこう．
我々は$$\dagger=\mathfold_\constantempty^\binarylistappend$$と定義することにする．

\section{マップ}

リストの各要素に決まった関数を適用したい場合がある．
引数として関数$f$とリスト$\listtype{x_0,x_1\rangedots x_n}$を取り，戻り値として$\listtype{fx_0,fx_1\rangedots fx_n}$を返す演算子$\binarylistfunctormap$を考えよう．
このとき$$f\binarylistfunctormap\listtype{x_0,x_1\rangedots x_n}=\listtype{fx_0,fx_1\rangedots fx_n}$$であると定義する．
% リストのマップ演算子と呼ぶ$\mapfunc_\text{list}$は$$\mapfunc\nolimits_\text{list}::(\typename{a}\rightarrow\typename{b})\rightarrow\listtype{\typename{a}}\rightarrow\listtype{\typename{b}}$$という型を持つ．



\chapter{コンテナの高度な話題}

\begin{leader}
a
\end{leader}


\section{Maybe}

整数$x$を$0$で除算することはエラーである．
しかし除算の度にエラーが起こったかどうか調べるのは面倒であるし，記述も煩雑になってしまう．
プログラマはよくこういう場合に「例外」という機構を用いるが，数学に例外は持ち込みたくない．
そこで変数$x$が正しく計算されたかもしれないし，されていないかもしれないということを，特別な記号$\maybetype{x}$で表しておこう．
ここで変数$\maybetype{x}$が取り得る値は正しく計算された値$x$か，あるいはエラーを表す値$\constantnothing$である．

この変数$\maybetype{x}$はもはや整数型とは言えない．
そこでこの$\maybetype{x}$の型を$\typeconstructor{\typemaybe}{\typeint}$と表して「きっと整数」型と呼ぶことにしよう．
ここに$\typemaybe$は型コンストラクタのひとつである．

変数$x$が一度$0$除算の危険性に汚染された場合，その後ずっと$\maybetype{x}$と印をつけられなければならない．
このきっと整数$\maybetype{x}$に対して整数を引数にとる関数$f$を適用させるには，何らかの関数マップ演算子が必要である．
そこできっと整数の中身に直接関数を適用する演算子を$\binarymaybefunctormap$としよう．
具体的には$$f\binarymaybefunctormap\maybetype{x}=\maybetype{fx}$$のように関数$f$を変数$\maybetype{x}$に適用させる．
その結果はまた$\typeconstructor{\typemaybe}{\typeint}$型である．
従って，結果を受け取る変数も$\typeconstructor{\typemaybe}{\typeint}$型でなければならず，それを忘れないように印を付けておかねばならない．
例えば$$\maybetype{y}=f\binarymaybefunctormap\maybetype{x}$$のように書くことになるであろう．

$$(\typeconstructor{\typemaybe}{\typename{a}},\binarymaybeappend,\constantnothing)$$
% \boxplus == \boxdot???

\section{モノイドとしてのコンテナ}

$$(\typeconstructor{\typelist}{\typename{a}},\binarylistappend,\constantempty)$$

% \section{コンテナの型クラスと種}

\section{リストの実装}

ここでリストの実装について若干述べておかねばならない．
紙上ではリストは自由に考えられるが，計算機上ではそれほど自由ではないからである．
ここではリストはLISPにおけるリストと同じ構造を持つものとする．
LISPにおけるリストとは要素$\specialwordfirst$と要素$\specialwordrest$からなるペアの集合である．
要素$\specialwordfirst$がリストの要素を持ち，要素$\specialwordrest$が次のペアを参照する．
リストの最後のペアの$\specialwordrest$は空リストを参照する．

% これらのペアはタプルで実装したいところだが，参照，逆参照の煩雑さを避けるために，
リストのための特別な表現$$\specialwordfirst\binaryconcat\specialwordrest$$を用い，第1要素$\specialwordfirst$はリストが保持する型，第2要素$\specialwordrest$はリスト型であるとする．
演算子$\binaryconcat$を\keyword{結合演算子}と呼ぶ．

要素$\specialwordrest$はリストまたは空リストであるから，一般にリストは次のように展開できることになる．
\begin{align*}
\listtype{x_0,x_1,x_2\rangedots x_n}&=x_0\binaryconcat\listtype{x_1,x_2\rangedots x_n}\\
&=x_0\binaryconcat x_1\binaryconcat\listtype{x_2\rangedots x_n}\\
&=x_0\binaryconcat x_1\binaryconcat x_2\binaryconcat\dotsb\binaryconcat x_n\binaryconcat\constantempty
\end{align*}
結合演算子$\binaryconcat$は右結合する．
すなわち$$x_0\binaryconcat x_1\binaryconcat x_2=x_0\binaryconcat(x_1\binaryconcat x_2)$$である．


\chapter{関手}

\section{関手}

$$F\istypeof\mathsetname{X}\mapsto\mathsetname{X}$$

\begin{align}
\mathidentitymorph\binaryfunctormap&=\mathidentitymorph\\
(f\binarycompose g)\binaryfunctormap&=(f\binaryfunctormap)\binarycompose(g\binaryfunctormap)
\end{align}


---

ある集合$\mathsetname{S}$と，その集合の元に対して定義される変換$f$全体の集合$\mathsetname{F}_{\mathsetname{S}}$との組み合わせ$(\mathsetname{S},\mathsetname{F}_{\mathsetname{S}})$を\keyword{圏}と呼ぶ．
例えばリストは$(\typeconstructor{\typelist}{\typename{a}},\binarylistfunctormap)$という圏であるし，Maybeは$(\typeconstructor{\typemaybe}{\typename{a}},\binarymaybefunctormap)$という圏である．

これらの圏はもともと$(\typename{a},\mathbinaryop)$という圏から変換して得られたものと考えることもできる．
つまり，
\begin{align*}
\typelist&=(\typename{a},\mathbinaryop)\mapsto(\typeconstructor{\typelist}{\typename{a}},\binarylistfunctormap)\\
\typemaybe&=(\typename{a},\mathbinaryop)\mapsto(\typeconstructor{\typemaybe}{\typename{a}},\binarymaybefunctormap)
\end{align*}
であると考えることができる．
このような圏から圏への変換を\keyword{関手}と呼ぶ．

一般に$$\mathfunctorname{F}=(\mathsetname{a},\mathbinaryop)\mapsto(\typeconstructor{\mathfunctorname{F}}{\typename{a}},\binaryfunctormap)$$


---

モノイド$(\mathsetname{M}_1,\mathbinaryop_1,\mathidentity_1)$と$(\mathsetname{M}_2,\mathbinaryop_2,\mathidentity_2)$があるとき，前者から後者への変換$\mathfunctorname{F}$を$$\mathfunctorname{F}=(\mathsetname{M}_1,\mathbinaryop_1,\mathidentity_1)\mapsto (\mathsetname{M}_2,\mathbinaryop_2,\mathidentity_2)$$と書き，変換$\mathfunctorname{F}$を\keyword{関手}と言う．

例えば$\typename{a}$型から$\typeconstructor{\typelist}{\typename{a}}$型を作る型コンストラクタ$\typelist$は関手である．
この場合は$$\typelist=(\typename{a},+,0)\mapsto(\typeconstructor{\typelist}{\typename{a}},\binarylistfunctormap,\constantempty)$$という関係になる．

また$\typename{a}$型から$\typeconstructor{\typemaybe}{\typename{a}}$型を作る型コンストラクタ$\typemaybe$も関手である．
この場合は$$\typemaybe=(\typename{a},+,0)\mapsto(\typeconstructor{\typemaybe}{\typename{a}},\binarymaybeappend,\constantnothing)$$という関係になる．


モノイドからモノイドへの変換，モノイド内での二項演算子なども含めて，変換するものを全て\keyword{射}と呼ぶ．
関手は射のひとつである．



\section{アプリカティブ関手}



$$(X,\langle\,\rangle,\binaryfunctormap,\times)$$


\section{関数と関手の関係}

\chapter{モナド}

\section{アプリカティブ関手の拡張}

$$(X,\langle\,\rangle,\binaryfunctormap,\times,\heartsuit)$$


\section{モナド則}

\section{モノイドなモナド}


\begin{table*}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c||}
\hline
\multirow{4}{*}{型クラス}
    &\multicolumn{6}{|c||}{$\typeclassmonadplus$}\\
\cline{2-7}
\multirow{3}{*}{}
    &\multicolumn{4}{|c|}{$\typeclassmonad$}
    &\multicolumn{2}{|c||}{$\typeclassmonoid$}\\
\cline{2-4}
\multirow{2}{*}{}
    &\multicolumn{3}{|c|}{$\typeclassapplicative$}
    &
    &\multicolumn{2}{|c||}{ }\\
\cline{2-2}
{ }
    &\multicolumn{1}{|c|}{$\typeclassfunctor$}
    &\multicolumn{2}{|c|}{ }
    &
    &\multicolumn{2}{|c||}{ }\\
\hline\hline
型$\setminus$要素と演算子
    &$\binaryfunctormap$
    &$\applicativetype{x}$
    &$\binaryapplicativemap$
    &$\binarymonadmap$
    &$\mathidentity$
    &$\mathbinaryop$\\
\hline
リスト
    &$\binarylistfunctormap$
    &$\listtype{x}$
    &$\binarylistapplicativemap$
    &$\binarylistmonadmap$
    &$\constantempty$
    &$\binarylistappend$\\
\hline
Maybe
    &$\binarymaybefunctormap$
    &$\maybetype{x}$
    &$\binarymaybeapplicativemap$
    &$\binarymaybemonadmap$
    &$\constantnothing$
    &$\binarymaybeappend$\\
\hline
関数
    &$\binaryfunctionfunctormap$
    &$\functyontype{x}$
    &$\binaryfunctionapplicativemap$
    &$\binaryfunctionmonadmap$
    &$\anonymousparameter$
    &$\binarycompose$\\
\hline
Int（参考）
    &
    &
    &
    &
    &$0$
    &$\binaryadd$\\
\hline
\end{tabular}
\end{center}
\end{table*}

\part{モナドから見る世界}

\chapter{IO}

\chapter{例外}

\chapter{乱数}

\chapter{状態}

\chapter{非決定性}

\chapter{継続}

\chapter{X}

\chapter{Y}

\chapter{Z}


\part{圏とモナド}


\chapter{---}



% ----------

% Literals
\newcommand{\charlit}[1]{\texttt{#1}}

% Operators and symbols
\newcommand{\applicativefunc}{\bigotimes} % <*>
\newcommand{\bind}{\rightrightarrows} % >>=
\newcommand{\comp}{\bullet} % .
\newcommand{\concretetype}{\mathbf\ast} % *
\newcommand{\defeq}{\xleftarrow{\text{def}}}
\newcommand{\dollar}{\mathop{\$}} % $
\newcommand{\filterfunc}{\bigcap} % filter
\newcommand{\foldfunc}{\bigcup} % foldl
\newcommand{\foldrightfunc}{\bigsqcup} % foldr
\newcommand{\guard}[1]{\mathop{\mid_{{#1}}}}
\newcommand{\haskelllambda}{\backslash}
\newcommand{\lambdaperiod}{\;.\;}
\newcommand{\listappend}{\mathop{++}}
\newcommand{\mapfunc}{\bigodot} % fmap
\newcommand{\monadfunc}{\bigoplus}
\newcommand{\monadjoin}{\dag}
\newcommand{\nullelem}{\emptyset}
\newcommand{\pure}{\bigstar} % pure
\newcommand{\typealpha}{\boldsymbol{\alpha}}
\newcommand{\unit}{\star} % return

% Functions
\newcommand{\concat}{\mathop{\text{concat}}}

% Booleans
\newcommand{\booleankeyword}[1]{\text{#1}}
\newcommand{\falsevalue}{\text{F}}
\newcommand{\truevalue}{\text{T}}

% Typenames
\newcommand{\typename}[1]{\bm{#1}}
\newcommand{\booleantype}{\typename{B}}
\newcommand{\integertype}{\typename{Z}}
\newcommand{\realtype}{\typename{R}}

% Typeclass names
\newcommand{\typeclassname}[1]{\mathbb{#1}}
\newcommand{\enumtypeclass}{\typeclassname{E}}
\newcommand{\eqtypeclass}{\typeclassname{Q}}
\newcommand{\functortypeclass}{\typeclassname{F}}
\newcommand{\inttypeclass}{\typeclassname{I}}
\newcommand{\numtypeclass}{\typeclassname{N}}
\newcommand{\ordtypeclass}{\typeclassname{O}}

% Fanctor typeclasses
\newcommand{\fanctortypeclassname}[1]{\mathcal{#1}}

% Functors
\newcommand{\function}[1]{\left\langle#1\right\rangle}
\newcommand{\generalcontainer}[1]{\left\langle\!\left\langle#1\right\rangle\!\right\rangle}
\newcommand{\listtype}[1]{\left[#1\right]}
\newcommand{\maybe}[1]{\left\{#1\right\}}
\newcommand{\monad}[1]{\left[\!\left[#1\right]\!\right]}

% Functor names
\newcommand{\functor}[1]{\mathop{\textbf{#1}}}
\newcommand{\functionfunctor}{\mathop{\functor{Function}}}
\newcommand{\listfunctor}{\mathop{\functor{List}}}
\newcommand{\maybefunctor}{\mathop{\functor{Maybe}}}
\newcommand{\monadfunctor}{\mathop{\functor{Monad}}}

% Keywords
\newcommand{\haskellkeyword}[1]{\textbf{#1}}
\newcommand{\letinprogram}{\haskellkeyword{let}}
\newcommand{\otherwise}{\haskellkeyword{otherwise}}
\newcommand{\where}{\haskellkeyword{where}}

% Math keywords
\newcommand{\mathkeyword}[1]{\textbf{#1}}
\newcommand{\mathelse}{\mathop{\mathkeyword{else}}}
\newcommand{\mathif}{\mathop{\mathkeyword{if}}}
\newcommand{\maththen}{\mathop{\mathkeyword{then}}}

% Special keywords
\newcommand{\specialkeyword}[1]{\textsf{#1}}
\newcommand{\firstelem}{\specialkeyword{First}}
\newcommand{\mathidentity}{\specialkeyword{id}}
\newcommand{\nothing}{\specialkeyword{Nothing}}
\newcommand{\restelems}{\specialkeyword{Rest}}

\chapter{思考の道具*}

「言語は思考を規定する」という．
実際プログラマは思考の道具としてプログラミング言語をよく用いるし，そのプログラマの好みのプログラミング言語の影響を強く受ける．
手続き的に問題を解くのが好きなプログラマもいれば，宣言的に問題を解くのが好きなプログラマもいる．
問題の複雑さを「オブジェクト」というプログラム単位に押し込むのが好きなプログラマもいれば，「クロージャ」という別のプログラム単位に押し込むのが好きなプログラマもいる．

一方で，古代ギリシャから連綿と続く数学者たちは，数学という言葉で問題を考えることを好む．
数学はわずかな方言の違いを無視すれば驚くほど統一された言語である．

プログラマが使う言葉すなわちプログラミング言語と，数学者たちが使う語はだいたい乖離しており，その両者の歩み寄りは虚しいものであることが多かった．
ここで言いたいのはプログラマが限られた文字セットしか使えないとか，スクリーン上の行という制約に縛られているとか，そのような表面的なことではない．
そうではなく，思考の様式が，プログラミング「文化」と数学「文化」で異なるという意味である．

プログラミング文化と数学文化の大きな違いの一つは，リアルタイムに起こるイベントの取り扱い方法である．
プログラマはほとんどいつもリアルタイムに起こるイベントに対応しないといけない．
一方で，数学者たちはそのようなイベントを「不純なもの」として理論から取り除く．
例えば変数$x$があるときは$0$だがあるときは$1$であるというのは，甚だ不純なものとして数学者の間では認識されるものだ．

\chapter{数学的準備*}

この章ではいま後本書で登場する数学的概念の記法を決めておく．

\section{定数・論理定数・文字定数}

定数はアラビア数字で記述するものとする．
定数が負の場合はマイナス記号($-$)を用いる．
定数が実数の場合は小数点($.$)を用いる場合がある．
例えば $-1, 0, 1.2$ は定数である．

論理定数とは真偽値を表す定数で，真($\truevalue$)及び偽($\falsevalue$)の2種類のみがある．

文字定数とはコード化された文字のことである．
文字コードを定数として扱うといささか読みづらくなるため，該当する文字をシングルクォートで囲むことにする．
例えば `\charlit{A}', `\charlit{b}', `\charlit{.}' は文字定数である．

\section{変数}

変数はアルファベット（ローマ文字またはギリシア文字）の小文字1文字で表すことにする．
変数名には任意個のプライム記号($'$)をつけても良いし，添え字をつけても良いこととする．
変数名はイタリック体で書く．

変数は代入演算子($=$)によって定数や変数，それらを複合した式の値を代入できる．
例えば $$x=1, y=x$$ は代入の例である．

\section{演算子}

演算子には数学記号を割り当てる．


\section{関数}

関数も変数と同じようにアルファベット（ローマ文字またはギリシア文字）の小文字1文字で表すことにする．
関数名には任意個のプライム記号($'$)をつけても良いし，添え字をつけても良いこととする．
三角関数のように十分な知名度を持つ関数や，それに匹敵する汎用的な関数は長い名前を持っても良い．
変数名や関数名はイタリック体で書くが，長い関数名はローマン体で書く．


二項演算子とは2引数関数の特別な場合であると考えてよい．
関数$r$を次のように中置する記法を定義しておく．
$$x\,{}^\backprime r^\backprime\,y\defeq rxy$$
バックプライム記号(${}^\backprime$)を使っているのはプライム記号($'$)と区別するためである．

既存の二項演算子$\circ$は次のようにして通常の関数として使えるものとする．
$$(\circ)xy\defeq x\circ y$$

\section{ラムダ式}

\section{関数定義}

\section{条件式}

\section{型}

\section{リスト}


\section{タプル}

複数の変数を束ねたものをタプルと呼ぶ．
変数$x$と変数$y$からなるタプルは$(x,y)$と書く．
いま$$t=(x,y)$$としたとき，タプルの中身を取り出すには$$(t_1,t_2)=t$$のようにしてパタンマッチングを用いる．

\section{リストの実装}


\chapter{型・型クラス・種*}

\section{関数の型}

$$f::\integertype\rightarrow\integertype$$

関数$f$が引数として整数を2個取り1個の整数を返すとき，その型は$$\integertype\rightarrow\integertype\rightarrow\integertype$$である．
型の式は右結合するものとする．
従って上式は$$\integertype\rightarrow\left(\integertype\rightarrow\integertype\right)$$と読む．
これは関数$f$が最初の引数を1個受け取り，$(\integertype\rightarrow\integertype)$型の関数を返していることを考えると理にかなっている表現である．

\section{型クラス}

$$\integertype\subset\eqtypeclass$$

$$\integertype\subset\ordtypeclass$$

$$\integertype\subset\enumtypeclass$$


\section{種}

$$\integertype::\concretetype$$

$$\maybe{\integertype}::\concretetype$$

$$\maybe{{}}::\concretetype\mapsto\concretetype$$

\chapter{マップ*}

Map.
$$f\odot[x_0,x_1\dotsb x_n]=[fx_0,fx_1\dotsb fx_n]$$
$$f\odot\{x\}=\{fx\}$$

Applicative map (fmap).
\begin{multline*}
[f_0,f_1\dotsb f_n]\otimes[x_0,x_1\dotsb x_{n'}]\\
=[f_0x_0,f_0x_1\dotsb f_0x_{n'},f_1x_0,f_1x_1\dotsb]
\end{multline*}
$$\{f\}\otimes\{x\}=\{fx\}$$
$$f\otimes g=f\comp g$$

Monadic map (bind).
$$f\oplus\monad{x}=\monad{fx}$$


\section{畳み込み}


\section{右畳み込み}


\section{フィルタ}

$$\filterfunc^p\listtype{x_0,x_1\dotsb x_n}\defeq\listtype{x\guard{x\in\listtype{x_0,x_1\dotsb x_n}\wedge px\equiv\truevalue}}$$

\section{マップ}



\section{一般化マップ}

マップ演算子の概念を一般化してみよう．
一般のマップ演算子はあるコンテナの中身に関数適用を行い，元のコンテナと同じコンテナを返す演算子であると考えることができる．
そこで，いま後マップ演算子の第2（右）引数は一般のコンテナであるとする．
型$\typename{a}$をコンテナに入れた型を一般に$\generalcontainer{\typename{a}}$と書くことにすると，一般化されたマップ演算子$\mapfunc$は$$\mapfunc::(\typename{a}\rightarrow\typename{b})\rightarrow\generalcontainer{\typename{a}}\rightarrow\generalcontainer{\typename{b}}$$という型を持つ．

マップはリストのマップのより汎用的なバージョンである．
つまり我々は$\mapfunc_\text{list}$を使わずに，最初から$\mapfunc$を使えば良いのである．

一般化マップの型は$\typename{a}\rightarrow\typename{b}$をとり$\generalcontainer{\typename{a}}\rightarrow\generalcontainer{\typename{b}}$を返しているようにも見える．
それゆえ一般化マップを用いることを関数の「持ち上げ(lifting)」と呼ぶのである．

\section{Maybe}



\section{関手}

ある型から，マップの第2（右）引数になれる型を作る射（一般化された写像）のことを関手と呼ぶ．
例えば型$\typename{a}$からリスト型$[\typename{a}]$を作る射$\listfunctor$ただし$$\listfunctor\typename{a}\defeq\typename{a}\mapsto\listtype{\typename{a}}$$は関手である．
また型$\typename{a}$から ``maybe a'' 型$\maybe{\typename{a}}$を作る射$\maybefunctor$ただし$$\maybefunctor\typename{a}\defeq\typename{a}\mapsto\maybe{\typename{a}}$$も関手である．

関数合成もまた関手の例である．
いま型$\typename{a}$を型$\function{\typename{a}}$に変換する関手$$\functionfunctor\typename{a}\defeq\typename{a}\mapsto\function{\typename{a}}$$を考える．
型$\function{\typename{a}}$は$$\function{\typename{a}}\defeq\typename{t}\rightarrow\typename{a}$$であるとする．
ここに型$\typename{t}$は任意の型である．
関数$f$が$$f::\typename{a}\rightarrow\typename{b}$$であり，関数$g$が$$g::\typename{t}\rightarrow\typename{a}$$であるとき，その合成$f\comp g$は$$f\comp g::\typename{t}\rightarrow\typename{b}$$でなければならない．
ここで型$\function{\typename{a}}$の定義式を用いると
\begin{align*}
\function{\typename{a}}&\defeq\typename{t}\rightarrow\typename{a}\\
\function{\typename{b}}&\defeq\typename{t}\rightarrow\typename{b}
\end{align*}
であるから，関数$g$並びに合成関数$f\comp g$は
\begin{align*}
g&::\function{\typename{a}}\\
f\comp g&::\function{\typename{b}}
\end{align*}
という型を持つことがわかる．
今一度マップ演算子の型$$\mapfunc::(\typename{a}\rightarrow\typename{b})\rightarrow\generalcontainer{\typename{a}}\rightarrow\generalcontainer{\typename{b}}$$を思い出してみよう．
これは関数合成にもそのまま使えることがわかる．
実際$$f\comp g\defeq\mapfunc^fg$$として関数合成は定義できる．

一般に$$\typename{a}\mapsto\generalcontainer{\typename{a}}$$という風に型$\typename{a}$をコンテナに入れて型$\generalcontainer{\typename{a}}$を作る射を関手と呼ぶ．

関手全体の型クラスを$\functortypeclass$で表す．
これまでに見た関手は$$\functionfunctor,\listfunctor,\maybefunctor::\functortypeclass$$である．


\section{関手が従う規則}

\begin{align}
\mapfunc^\mathidentity&=\mathidentity\\
\mapfunc^{\functor{f}\comp\functor{g}}&\equiv\mapfunc^{\functor{f}}\comp\mapfunc^{\functor{g}}
\end{align}

\section{アプリカティブ関手}

一般化マップとは$$\mapfunc::(\typename{a}\rightarrow\typename{b})\rightarrow\generalcontainer{\typename{a}}\rightarrow\generalcontainer{\typename{b}}$$のことであった．
一般化マップの第1引数である1引数関数がコンテナに入っている場合を想定しよう．
そうすると次のような「一般化された」マップ$\applicativefunc$を考えることができる．
$$\applicativefunc::\generalcontainer{(\typename{a}\rightarrow\typename{b})}\rightarrow\generalcontainer{\typename{a}}\rightarrow\generalcontainer{\typename{b}}$$
実際の使い方は$$\listtype{y_0,y_1\dotsb y_{n''}}=\applicativefunc^{\listtype{f_0,f_1\dotsb f_n}}\listtype{x_0,x_1\dotsb x_{n'}}$$のようになるであろう．

一般化マップ演算子$\applicativefunc$と次のピュア演算子$\pure$があれば，リストもMaybeも同じ枠組みで考えることができる．
ピュア演算子$\pure$は$$\pure::\typename{a}\rightarrow\generalcontainer{\typename{a}}$$という型を持つ．
関手の型$\typename{a}\mapsto\generalcontainer{\typename{a}}$とは矢印が違う事に注意しよう．
ピュア演算子は型を型へ変換するのではなく，変数をコンテナに入れられた別な変数へと変換する．

型$\generalcontainer{\typename{a}}$の変数をアプリカティブと呼ぶ．

リストの場合，ピュア演算子と一般化マップは次のように実装することができる．
\begin{align*}
\pure x&=\listtype{x}\\
\applicativefunc^{\listtype{f_0,f_1\dotsb f_n}}\listtype{x_0,x_1\dotsb x_{n'}}&=\listtype{fx\guard{f\in\listtype{f_0,f_1\dotsb f_n},x\in\listtype{x_0,x_1\dotsb x_{n'}}}}
\end{align*}

Maybeの場合は次のようにピュア演算子と一般化マップを実装することができる．
\begin{align*}
\pure x&=\maybe{x}\\
\applicativefunc^{\nothing}\maybe{x}&=\nothing\\
\applicativefunc^{\maybe{f}}\maybe{x}&=\mapfunc^f\maybe{x}
\end{align*}

% IO: skip.

% Function:
% \begin{align*}
% \pure x&=\haskelllambda y\rightarrow x\\
% \applicativefunc^fg&=\haskelllambda x\rightarrow fx(gx)
% \end{align*}

アプリカティブが従う規則

$$\applicativefunc^{\pure f}x\equiv\mapfunc^fx$$

\section{モナド}

ある型$\typename{a}$について，特殊なコンテナ$\monad{\typename{a}}$に入れられた型を想像してほしい．
この型にもマップ演算子$\monadfunc$があり$$\monadfunc::\left(\typename{a}\rightarrow\monad{\typename{b}}\right)\rightarrow\monad{\typename{a}}\rightarrow{\monad{\typename{b}}}$$という型を持っているとする．
このマップ演算子は第1（上）引数として型$\typename{a}$をとりコンテナに収めた型$\monad{\typename{b}}$を返す関数を，第2（右）引数としてコンテナに収められた型$\monad{\typename{a}}$をとり，戻り値としてコンテナに収められた型$\monad{\typename{b}}$を返す．

型$\typename{a}$から型$\monad{\typename{a}}$を作り出す関手を$\monadfunctor$とし$$\monadfunctor\typename{a}=\typename{a}\mapsto\monad{\typename{a}}$$とする．
$\typename{a}$型の変数から$\monad{\typename{a}}$型の変数を作る演算子を$\unit$とし，ユニット演算子と呼ぶ．

$\monad{\typename{a}}$型の変数をモナドと呼ぶ．
モナドはアプリカティブとよく似ているが，少し異なることに注意しよう．
モナドの応用範囲は極めて広く，それゆえ基本的な関手と考えられている．

Maybeの方がリストよりも簡単なので，Maybeから説明する．
Maybeの場合は次のような実装となる．
\begin{align*}
\unit x&=\maybe{x}\\
\monadfunc^f\nothing&=\nothing\\
\monadfunc^f\maybe{x}&=fx
\end{align*}
ここに関数$f$は$$f::\typename{a}\rightarrow\monad{\typename{b}}$$であるから，関数適用された値$fx$は$$fx::\monad{\typename{b}}$$という型を持つことに注意しよう．

% ---
% 
% $$\bind\,::\monad{\typename{a}}\rightarrow(\typename{a}\rightarrow\monad{\typename{b}})\rightarrow\monad{\typename{b}}$$
% 
% Maybe:
% \begin{align*}
% \unit x&=\maybe{x}\\
% \nothing\bind f&=\nothing\\
% \maybe{x}\bind f&=fx
% \end{align*}
% 
% ---

リストの場合は次のような実装となる．
\begin{align*}
\unit x&=\listtype{x}\\
\monadfunc^f\listtype{x_0,x_1\dotsb x_n}&=\concat\mapfunc^f\listtype{x_0,x_1\dotsb x_n}
\end{align*}
関数$\concat$はリストのリスト$$\listtype{\listtype{x_0,x_1\dotsb x_n},\listtype{y_0,y_1\dotsb y_n}\dotsb}$$をフラットなリスト$$\listtype{x_0,x_1\dotsb x_n,y_0,y_1\dotsb y_n\dotsb}$$へと変換する．

% List:
% \begin{align*}
% \unit x&=\listtype{x}\\
% \listtype{x_0,x_1\dotsb x_n}\bind f&=\concat\mapfunc^f\listtype{x_0,x_1\dotsb x_n}
% \end{align*}

% Function:
% \begin{align*}
% \unit x&=\haskelllambda y\rightarrow x\\
% g\bind f&=\haskelllambda h\rightarrow f(gh)h
% \end{align*}


\section{モナド則}

新しい演算子$\triangleleft$を$$(f\triangleleft g)x\defeq\monadfunc^f(gx)$$として導入する．
モナドは次の規則に従う．
\begin{align}
f\triangleleft\unit&=f\\
\unit\triangleleft f&=f\\
(f\triangleleft g)\triangleleft h&=f\triangleleft(g\triangleleft h)
\end{align}

\section{結合演算子}

「結合演算子($\bind$)」を$$x\bind f\defeq \monadfunc^fx$$のように定義する．

---

$$(f\triangleright g)x\defeq(fx)\bind g$$
\begin{align}
\unit\triangleright f&=f\\
f\triangleright\unit&=f\\
(f\triangleright g)\triangleright h&=f\triangleright(g\triangleright h)
\end{align}

\begin{align}
\unit x\bind f&=fx\\
\monad{x}\bind\unit&=\monad{x}\\
(\monad{x}\bind f)\bind g&=\monad{x}\bind(\haskelllambda x'\rightarrow(fx'\bind g))
\end{align}

Or,
\begin{align}
\monadfunc^f(\unit x)&=fx\\
\monadfunc^\unit\monad{x}&=\monad{x}\\
\monadfunc^g\left(\monadfunc^f\monad{x}\right)&=\monadfunc^{\haskelllamda x'\rightarrow\left(\monadfunc^gfx'\right)}\monad{x}
\end{align}

Memo.
\begin{align*}
\monadjoin\monad{\monad{x}}&\defeq\monad{x}\\
\mapfunc^f\monad{x}&=\monad{x}\bind(\unit\comp f)\\
\monadjoin\monad{x}&=\monad{x}\bind\mathidentity\\
\monad{x}\bind f&\defeq\monadjoin\mapfunc^f\monad{x}\\
\unit\comp f&\defeq\mapfunc^f\comp\unit\\
\monadjoin\comp\mapfunc^\monadjoin&\defeq\monadjoin\comp\monadjoin\\
\monadjoin\comp\mapfunc^\unit&\defeq\monadjoin\comp\unit=\mathidentity\\
\monadjoin\comp\mapfunc^{\mapfunc^f}&\defeq\mapfunc^f\comp\monadjoin
\end{align*}

\chapter{プログラミング*}

letとwhere.

乱数．


\end{document}
