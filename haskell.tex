\documentclass[twocolumn]{jsbook}
\usepackage{amsmath,amssymb,ascmac,bm,multirow,fancyvrb}

\title{プログラマのための代数構造}
\author{Ichi Kanaya}
\date{2016}

\def\[{[\![}
\def\]{]\!]}

\def\MARU#1{\leavevmode \setbox0\hbox{$\bigcirc$}\copy0\kern-\wd0 \hbox to\wd0{\hfil{#1}\hfil}}

\newenvironment{footnotecode}{\begin{Verbatim}[xleftmargin=10mm]}{\end{Verbatim}}

\newcommand{\hsklType}[1]{\textbf{#1}}
\newcommand{\hsklTypeclass}[1]{\mathsf{#1}}
\newcommand{\hsklTypeConstructor}[1]{\mathop{\mathrm{#1}}}

\DeclareMathOperator{\hsklApplicativeMap}{\times}
\DeclareMathOperator{\hsklApplicativeListMap}{\otimes}
\DeclareMathOperator{\hsklConcat}{\flat}
\DeclareMathOperator{\hsklFmap}{\cdot}
\DeclareMathOperator{\hsklListConstructor}{\hsklTypeConstructor{List}}
\DeclareMathOperator{\hsklMap}{\odot}
\DeclareMathOperator{\hsklMaybeConstructor}{\hsklTypeConstructor{Maybe}}
\DeclareMathOperator{\hsklMaybeAppend}{\boxplus}
\DeclareMathOperator{\hsklMaybeMap}{\boxdot}
\DeclareMathOperator{\hsklOf}{::}
\DeclareMathOperator{\hsklPred}{pred}
\DeclareMathOperator{\hsklSucc}{succ}
\newcommand{\hsklAppend}{\oplus}
\newcommand{\hsklApplicative}{\hsklTypeclass{Applicative}}
\newcommand{\hsklBool}{\hsklType{Bool}}
\newcommand{\hsklChar}{\hsklType{Char}}
\newcommand{\hsklEmptyList}{\emptyset}
\newcommand{\hsklEnum}{\hsklTypeclass{Enum}}
\newcommand{\hsklInt}{\hsklType{Int}}
\newcommand{\hsklIntegral}{\hsklTypeclass{Integral}}
\newcommand{\hsklEq}{\hsklTypeclass{Eq}}
\newcommand{\hsklFloat}{\hsklType{Float}}
\newcommand{\hsklFunctor}{\hsklTypeclass{Functor}}
\newcommand{\hsklMonad}{\hsklTypeclass{Monad}}
\newcommand{\hsklMonadplus}{\hsklTypeclass{Monadplus}}
\newcommand{\hsklMonoid}{\hsklTypeclass{Monoid}}
\newcommand{\hsklNothing}{\varnothing}
\newcommand{\hsklNum}{\hsklTypeclass{Num}}
\newcommand{\hsklOrd}{\hsklTypeclass{Ord}}
\newcommand{\hsklReal}{\hsklTypeclass{Real}}

\newcommand{\hsklFunction}[1]{\Hat{#1}}
\newcommand{\hsklJust}[1]{\[#1\]}
\newcommand{\hsklList}[1]{\Bar{#1}}
\newcommand{\hsklListType}[1]{\boldsymbol{[}#1\boldsymbol{]}}
\newcommand{\hsklMaybe}[1]{\Tilde{#1}}
\newcommand{\hsklMaybeW}[1]{\widetilde{#1}}
\newcommand{\hsklMaybeType}[1]{\boldsymbol{\[}#1\boldsymbol{\]}}
\newcommand{\hsklPure}[1]{\langle#1\rangle}

\newcommand{\hsklTypeConstruct}[2]{#1\,#2}

\newcommand{\mathKeyword}[1]{\mathbf{#1}}
\newcommand{\mathVarKeyword}[1]{\mathsf{#1}}

\DeclareMathOperator{\mathAnyBinaryOperator}{\bigstar}
\DeclareMathOperator{\mathInverse}{\sharp}
\DeclareMathOperator{\mathAnd}{\wedge}
\DeclareMathOperator{\mathApply}{\$}
\DeclareMathOperator{\mathAnyUnaryOperator}{\star}
\DeclareMathOperator{\mathCompose}{\bullet}
\DeclareMathOperator{\mathIn}{::}
\DeclareMathOperator{\mathElse}{\mathKeyword{else}}
\DeclareMathOperator*{\mathFold}{\bigcup}
\DeclareMathOperator*{\mathFoldRight}{\bigsqcup}
\DeclareMathOperator{\mathFrom}{\in}
\DeclareMathOperator{\mathIf}{\mathKeyword{if}}
\DeclareMathOperator{\mathLambda}{\backslash}
\DeclareMathOperator{\mathMapsTo}{\mapsto}
\DeclareMathOperator{\mathOr}{\vee}
\DeclareMathOperator{\mathSetTimes}{\circledast}
\DeclareMathOperator{\mathThen}{\mathKeyword{then}}

\newcommand{\mathFirst}{\mathVarKeyword{First}}
\newcommand{\mathLambdaAnonymousParameter}{\lozenge}
\newcommand{\mathLambdaArrow}{\rightarrow}
\newcommand{\mathLeft}{\mathKeyword{left}}
\newcommand{\mathOtherwise}{\mathKeyword{otherwise}}
\newcommand{\mathRest}{\mathVarKeyword{Rest}}
\newcommand{\mathRight}{\mathKeyword{right}}
\newcommand{\mathSomething}{\square}

\newcommand{\mathFunctor}[1]{\mathrm{#1}}
\newcommand{\mathGuard}[1]{\mathop{\mid_{#1}}}
\newcommand{\mathSet}[1]{\mathbf{#1}}
\newcommand{\mathVector}[1]{\vec{#1}}

\newcommand{\mathCategoryShort}[2]{(#1,#2)_\mathcal{C}}
\newcommand{\mathLambdaExpression}[2]{\mathLambda#1\mathLambdaArrow#2}
\newcommand{\mathMorph}[2]{#1\mathMapsTo#2}

\newcommand{\mathMonoid}[3]{(#1,#2,#3)_\mathcal{M}}
\newcommand{\mathMorphII}[3]{#1\mathMapsTo#2\mathMapsTo#3}
\newcommand{\mathMorphIIWithParenthesis}[3]{#1\mathMapsTo(#2\mathMapsTo#3)}

\newcommand{\mathCategory}[4]{(#1,#2,#3,#4)_\mathcal{C}}
\newcommand{\mathGroup}[4]{(#1,#2,#3,#4)_\mathcal{G}}
\newcommand{\mathMorphIII}[4]{#1\mathMapsTo#2\mathMapsTo#3\mathMapsTo#4}

\newcommand{\mathField}[7]{(#1,#2,#3,#4,#5,#6,#7)_\mathcal{K}}


% ---

\def\boxcirc{\mathrel{\mathchoice{\BOXCIRC}{\BOXCIRC}{\scriptsize\BOXCIRC}{\tiny\BOXCIRC}}}
\def\BOXCIRC{{\setbox0\hbox{$\circ$}\rlap{\hbox to \wd0{\hss$\square$\hss}}\box0}}

\newcommand{\keyword}[1]{\emph{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newenvironment{leader}{\begingroup\bf}{\endgroup}
\newenvironment{point}{\begin{screen}}{\end{screen}}
% \newenvironment{footnotecode}{\begin{verbatim}}{\end{verbatim}}

% Lambda
\newcommand{\lambdasym}{\backslash}
\newcommand{\lambdadot}{\rightarrow}
\newcommand{\lambdaexp}[2]{\lambdasym#1\lambdadot#2}
\newcommand{\lambdacut}{\lozenge}

% Typeclasses
\newcommand{\typeclassname}[1]{\mathfrak{#1}}
\newcommand{\typeclassapplicative}{\typeclassname{Applicative}}
\newcommand{\typeclassbounded}{\typeclassname{Bounded}}
\newcommand{\typeclassenum}{\typeclassname{Enum}}
\newcommand{\typeclasseq}{\typeclassname{Eq}}
\newcommand{\typeclassfunctor}{\typeclassname{Functor}}
\newcommand{\typeclassintegral}{\typeclassname{Integral}}
\newcommand{\typeclassmonad}{\typeclassname{Monad}}
\newcommand{\typeclassmonadplus}{\typeclassname{Monadplus}}
\newcommand{\typeclassmonoid}{\typeclassname{Monoid}}
\newcommand{\typeclassnum}{\typeclassname{Num}}
\newcommand{\typeclassord}{\typeclassname{Ord}}
\newcommand{\typeclassreal}{\typeclassname{Real}}

% Types
\newcommand{\typename}[1]{\mathbf{#1}}
\newcommand{\typeconstructor}[2]{\mathop{#1}\,#2}
\newcommand{\typebool}{\typename{Bool}}
\newcommand{\typechar}{\typename{Char}}
\newcommand{\typefunction}{\typename{Function}}
\newcommand{\typeint}{\typename{Int}}
\newcommand{\typefloat}{\typename{Float}}
\newcommand{\typelist}{\typename{List}}
\newcommand{\typemaybe}{\typename{Maybe}}

% Morph
\newcommand{\morph}[2]{#1\mapsto#2}
\newcommand{\mmorph}[3]{#1\mapsto#2\mapsto#3}
\newcommand{\mmorphwithparenthesis}[3]{#1\mapsto(#2\mapsto#3)}
\newcommand{\mmmorph}[4]{#1\mapsto#2\mapsto#3\mapsto#4}

% Parameters
\newcommand{\anonymousparameter}{\lozenge}

% Constants
\newcommand{\constantname}[1]{\mathrm{#1}}
\newcommand{\constanttrue}{\constantname{T}}
\newcommand{\constantfalse}{\constantname{F}}
\newcommand{\constantempty}{\emptyset}
\newcommand{\constantnothing}{\varnothing}
\newcommand{\constantidentityfunction}{\anonymousparameter}

% Unary ops.
\newcommand{\unarypred}{\blacktriangleleft}
\newcommand{\unarysucc}{\blacktriangleright}

% Binary ops.
\newcommand{\binaryeq}{\equiv}
\newcommand{\binaryl}{<}
\newcommand{\binaryle}{\le}
\newcommand{\binaryge}{\ge}
\newcommand{\binaryg}{>}
\newcommand{\binaryadd}{+}
\newcommand{\binarysub}{-}
\newcommand{\binarymultiply}{*}
\newcommand{\binarydivide}{/}
\newcommand{\binaryor}{\vee}
\newcommand{\binaryand}{\wedge}
\newcommand{\binarycompose}{\bullet}
\newcommand{\binaryfunctormap}{\cdot}
\newcommand{\binaryapplicativemap}{\times}
\newcommand{\binarymonadmap}{\heartsuit}%{\Leftarrow}
\newcommand{\binarylistfunctormap}{\odot}
\newcommand{\binarylistapplicativemap}{\otimes}
\newcommand{\binarylistmonadmap}{\circ}%{\hookleftarrow}
\newcommand{\binarylistappend}{\oplus}
\newcommand{\binarymaybefunctormap}{\boxdot}
\newcommand{\binarymaybeapplicativemap}{\boxtimes}
\newcommand{\binarymaybemonadmap}{\Box}%{\leftleftarrows}
\newcommand{\binarymaybeappend}{\boxplus}
\newcommand{\binaryfunctionfunctormap}{\binarycompose}
\newcommand{\binaryfunctionapplicativemap}{\Join}%{\bowtie}
\newcommand{\binaryfunctionmonadmap}{\diamond}%{\blacktriangleright\!\blacktriangleleft}%{\twoheadleftarrow}
\newcommand{\binaryapply}{\mathop{\$}}
\newcommand{\binaryconcat}{:}

% Functions
\newcommand{\functionpred}{\mathop{\text{pred}}}
\newcommand{\functionsucc}{\mathop{\text{succ}}}

% Parenthesis ops.
\newcommand{\applicativetype}[1]{\left\langle#1\right\rangle}
\newcommand{\listtype}[1]{\left[#1\right]}
\newcommand{\maybetype}[1]{\left\{#1\right\}}
\newcommand{\functyontype}[1]{\[#1\]}

% Guard
\newcommand{\guard}[1]{\mathop{\mid_{#1}}}
\newcommand{\guardcomma}{,\,}

% Range
\newcommand{\isin}{\in}
\newcommand{\rangedots}{\dots}
\newcommand{\infinitydots}{\dots}

% Type and class
\newcommand{\istypeof}{\mathop{::}}
\newcommand{\isclassof}{\subset}

% Keywords
\newcommand{\keywordname}[1]{\mathbf{#1}}
\newcommand{\keywordotherwise}{\keywordname{otherwise}}
\newcommand{\keywordif}{\mathop{\keywordname{if}}}
\newcommand{\keywordthen}{\mathop{\keywordname{then}}}
\newcommand{\keywordelse}{\mathop{\keywordname{else}}}

% Special words
\newcommand{\specialwordname}[1]{\mathsf{#1}}
\newcommand{\specialwordfirst}{\specialwordname{First}}
\newcommand{\specialwordrest}{\specialwordname{Rest}}

% Math
\newcommand{\mathbinaryop}{\bigstar}
\newcommand{\mathidentity}{\mathcal{O}}
\newcommand{\mathidentitymorph}{\mathcal{I}}
\newcommand{\mathsetname}[1]{\boldsymbol{#1}}
\newcommand{\mathfunctorname}[1]{\mathbb{#1}}
\newcommand{\mathtriple}[3]{(#1,#2,#3)}
\newcommand{\mathcompose}{\bullet}
\newcommand{\mathfold}{\bigcup}
\newcommand{\mathfoldright}{\bigsqcup}
\newcommand{\mathwhere}{\mathop{\text{where}}}

\begin{document}
\maketitle
\tableofcontents

\begin{table*}
\caption{凡例}
\begin{center}
\begin{tabular}{||c|c|c||}
\hline
種類&字体・表記法&例\\
\hline
変数&イタリック体，小文字（1文字）&$x$, $y$\\
関数&イタリック体，小文字（1文字）&$f$, $g$\\
定数&イタリック体，大文字（1文字）&$I$, $T$\\
特別な関数&ローマン体，小文字で始める&$\hsklSucc$, $\hsklPred$\\
キーワード&ボールド体，小文字で始める&$\mathIf$, $\mathOtherwise$\\
集合と型&ボールド体，大文字で始める&$\mathSet{S}$, $\hsklInt$\\
型パラメタ&ボールド体，小文字（1文字）&$\hsklType{a}$, $\hsklType{b}$\\
関手と型コンストラクタ&ローマン体，大文字で始める&$\mathFunctor{F}$, $\hsklListConstructor$\\
型クラス&サンセリフ体，大文字で始める&$\hsklEq$, $\hsklIntegral$\\
\hline
リスト&ブラケットで包む&$[x,y,z]$\\
集合&ブレースで包む&$\{x,y,z\}$\\
組み合わせ（タプル）&丸括弧で包む&$(x,y,z)$\\
% \hline
% リスト変数&名前にバーをつける&$\hsklList{x}$\\
% Maybe変数&名前にチルダをつける&$\hsklMaybe{x}$\\
% 関数変数&名前にハットをつける&$\hsklFunction{x}$\\
% ベクトル変数&名前に矢印をつける&$\mathVector{x}$\\
% \hline
% コード&タイプライタ体&\texttt{1+x}\\
\hline
\end{tabular}
\end{center}
\end{table*}


\part{代数構造とプログラミング}

\chapter{はじめに}

Haskellというプログラミング言語を知ろうとすると，従来のプログラミング言語の知識が邪魔をする．
モダンで，人気があって，Haskellから影響を受けた言語，例えばRubyやSwiftの知識さえ，Haskellを学ぶ障害になり得る．
ではどのようにしてHaskellの深みに到達すればいいのだろうか．

その答えは，一見遠回りに見えるが，一度抽象数学の高みに登ることである．

と言っても，あわてる必要はない．

近代的なプログラミング言語を知っていれば，すでにある程度抽象数学に足を踏み入れているからである．

\chapter{数学的準備}

\begin{leader}
この章では「代数的構造」を見ていくことにする．
代数的構造とは，四則演算のような数に関する基本的な性質を抽象化していくことで，数の背後にある基本的なメカニズムを抽出したものである．
代数的構造はあらゆるプログラミング言語に明示的，あるいは非明示的に見られる要素である．
\end{leader}

\section{数}

これから各種の\keyword{代数的構造}を見ていくことにする．
代数的構造と言っても，身構える必要はない．
それは，我々プログラマが日々接している概念に，共通した名前を与えたにすぎない．

まず最初に，我々にとって一番身近な代数的構造である\keyword{数}を見てみよう．
数の代表例は\keyword{実数}であるから，実数を例にとって考えてみよう．
実数全体の集合を$\mathSet{R}$で表すことにする．
また任意の実数を$x,y,z$で表すこととする．
このことを数学者は$x,y,z\in\mathSet{R}$と書くが，我々は記号$\in$を別の用途に使いたいので，本書では$$x,y,z\mathIn\mathSet{R}$$と表すことにする．

以下に実数の備える代数的性質を列挙する．
どれも当たり前のことに見えるが，ひとつひとつ見ていこう．
ここで$x,y,z\mathIn\mathSet{R}$とする．
\begin{description}
\item[実数の性質1. 足し算] 任意の$x$と任意の$y$の足し算（\keyword{加法}）の結果（\keyword{和}）$x+y$は$\mathSet{R}$の元すなわち実数である．
\item[実数の性質2. 足し算の結合則] 任意の$x,y,z$について$$(x+y)+z=x+(y+z)$$である．これを\keyword{結合則}と呼ぶ．
\item[実数の性質3. 零元（加法単位元）の存在] 特別な実数$0\mathIn\mathSet{R}$があり$$0+x=x+0=x$$である．この$0$は足し算の\keyword{単位元}である．\keyword{零元}または\keyword{加法単位元}と呼ぶこともある．
\item[実数の性質4. 負元（加法逆元）の存在] 任意の$x$に対して$-x\mathIn\mathSet{R}$があり$$-x+x=0$$である．この$-x$は$x$の足し算の\keyword{逆元}である．\keyword{負元}または\keyword{加法逆元}と呼ぶこともある．
\item[実数の性質5. 足し算の可換性] 任意の$x,y$について$$x+y=y+x$$である．このことを足し算の\keyword{可換性}と呼ぶ．
\item[実数の性質6. 掛け算] 任意の$x$と任意の$y$の掛け算（\keyword{乗法}）の結果（\keyword{積}）$x*y$は$\mathSet{R}$の元すなわち実数である．
\item[実数の性質7. 掛け算の結合則] 任意の$x,y,z$について$$(x*y)*z=x*(y*z)$$である．
\item[実数の性質8. 単位元の存在] 特別な実数$1\mathIn\mathSet{R}$があり$$1*x=x*1=x$$である．この$1$を掛け算の単位元または\keyword{乗法単位元}と呼ぶ．
\item[実数の性質9. 逆元の存在] 任意の$x$に対して$x^{-1}\mathIn\mathSet{R}$があり$$x^{-1}*x=1$$である．この$x^{-1}$は$x$の掛け算の逆元である．\keyword{乗法逆元}と呼ぶこともある．ただし性質11で述べる通り，加法単位元については逆元がなくても良い．
\item[実数の性質10. 掛け算の可換性] 任意の$x,y$について$$x*y=y*x$$である．このことを掛け算の可換性と呼ぶ．
\item[実数の性質11. 加法単位元の乗法逆元] 加法単位元に対する掛け算の逆元は存在しなくても良い．（つまり$0^{-1}$のことは考えなくて良い．）
\item[実数の性質12. 分配則] 足し算と掛け算が混在する場合$$x*(y+z)=x*y+x*z$$と掛け算を\keyword{分配}する．
\end{description}
以上が実数の代数的性質の全てである．
我々がよく使う割り算，引き算はプログラミングでいう糖衣構文 (syntax sugar) である．

上述の12個の条件が当てはまる数には，\keyword{有理数}や\keyword{複素数}がある．
この12個の性質をまとめて，数学では\keyword{体}または可換体と呼ぶ．
わざわざ可換と断るのは，現代の数学では$x*y\neq y*x$であるような体系がよく用いられるからである．

体の要素は，集合$\mathSet{K}$，二項演算子$+$，二項演算子$+$の単位元$0$，二項演算子$+$の逆元生成演算子$-$，もう一つの二項演算子$*$，二項演算子$*$の単位元$1$，二項演算子$*$の逆元生成演算子$\mathSomething^{-1}$であるから，体はそれらを列挙して$\mathField{\mathSet{K}}{+}{0}{-}{*}{1}{\mathSomething^{-1}}$と表現する．

体の性質から言えることを一つ紹介しよう．
これから$$z\uparrow n=\underbrace{z*\dotsb*z}_n$$なる二項演算子$\uparrow$（\keyword{クヌースの矢印}）を使う．
ここに$z$を体$\mathField{\mathSet{K}}{+}{0}{-}{*}{1}{{}^{-1}}$の$\mathSet{K}$の元，$n$を自然数とした．
さて$z\uparrow2$は$$z\uparrow2=z*z$$であるから，いま$z=x+y$とすると
\begin{align*}
z\uparrow2&=z*z\\
&=z*(x+y)\\
&=z*x+z*y\;\dots\;\text{分配則}\\
&=(x+y)*x+(x+y)*y\\
&=x*x+y*x+x*y+y*y\;\dots\;\text{分配則}\\
&=x\uparrow2+x*y+y*x+y\uparrow2
\end{align*}
となり
\begin{equation}
\label{eq:xysq}
(x+y)\uparrow2=x\uparrow2+x*y+y*x+y\uparrow2
\end{equation}
を得る．
式\eqref{eq:xysq}は体の性質だけを使って導いた関係なので，実数だけでなく有理数や複素数にもそのまま使える．
実際には式\eqref{eq:xysq}は体の性質のうち分配則だけを使っいるので，体以外にも応用が利く式である．

一方で，この体の性質を若干緩めたい場合もある．
さもなければ，\keyword{整数}，\keyword{正方行列}，\keyword{クォータニオン}（四元数），\keyword{論理値}，\keyword{ベクトル}，ベクトルの\keyword{変換}，\keyword{写像}と言った重要な概念が数の概念からこぼれてしまうからである．
例えば整数の掛け算の逆元は（単位元の逆元を除いて）整数の中には存在しないし，正則行列やクォータニオンの場合は掛け算が可換ではない．
だいたいどの辺まで制約を緩めたものを数の仲間に入れるかというのは見解の分かれるところでもあるが，体から性質9（掛け算の逆元），性質10（掛け算の可換性），性質11（加法単位元の乗法逆元）を取り除いたものを\keyword{環}と呼び，環の性質を持つものを数の仲間に入れることが一般的である．
環の性質を持つものは，体である実数，有理数，複素数に加えて，整数，正方行列，クォータニオン，論理値などがある．

制約を少しずつ緩める代わりに，制約をその構成要素に分解するほうがさらなる応用が利きそうである．
体には二つの二項演算子$+$と$*$が登場した．
その片方にのみ注目してみたらどうなるだろう．
それが次節で取り上げる\keyword{群}である．

\begin{table*}
\caption{代表的な代数的構造の性質(1)}
\label{tab:field-and-ring}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c||}
\hline
代数的構造&$\mathAnyBinaryOperator_1$&$\mathAnyBinaryOperator_1$の単位元&$\mathAnyBinaryOperator_1$の逆元&$\mathAnyBinaryOperator_2$&$\mathAnyBinaryOperator_2$の単位元&$\mathAnyBinaryOperator_2$の逆元\\
\hline\hline
体&可換&あり&あり&可換&あり&あり\\
環&可換&あり&あり&非可換&あり&なし\\
\hline
\end{tabular}
\end{center}
\end{table*}

\section{群}

形式的に二項演算子$+$を$\mathAnyBinaryOperator_1$とし，二項演算子$*$を$\mathAnyBinaryOperator_2$として，体と環の性質を並べたものが表\ref{tab:field-and-ring}である．
これを見ると，演算子$\mathAnyBinaryOperator$について「可換・単位元あり・逆元あり」の組み合わせが二つペアになったもの（体）か，「可換・単位元あり・逆元あり」の組み合わせと「非可換・単位元あり・逆元なし」の組み合わせがペアになったもの（環）があり，その構成要素は二項演算子$\mathAnyBinaryOperator$について「可換・単位元あり・逆元あり」と「非可換・単位元あり・逆元なし」の2種類であることがわかる．

いま集合$\mathSet{G}$があり，$x,y,z\mathIn\mathsetname{G}$であるとし，二項演算子を$\mathAnyBinaryOperator$と書くことにして，体の性質の前半分を書き下してみよう．
\begin{description}
\item[性質1.] 任意の$x$と任意の$y$の演算の結果$x\mathAnyBinaryOperator y$は$\mathSet{G}$の元である．
\item[性質2.] 任意の$x,y,z$について$$(x\mathAnyBinaryOperator y)\mathAnyBinaryOperator z=x\mathAnyBinaryOperator(y\mathAnyBinaryOperator z)$$である．
\item[性質3.] 特別な元$O\mathIn\mathSet{G}$があり$$O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x$$である．
\item[性質4.] 任意の$x$に対して$\mathInverse x\mathIn\mathSet{G}$があり$$\mathInverse x\mathAnyBinaryOperator x=O$$である．
\item[性質5.] 任意の$x,y$について$$x\mathAnyBinaryOperator y=y\mathAnyBinaryOperator x$$である．
\end{description}
このような性質が満たされる時，組み合わせ$\mathGroup{\mathSet{G}}{\mathAnyBinaryOperator}{O}{\mathInverse}$を\keyword{可換群}または\keyword{加群}と呼ぶ．
この可換群が最初の構成要素「可換・単位元あり・逆元あり」の正体である．

例えば$\mathGroup{\mathSet{R}}{+}{0}{-}$は可換群である．
整数全体の集合を$\mathSet{Z}$とすると$\mathGroup{\mathSet{Z}}{+}{0}{-}$も可換群である．
また，集合$\mathSet{R}$から$0$だけを取り除いた集合を$\mathSet{R}\setminus0$とするとき$\mathGroup{\mathSet{R}\setminus0}{*}{1}{\mathSomething^{-1}}$も可換群である．

可換群は代表的な代数的構造のひとつであり，他にも数学のあちこちに顔を出している．
例えば回転角を$r$とする二次元の回転変換（行列）を$U_r$ただし$$U_r=\begin{bmatrix}\cos r&-\sin r\\\sin r&\cos r\end{bmatrix}$$として，回転変換$U_r$すべてからなる集合$\mathSet{U}$を考えてみよう．
回転の合成を$\bullet$で表すとすると
\begin{equation}
\label{eq:rotation}
U_{r_1}\bullet U_{r_2}=U_{(r_1+r_2)}
\end{equation}
であるから，回転を合成した結果も回転である．
また式\eqref{eq:rotation}から$$U_{r_1}\bullet\left(U_{r_2}\bullet U_{r_3}\right)=\left(U_{r_1}\bullet U_{r_2}\right)\bullet U_{r_3}$$
であるから，回転変換は結合則も満たしている．

次にに回転変換に単位元があるかどうか調べてみよう．
回転しない変換は\keyword{恒等変換}とも言い，しばしば$I$で表す．
何もしない回転変換は$0$度の回転であるから$I=U_0$である．
このとき$$I\bullet U_r=U_r\bullet I=U_r$$であるから，$I$は回転変換の単位元であると言える．

最後に回転変換に逆元があるかも調べてみよう．
$r$回転の逆は明らかに$-r$であるから$$U_{-r}\bullet U_r=U_r\bullet U_{-r}=I$$が成り立つ．
そこで$$U_{r}^{-1}=U_{-r}$$として$U_r$の逆元$U_r^{-1}$を定義することができる．

このように，組み合わせ$\mathGroup{\mathSet{U}}{\bullet}{I}{\mathSomething^{-1}}$も可換群である．

任意次元のベクトル全体からなる集合を$\mathSet{V}$として，零ベクトルを$\mathVector{Z}$で表すことにしよう．
% 矢印はベクトルであることを忘れないようにするための飾りである．
ベクトル同士の加算を二項演算子$+$で表し，向きを反転させた逆ベクトル作る演算子を$-$とすると，組み合わせ$\mathGroup{\mathSet{V}}{+}{\mathVector{Z}}{-}$もまた可換群である．

可換群の性質のうち最初の4項目だけを満たすものを\keyword{群}と呼ぶ．
可換群は群の特別な場合である．
現代の数学では$x\mathAnyBinaryOperator y\neq y\mathAnyBinaryOperator x$のように演算子の前後を入れ替えると結果が異なるような演算をよく取り扱うので，一般の群は可換群よりもよく取り上げられ，それ故より短い名前が付けられている．

もう一度組み合わせ$\mathGroup{\mathSet{G}}{\mathAnyBinaryOperator}{O}{\mathInverse}$が群である条件を見ておこう．
それは
\begin{description}
\item[群の性質1.] 任意の$x$と任意の$y$の演算の結果$x\mathAnyBinaryOperator y$は$\mathSet{G}$の元である．
\item[群の性質2. 結合則] 任意の$x,y,z$について$$(x\mathAnyBinaryOperator y)\mathAnyBinaryOperator z=x\mathAnyBinaryOperator(y\mathAnyBinaryOperator z)$$である．
\item[群の性質3. 単位元の存在] 特別な元$O\mathIn\mathSet{G}$があり$$O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x$$である．
\item[群の性質4. 逆元の存在] 任意の$x$に対して$\mathInverse x\mathIn\mathSet{G}$があり$$\mathInverse x\mathAnyBinaryOperator x=O$$である．
\end{description}
であった．
これらの条件を少し緩め，逆元が存在しなくても良い「緩やかな群」を考えてみる．
この「緩やかな群」のことを\keyword{単位的半群}または\keyword{モノイド}と呼ぶ．
これが構成要素「非可換・単位元あり・逆元なし」の正体である．

\begin{table}
\caption{代表的な代数的構造の性質 (2)}
\label{tab:group-and-monoid}
\begin{center}
\begin{tabular}{||c||c|c|c||}
\hline
代数的構造&$\mathAnyBinaryOperator$&$\mathAnyBinaryOperator$の単位元&$\mathAnyBinaryOperator$の逆元\\
\hline\hline
可換群&可換&あり&あり\\
群&非可換&あり&あり\\
単位的半群&非可換&あり&なし\\
半群&非可換&なし&なし\\
\hline
\end{tabular}
\end{center}
\end{table}

単位的半群の性質は次の三つである．ただし$x,y,z$が集合$\mathSet{M}$の元であるとする．
\begin{description}
\item[単位的半群の性質1.] 任意の$x$と任意の$y$の演算の結果$x\mathAnyBinaryOperator y$は$\mathSet{M}$の元である．
\item[単位的半群の性質2. 結合則] 任意の$x,y,z$について$$(x\mathAnyBinaryOperator y)\mathAnyBinaryOperator z=x\mathAnyBinaryOperator(y\mathAnyBinaryOperator z)$$である．
\item[単位的半群の性質3. 単位元の存在] 特別な元$O\mathIn\mathSet{M}$があり$$O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x$$である．
\end{description}
このとき，組み合わせ$\mathMonoid{\mathSet{M}}{\mathAnyBinaryOperator}{O}$が単位的半群である．
可換群とこの単位的半群を組み合わせたのが環，可換群二つを組み合わせたのが体であった．

なお，これまで単位元の定義として$O\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O=x$を掲げているが，厳密には単位元は$$O_\mathLeft\mathAnyBinaryOperator x=x\mathAnyBinaryOperator O_\mathRight=x$$のように，\keyword{左単位元}と\keyword{右単位元}を区別しても良い．

単位的半群の性質からさらに性質3を消したものを\keyword{半群}と呼ぶ．
可換群，群，単位的半群，半群を一覧にしたものを表\ref{tab:group-and-monoid}に掲げる．

\section{圏}

これまでは集合の元同士に対する二項演算を考えてきた．
集合$\mathSet{M}$が単位的半群であるとき，集合$\mathSet{M}$の元$x,y\mathIn\mathSet{M}$に対して$x\mathAnyBinaryOperator y\mathIn\mathSet{M}$であった．
見方を変えると，演算子$\mathAnyBinaryOperator$とは集合$\mathSet{M}$の元2個から出発して，集合$\mathSet{M}$の元1個へとジャンプさせる\keyword{写像}であると言える．
これを$$\mathAnyBinaryOperator\mathIn\mathMorph{\mathSet{M}\mathSetTimes\mathSet{M}}{\mathSet{M}}$$と書く．
ここに$\mathSet{X}\mathSetTimes\mathSet{Y}$は集合$\mathSet{X}$と集合$\mathSet{Y}$の\keyword{直積集合}である．
直積集合と元の集合はもはや別な集合であることに注意しよう．

写像は$\mathMorph{\mathSet{M}\mathSetTimes\mathSet{M}}{\mathSet{M}}$に限ったもの出はなく，集合$\mathSet{M}$から集合$\mathSet{M}$への写像$\mathAnyUnaryOperator$ただし$$\mathAnyUnaryOperator\mathIn\mathMorph{\mathSet{M}}{\mathSet{M}}$$があっても良い．
実はこれまでにも登場した逆元を作る演算子はまさに$\mathMorph{\mathSet{M}}{\mathSet{M}}$という写像である．

またベクトルには，実数倍や回転といった写像がある．
これらは実数のパラメタを一つとるので，ベクトル全体の集合を$\mathSet{V}$，実数全体の集合を$\mathSet{R}$として，実数のパラメタを$r$としたときに$$\mathAnyUnaryOperator_r\mathIn\mathMorph{\mathSet{R}\mathSetTimes\mathSet{V}}{\mathSet{V}}$$と書ける．
例えば回転の場合は$\mathAnyUnaryOperator_r=U_r$である．

このようにとある集合（例えば$\mathSet{M}\mathSetTimes\mathSet{M}$や$\mathSet{R}\mathSetTimes\mathSet{V}$）から異なる別な集合（例えば$\mathSet{M}$や$\mathSet{V}$）へという写像を一般化するとどうなるだろうか．
いま，集合$\mathSet{X}$から集合$\mathSet{Y}$への写像$f$があり，集合$\mathSet{Y}$から集合$\mathSet{Z}$への写像$g$があるとする．
すなわち
\begin{align*}
f&\mathIn\mathMorph{\mathSet{X}}{\mathSet{Y}}\\
g&\mathIn\mathMorph{\mathSet{Y}}{\mathSet{Z}}
\end{align*}
があるとする．
また写像同士を二項演算子$\mathCompose$で\keyword{合成}できるものとする．
例えば$f$と$g$の合成写像は$\mathSet{X}$を出発点に$\mathSet{Y}$を経由して$\mathSet{Z}$へと行くので$$f\mathCompose g\mathIn\mathMorph{\mathSet{X}}{\mathSet{Z}}$$と書ける．
ここで合成演算子は結合則を満たすものとしておこう．

さらに$$I_\mathSet{X}\mathIn\mathMorph{\mathSet{X}}{\mathSet{X}},\;I_\mathSet{Y}\mathIn\mathMorph{\mathSet{Y}}{\mathSet{Y}},\;I_\mathSet{Z}\mathIn\mathMorph{\mathSet{Z}}{\mathSet{Z}}$$という写像もあるとしよう．
ここで$$I_\mathSet{Y}\mathCompose f=f\mathCompose I_\mathSet{X}$$とすると，写像$I_\mathSet{X}$と写像$I_\mathSet{Y}$はそれぞれ写像の合成演算子$\mathCompose$に対して単位元のように振る舞う．
写像$g$については$$I_\mathSet{Z}\mathCompose g=g\mathCompose I_\mathSet{Y}$$であるとする．
このような写像$I_\mathSet{X},I_\mathSet{Y},I_\mathSet{Z}$を\keyword{恒等写像}と呼ぶ．

集合$\mathSet{X}$，集合$\mathSet{Y}$，集合$\mathSet{Z}$の集合$\mathSet{C}$と，写像$f$と写像$g$の集合$\mathSet{P}$と，写像合成演算子$\mathCompose$と，恒等写像の集合$\mathSet{I}$の組み合わせ$\mathCategory{\mathSet{C}}{\mathSet{P}}{\mathCompose}{\mathSet{I}}$を\keyword{圏}と呼ぶ．
写像合成演算子と恒等写像の集合は自明であるためしばしば省略され，組み合わせ$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$を圏とする書き方もよくされる．

圏を考えるとき，変換や写像は全て\keyword{射}と呼ぶ決まりである．

いまある単位的半群$\mathMonoid{\mathSet{M}}{\mathAnyBinaryOperator}{O}$があるとする．
集合$\mathSet{C}$を$\mathSet{M}$及び$\mathSet{M}\mathSetTimes\mathSet{M}$を元とする集合とし，集合$\mathSet{P}$を$\mathAnyBinaryOperator$のみを元とする集合とすると，組み合わせ$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$は圏になっている．

\section*{余計な話：束}


\chapter{記法}

\begin{leader}
本書では一般の数学書やプログラミングの教科書からは少し異なった記法を用いる．
ある概念が発明されてからずっと後になって正しい記法が見つかり，それがきっかけとなって正しく理解されるという現象は歴史上よくあることである．
本書でも様々な新しい記号，記法を導入するが，この章では既に比較的広く知られている記法を紹介する．
\end{leader}


\section{関数}

関数引数には括弧を付けない．我々はよく引数$x$をとる関数$f$を$f(x)$と書くが，括弧は冗長なので今後は$fx$と書くことにする．
引数$x$を関数$f$に「食わせる」ことを\keyword{関数適用}と呼ぶ．

複数引数をとる関数を我々はよく$f'(x,y)$と書くが，これも括弧が冗長なので今後は$f'xy$と書くことにする．
この場合式$f'xy$は左を優先して結合するものとする．つまり$$f'xy=(f'x)y$$である．
引数に「飢えた」関数$(fx)$を\keyword{部分適用}された関数と呼ぶ．\footnote{Haskellでは関数\code{f}に引数\code{x}を適用させることを \code{f x} と書く．}

このように式の左側を優先的に演算していくことを\keyword{左結合}と呼ぶ．
関数適用は左結合である．
他に式の右側を優先的に演算する\keyword{右結合}の演算子も存在する．

\section{演算子}

単項演算子には論理否定($\neg$)とマイナス($-$)がある．
本書で扱う基本的な単項演算子はこの2種類だけであるが，複数の演算子を組み合わせて単項演算子を新たに作ることはある．

二項演算子のうちよく使われるものは和($+$)，積($*$)，差($-$)，商（$/$），論理和($\vee$)，論理積($\wedge$)，同値($\equiv$)，大なり($>$)，小なり($<$)等である．
二項演算子はたとえ積記号であっても省略できない．
二項演算子は多数あるので，その都度説明する．

二項演算子は中置することが基本であるが，括弧で包むことで前置することも可能である．
任意の二項演算子$\mathAnyBinaryOperator$について$$x\mathAnyBinaryOperator y$$及び$$(\mathAnyBinaryOperator)xy$$は全く同じ意味である．\footnote{Haskellでは任意の二項演算子を括弧で包むことで前置演算子として使うことができる．例えば\code{x+y}と \code{(+)x y} は同じ結果を返す．逆に任意の二引数関数\code{f}は \code{x `f` y} と書くことで中置することができる．}

二項演算子の結合性，すなわち左結合か右結合かは，演算子によって異なる．

演算の優先順位を明示的に与えるために括弧が用いられる．

\begin{point}
任意の二項演算子$\mathAnyBinaryOperator$について$$x\mathAnyBinaryOperator y=(\mathAnyBinaryOperator)xy$$である．
\end{point}

\section{ラムダ式}
引数$x$をとり値$1+x$を返す\keyword{ラムダ式}は次のように書くことにする．
$$\mathLambdaExpression{x}{1+x}$$
この式はラムダ式を発明したチャーチのオリジナルの論文の記法であれば$\Hat x\,.\,1+x$と書かれたところであり，現在でも多くの書物で$\lambda x\,.\,1+x$と記述されるところである．
しかし我々はすべてのギリシア文字を変数名のために予約しておきたいのと，ピリオド記号($.$)が今後登場する二項演算子$\cdot$と紛らわしいため，上述の記法を用いる．\footnote{Haskellではこのラムダ式を \code{\textbackslash x->1+x} と書く．}

ラムダ式は関数である．
ラムダ式を適用するには，ラムダ式を括弧で包む必要がある．
例を挙げる．
$$\left(\mathLambdaExpression{x}{1+x}\right)2$$
この式は結果として$3$を返す．

複数引数をとるラムダ式は例えば$$\mathLambdaExpression{xy}{x+y}$$のように引数を並べて書く．

本書では新たに，次のラムダ式記法も導入する．
式中に記号$\mathLambdaAnonymousParameter$が現れた場合，その式全体がラムダ式であるとみなす．
記号$\mathLambdaAnonymousParameter$の部分には引数が入る．
第$n$番目の$\mathLambdaAnonymousParameter$には第$n$番目の引数が入る．
例えばラムダ式$\mathLambdaExpression{xy}{x+y}$は$$\mathLambdaAnonymousParameter+\mathLambdaAnonymousParameter$$と書いても良い．
式を左から読んで1番目の$\mathLambdaAnonymousParameter$が元々の$x$すなわち第1引数を，2番目の$\mathLambdaAnonymousParameter$が元々の$y$すなわち第2引数を意味する．この省略記法はプログラミング言語Schemeにおけるcutプロシジャに由来する．\footnote{この記法はHaskellにはない．}

\section*{余計な話：局所変数}

let, where.

\chapter{関数}

\begin{leader}
プログラムはひとつの関数であり，その関数はいくつかの部分的な関数から合成される．
つまり，関数はプログラムの全体であり，またビルディングブロックである．
プログラムという関数をより小さな関数の合成で作るのは，それらの小さな関数が他のプログラムに再利用されることを期待するためである．
このように関数と関数の合成はプログラミングの中心的な概念である．
% プログラミング言語Cは，プログラムが関数だけからでも構成できることを示した．
% Pascalの「手続き」はCでは値を返さない関数であり，Pascalの「本文」はmainという名前の関数である．
\end{leader}


\section{関数の定義}

ラムダ式を用いた\keyword{関数}の定義が可能である．
例えば引数$x$をとり値$1+x$を返す関数$f$は$$f=\mathLambdaExpression{x}{1+x}$$と定義できる．
この省略形として$$fx=1+x$$と書いても良いし，さらに省略して$$f=(+)1$$と書いても良い．
もちろん$f=+1$でないことに注意しよう．\footnote{Haskellでは$f=\mathLambdaExpression{x}{1+x}$を\code{f=\textbackslash x->1+x}，$fx=1+x$を\code{f x = 1+x}，$f=(+)1$を\code{f=(+)1}のように書く．}

関数に\keyword{スペシャルバージョン}がある場合はそれらを列挙する．
例えば引数が$0$の場合は特別に戻り値も$0$であり，その他の場合は関数$f$と同じ振る舞いをする関数$f'$を考える．
このとき$f'$は
\begin{equation*}
\begin{split}
f'0&=0\\
f'x&=1+x
\end{split}
\end{equation*}
ように定義することになる．\footnote{Haskellでは
\begin{Verbatim}[xleftmargin=10mm]
f' 0 = 0
f' x = 1+x
\end{Verbatim}
と書く．}

関数定義に\keyword{場合分け}が必要な場合は「ガード」を用いる．
例えば引数の値が負の場合は$-1$を，$0$の場合は$0$を，それ以外の場合は関数$f$と同じ振る舞いをする関数$f''$は
\begin{equation*}
\begin{split}
f''x&\mathGuard{x<0}=-1\\
&\mathGuard{x\equiv 0}=0\\
&\mathGuard{\mathOtherwise}=1+x
\end{split}
\end{equation*}
という風に定義することにする．\footnote{Haskellでは
\begin{Verbatim}[xleftmargin=10mm]
f'' x | x<0       = -1
      | x==0      = 0
      | otherwise = 1+x
\end{Verbatim}
と書く．}

関数のスペシャルバージョン，場合分けといった左片での条件付けではなく，定義式の右辺で条件付けをすることも可能である．
それには\keyword{条件式}を使う．
条件式とは
$$fx=\mathIf x\equiv0\mathThen0\mathElse1+x$$
のように$\mathIf$節，$\mathThen$節，及び$\mathElse$節からなるものである．
$\mathIf$節の中身は真理値を返す関数であれば良いので，関数$p$を$$p=(\equiv)0$$としておき，$$fx=\mathIf px\mathThen0\mathElse1+x$$と書く方法もしばしば用いられる．\footnote{Haskellでは$fx=\keywordif x\binaryeq0\keywordthen0\keywordelse1+x$を\code{f x = if x == 0 then 0 else 1+x}と書く．}

条件式は紙面が許せば次のように書いても良い．
\begin{equation*}
fx=\begin{cases}
0&\mathIf x\equiv0\\
1+x&\mathOtherwise
\end{cases}
\end{equation*}


関数は内部で自分自身を読んでも良い．
例えば$x$の階乗を返す関数$s$は
\begin{equation*}
sx=\begin{cases}
1&\mathIf x\equiv0\\
x*s(x-1)&\mathOtherwise
\end{cases}
\end{equation*}
と定義できる．

\section{関数の合成}

関数は\keyword{合成}できる．関数$f$と関数$g$があって，その合成を$f\mathCompose g$と書くとき$$(f\mathCompose g)x=f(gx)$$である．
関数合成の演算子$\mathCompose$は関数適用よりも優先順位が高く，$(f\mathCompose g)x$は単に$f\mathCompose g\,x$と書いても良い．
この記法は括弧の数を減らすためにしばしば用いられる．\footnote{Haskellでは関数\code{f}と関数\code{g}の合成は\code{f.g}である．}

関数合成演算子とは逆に，優先順位の低い関数適用演算子も考えておくと括弧の数を減らすのに便利である．
関数適用演算子$\mathApply$を次のように定義しておく．
$$f\mathApply gx=f(gx)$$
演算子$\mathApply$の優先順位は足し算演算子よりも低いものとする．
よって$f(x+1)$は$f\mathApply x+1$と書くこともできる．\footnote{Haskellでは$f\mathApply gx$を\code{f \$ g x}と書く．}

\section{カリー化}

どのような関数であれ，引数は1個しかとらない．
引数が2個あるように見える関数として，例えば$fxy$があったとしよう．
関数適用が左結合であるから，これは$(fx)y$である．
ここに$(fx)$は引数$y$をとる関数であると見ることができる．
つまり，関数$f$とは引数$x$をとり「引数$y$をとって値を返す関数$(fx)$を返す」関数であると言える．

二項演算$x+y$は$$(+)xy$$とも書けたことを思い出そう．
これも左結合を思い出すと$$((+)x)y$$と書けるから，$y$という引数を$((+)x)$という関数に食わせていると解釈できる．

ラムダ式の場合は話はもっと単純で，機械的に$$\mathLambdaExpression{xy}{x+y}=\mathLambdaExpression{x}{(\mathLambdaExpression{y}{x+y})}$$のように展開するだけである．
矢印$\mathLambdaArrow$は右結合であるから，このラムダ式は括弧を省略して$$\mathLambdaExpression{xy}{x+y}=\mathLambdaExpression{x}{\mathLambdaExpression{y}{x+y}}$$とも書かれる．


\section*{余計な話：ラムダ}


\chapter{型と型クラス}

\begin{leader}
プログラマのいう型とは，数学者のいう集合のことである．
\end{leader}


\section{型}

型とは変数が取りうる値に与えた制約のことである．
数学者がよく扱う型は論理型($\mathSet{B}$)，整数型($\mathSet{Z}$)，実数型($\mathSet{R}$)といったところであろう．
ただし数学者たちは型ではなく集合と呼ぶ．
括弧内に示した記号は数学者たちが慣用的に用いているものである．

我々は計算機での実装を考慮して，数学者たちとは若干異なる型と表記方法を扱うことにする．
まず論理型($\mathSet{B}$)はそのまま論理型として$\hsklBool$で表す．

計算機にとって都合の良い整数の範囲を考慮した整数型を$\hsklInt$で表す．
計算機にとって都合の良い整数の範囲とは，例えば64ビット計算機の場合$-2^{32}$から$2^{32}-1$までの範囲のことである．

計算機は残念ながら無限精度の実数を扱えない．
そこで標準精度の浮動小数点数を表す型を$\hsklFloat$で表す．

もう一つ，計算機ならではの型を導入しておこう．
それは$\hsklInt$とよく似ているが，特別に文字を扱うために考えられた型$\hsklChar$である．
文字といってもその中身は整数である．
整数ではあるが，わざわざ別な型とするのには理由がある．
歴史的には文字は小さな整数として表現されることが多かったため，計算機のメモリが高価であった時代背景もあり，メモリの節約のために文字を表す型が存在した．
現在では，文字が数値にエンコードされる方式がより複雑になってきたために，文字を通常の数値と区別するために特別な型が用意さてれいる．

\begin{table}
\caption{単位的半群}
\label{tab:monoids}
\begin{center}
\begin{tabular}{||c||c|c||}
\hline
型クラス
    &\multicolumn{2}{|c||}{$\hsklMonoid$}\\
\hline\hline
型$\backslash$演算子と単位元
    &演算子
    &単位元\\
\hline
$\typechar$
    &---
    &---\\
\hline
$\hsklBool$
    &$\vee$
    &$F$\\
\hline
$\hsklBool$
    &$\wedge$
    &$T$\\
\hline
$\hsklInt$
    &$+$
    &$0$\\
\hline
$\hsklInt$
    &$*$
    &$1$\\
\hline
$\hsklFloat$
    &$+$
    &$0$\\
\hline
$\hsklFloat$
    &$*$
    &$1$\\
\hline
\end{tabular}
\end{center}
\end{table}

\section{関数の型}

関数にも型がある．
例えば整数引数を一つ取り，整数を返す関数$f$は$$f\mathIn\mathMorph{\hsklInt}{\hsklInt}$$という型を持つ．

整数引数を二つ取り，整数を返す関数$f'$は$$f'\mathIn\mathMorphII{\hsklInt}{\hsklInt}{\hsklInt}$$という型を持つ．
これは$$f'\mathIn\mathMorphIIWithParenthesis{\hsklInt}{\hsklInt}{\hsklInt}$$と同じ意味である．

\begin{table*}
\caption{型と型クラス}
\label{tab:type-and-typeclass}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c|c|c|c|c|c|c||}
\hline
\multirow{4}{*}{型クラス}
    &\multicolumn{12}{|c||}{$\hsklIntegral$}\\
\cline{2-13}
\multirow{3}{*}{}
    &\multicolumn{10}{|c|}{$\hsklReal$}
    &\multicolumn{2}{|c||}{$\hsklEnum$}\\
\cline{2-11}
\multirow{2}{*}{}
    &\multicolumn{5}{|c|}{$\hsklOrd$}
    &\multicolumn{5}{|c|}{$\hsklNum$}
    &\multicolumn{2}{|c||}{ }\\
\cline{2-2}\cline{7-7}
{ }
    &$\hsklEq$
    &\multicolumn{4}{|c|}{ }
    &$\hsklEq$
    &\multicolumn{4}{|c|}{ }
    &\multicolumn{2}{|c||}{ }\\
\hline\hline
型$\backslash$演算子
    &$\equiv$
    &$<$
    &$\le$
    &$\ge$
    &$>$
    &$\equiv$
    &$+$
    &$-$
    &$*$
    &$/$
    &$\hsklPred$
    &$\hsklSucc$\\
\hline
$\typechar$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---
    &---
    &---
    &$\checkmark$
    &$\checkmark$\\
\hline
$\typebool$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---
    &---
    &---
    &$\checkmark$
    &$\checkmark$\\
\hline
$\typeint$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$\\
\hline
$\typefloat$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---\\
\hline
\end{tabular}
\end{center}
\end{table*}

\section{型クラス}

組み合わせ$\mathMonoid{\hsklInt}{+}{0}$は単位的半群である．
同様に$\mathMonoid{\hsklInt}{*}{1}$, $\mathMonoid{\hsklFloat}{+}{0}$, $\mathMonoid{\hsklFloat}{*}{1}$, $\mathMonoid{\hsklBool}{\vee}{F}$, $\mathMonoid{\hsklBool}{\wedge}{T}$ も単位的半群である．
そこで，任意の型$\hsklType{a}$について，組み合わせ$\mathMonoid{\hsklType{a}}{\mathAnyBinaryOperator}{O}$が単位的半群である場合には$$\mathMonoid{\hsklType{a}}{\mathAnyBinaryOperator}{O}\mathIn\hsklMonoid$$と書くことにする．
二項演算子，単位元が自明な場合は簡略化して$$\hsklType{a}\mathIn\hsklMonoid$$と書くことにする．
これまで出てきた型を表\ref{tab:monoids}にまとめた．

このような型をより抽象化した型のようなものを\keyword{型クラス}と呼ぶ．
単位的半群は型クラスの例である．
表\ref{tab:monoids}に型と対応する単位的半群の単位元，演算子の一覧を示す．

もっと身近な型クラスもある．
例えば，型$\hsklType{a}$の変数どうしの間で等値性が定義されている場合，その型は型クラス$\hsklEq$に属することになる．
型クラス$\hsklEq$に属する型は等値演算子$\equiv$を提供する．

型$\hsklType{a}$の変数どうしの間で大小関係が定義されている場合，かつその型が型クラス$\hsklEq$に属する場合，その型は型クラス$\hsklOrd$にも属する．
型クラス$\hsklOrd$に属する型は比較演算子$<,\le,\ge,>$を提供する．

型$\hsklType{a}$の変数どうしの間で四則演算関係が定義されている場合，かつその型が型クラス$\hsklEq$に属する場合，その型は型クラス$\hsklNum$にも属する．
型クラス$\hsklNum$に属する型は比較演算子$+,-,*,/$を提供する．

型$\hsklType{a}$が型クラス$\hsklOrd$及び型クラス$\hsklNum$に属しているとき，かつそのときに限り，型$\hsklType{a}$は型クラス$\hsklReal$にも属する．

型$\hsklType{a}$の変数について，一つ小さい値を返す関数$\hsklPred$と一つ大きい値を返す関数$\hsklSucc$が定義されているとき，かつそのときに限り，型$\hsklType{a}$は型クラス$\hsklEnum$に属する．

型$\hsklType{a}$が型クラス$\hsklReal$及び型クラス$\hsklEnum$に属しているとき，かつそのときに限り，型$\hsklType{a}$は型クラス$\hsklIntegral$にも属する．

これらの関係を表にまとめたものが表\ref{tab:type-and-typeclass}である．

\section*{余計な話}

\chapter{コンテナ}

\begin{leader}
型から作る型をコンテナと呼ぶ．
代表的なコンテナはある型のホモジニアスな配列であるリストである．
この章ではリストと，リストに対する重要な演算である畳み込み，マップを取り扱う．
\end{leader}

\section{リスト}

同じ型の値を一列に並べたもの，つまりホモジニアスな配列のことを\keyword{リスト}と呼ぶ．
例えば$0$から始まり$9$まで続く整数のリストは$[0,1,2,3,4,5,6,7,8,9]$と書く．
等差数列に限って，簡略化した書き方が許される．
$0$から$9$までのリストは$[0,1\dots9]$と書いても良い．
複数の型の要素が混在してもよい配列のことをヘテロジニアスな配列と呼び，ホモジニアスな配列とは区別する．

リストは変数に代入できる．
今後，リストを指す変数にはバーをつけて$\hsklList{l}$と書くことにして$$\hsklList{l}=[0,1\dots9]$$のように書くことにしよう．

より高度なリスト，例えば$0$から$9$までの平方数のリストは$$\left[x^2\mathGuard{x\mathFrom{[0,1\dots9]}}\right]$$のようにガードを用いて書く．
ここに右辺のリストから一つずつ要素を取り出して左辺に代入する演算子$\mathFrom$を用いた．

ガードの中の式は複数あっても良い．
例えば$$\left[x+y\mathGuard{x\mathFrom[0,1\dots9],\,y\mathFrom[0,1\dots5],\,x+y>3}\right]$$は$0\le x\le 10$かつ$0\le y\le 5$の範囲で$x+y>3$となる$x$及び$y$から$x+y$を並べたリストである．

リストは\keyword{結合}できる．
例えばリスト$\hsklList{l}$とリスト$\hsklList{m}$を結合したリストは$$\hsklList{l}\hsklAppend\hsklList{m}$$で得られる．

リストは無限個の要素を持っても良い．
例えば自然数全体を表すリスト$\hsklList{n}$は$$\hsklList{n}=[1,2\dots]$$のように定義して良い．

\keyword{空リスト}は$\hsklEmptyList$で表す．

任意の型を$\hsklType{a}$とするとき，$\hsklType{a}$型のリスト型を$\hsklListType{\hsklType{a}}$と書く．
型$\hsklType{a}$から型$\hsklListType{\hsklType{a}}$を生成する演算子を\keyword{リスト型コンストラクタ}と呼んで$\hsklListConstructor$と書き$$\hsklListType{\hsklType{a}}=\hsklTypeConstruct{\hsklListConstructor}{\hsklType{a}}$$とする．
この等式の両辺は変数ではなく型名であることに注意しよう．

$\hsklType{a}$型の変数$x$を入れた$\hsklListType{\hsklType{a}}$型のリストを作る演算子を\keyword{リスト値コンストラクタ}と呼ぶ．
変数$l$がリストであることを示すために今後$\hsklList{l}$と印をつけることとして，$\hsklType{a}$型の変数$x$からリスト値コンストラクタを使ってリスト$\hsklList{l}$を作ることは$$\hsklList{l}=[x]$$と書く．

ある型を包み込んだ別の型を一般に\keyword{コンテナ型}または単に\keyword{コンテナ}と呼ぶ．

\section{畳み込み}

我々はよくリストの総和を表現するためにシグマ記号($\sum$)を使う．
リスト$[x_0,x_1\dots x_n]$の総和を$$\sum[x_0,x_1\dots x_n]=x_0+x_1+\dotsb+x_n$$とするようなシグマ記号である．
この表現を一般化してみよう．
リスト$[x_0,x_1\dots x_n]$が与えられたとき，$$\mathFold^{\mathAnyBinaryOperator}_{a}[x_0,x_1\dots x_n]=a\mathAnyBinaryOperator x_0\mathAnyBinaryOperator x_1\mathAnyBinaryOperator\dotsb\mathAnyBinaryOperator x_n$$であると定義する．
この新しい記号$\mathFold$は\keyword{畳み込み演算子}と呼ばれる．
変数$a$はアキュムレータと呼ぶ．
アキュムレータは右側の引数が空であった場合のデフォルト値と考えても良い．

リストの総和をとる演算子$\sum$は$$\sum=\mathFold^+_0$$とすれば得られる．
同じようにリストの要素のすべての積をとる演算子$\prod$は$$\prod=\mathFold^*_1$$とすれば得られる．

畳み込み演算子は第1（上）引数に$\hsklType{a}$型と$\hsklType{b}$型の引数を取り$\hsklType{a}$型の戻り値を返す二項演算子，第2（下）引数に$\hsklType{a}$型，第3（右）引数に$\hsklType{b}$型のリストすなわち$\hsklListType{\hsklType{b}}$型を取り，$\hsklType{a}$型の値を返す．
従って畳み込み演算子の型は$$\mathFold\mathIn\mathMorphIII{(\mathMorphII{\hsklType{a}}{\hsklType{b}}{\hsklType{a}})}{\hsklType{a}}{\hsklListType{\hsklType{b}}}{\hsklType{a}}$$と定義できる．

畳み込み演算子には次のようなもう一つのバリエーションがある．
$$\mathFoldRight^{\mathAnyBinaryOperator}_{a}[x_0,x_1\dotsb x_n]=\left(x_0\mathAnyBinaryOperator\left(x_1\mathAnyBinaryOperator\dotsb\mathAnyBinaryOperator\left(x_n\mathAnyBinaryOperator a\right)\right)\right)$$
これは右畳み込みと呼ばれる演算子である．

畳み込み演算子の面白い応用例を示そう．
$$\mathFold_\hsklEmptyList^\hsklAppend[[0,1,2],[3,4,5],\dots]=[0,1,2,3,4,5,\dots]$$
であるから，演算子$$\mathFold_\hsklEmptyList^\hsklAppend$$はリストを平坦化する\keyword{平坦化演算子}である．
平坦化演算子はconcat演算子とも呼ばれることもあるが，基本的な演算子であるため特別な記号をつけておこう．
我々は$$\hsklConcat=\mathFold_\hsklEmptyList^\hsklAppend$$と定義することにする．

\section{マップ}

リストの各要素に決まった関数を適用したい場合がある．
引数として関数$f$とリスト$[x_0,x_1\dots x_n]$を取り，戻り値として$[fx_0,fx_1\dots fx_n]$を返す演算子$\hsklMap$を考えよう．
このとき$$f\hsklMap[x_0,x_1\dots x_n]=[fx_0,fx_1\dots fx_n]$$であると定義する．
この$\hsklMap$演算子を\keyword{マップ演算子}と呼ぶ．

マップ演算子の型は
$$\hsklMap\hsklOf{}\mathMorphII{(\mathMorph{\hsklType{a}}{\hsklType{b}})}{\hsklListType{\hsklType{a}}}{\hsklListType{\hsklType{b}}}$$
である．
矢印$\mathMapsTo$は右結合なので，これは$$\hsklMap\hsklOf{}\mathMorph{(\mathMorph{\hsklType{a}}{\hsklType{b}})}{(\mathMorph{\hsklListType{\hsklType{a}}}{\hsklListType{\hsklType{b}}})}$$の意味でもある．
ここで$f$と$f\hsklMap$の型を並べてみると
\begin{align*}
f&\mathIn\mathMorph{\hsklType{a}}{\hsklType{b}}\\
f\hsklMap&\mathIn\mathMorph{\hsklListType{\hsklType{a}}}{\hsklListType{\hsklType{b}}}
\end{align*}
となり，マップ演算子が何をしているのか一目瞭然になる．

\section*{余計な話}

\chapter{コンテナの高度な話題}

\begin{leader}
a
\end{leader}


\section{Maybe}

整数$x$を$0$で除算することはエラーである．
しかし除算の度にエラーが起こったかどうか調べるのは面倒であるし，記述も煩雑になってしまう．
プログラマはよくこういう場合に「例外」という機構を用いるが，数学に例外は持ち込みたくない．
そこで変数$x$が正しく計算されたかもしれないし，されていないかもしれないということを，$\hsklMaybe{m}$のように印をつけた別の変数に入れて，忘れないようにしておこう．
ここで変数$\hsklMaybe{m}$が取り得る値は正しく計算された値$x$か，あるいはエラーを表す値$\hsklNothing$である．

この変数$\hsklMaybe{m}$はもはや整数型とは言えない．
そこでこの$\hsklMaybe{m}$の型を$\hsklMaybeType{\hsklInt}$と表して「きっと整数」型と呼ぶことにしよう．
型$\hsklType{a}$から型$\hsklMaybeType{\hsklType{a}}$を生成する型コンストラクタを$\hsklMaybeConstructor$と呼び$$\hsklMaybeType{\hsklType{a}}=\hsklTypeConstruct{\hsklMaybeConstructor}{\hsklType{a}}$$とする．

$\hsklType{a}$型の変数を$\hsklMaybeType{\hsklType{a}}$型の変数に代入するには，次の値コンストラクタを用いる．
$$\hsklMaybe{m}=\hsklJust{x}$$

変数$x$が一度$0$除算の危険性に汚染された場合，その後ずっと$\hsklMaybe{m}$というコンテナに入れ続けなければいけない．
このきっと整数$\hsklMaybe{m}$に対して整数を引数にとる関数$f$を適用させるには，何らかの関数マップ演算子が必要である．
そこできっと整数の中身に直接関数を適用する演算子を$\hsklMaybeMap$としよう．
具体的には$$f\hsklMaybeMap\hsklMaybe{m}=\hsklMaybeW{fx}$$のように関数$f$を変数$\hsklMaybe{m}$に適用させる．
その結果はまた$\hsklMaybeType{\hsklInt}$型である．

具体例として「安全な」割り算演算子$\div$を定義してみよう．
ここで
\begin{equation*}
\hsklMaybe{m}\div y=\begin{cases}\hsklJust{x/y}&\mathIf m\neq\hsklNothing\mathAnd y\neq0\\
\hsklNothing&\mathOtherwise\end{cases}
\end{equation*}
とする．
ただし$\hsklMaybe{m}$は$\hsklJust{x}$か，あるいは$\hsklNothing$かのどちらかの値が入っている．
$x\neq\hsklNothing$かつ$y\neq0$のときの戻り値が$x/y$ではなく$\hsklJust{x/y}$なのは，計算結果が汚染の可能性を持つからである．

さて，我々が欲しいのは$$\hsklMaybe{m}\div y=(\mathLambdaAnonymousParameter/y)\hsklMaybeMap\hsklMaybe{m}$$であるようなMaybeバージョンのマップ演算子である．
その実装は実はいたって単純で
\begin{align*}
f\hsklMaybeMap\hsklJust{x}&=\hsklJust{fx}\\
f\hsklMaybeMap\hsklNothing&=\hsklNothing
\end{align*}
である．

% 従って，結果を受け取る変数も$\typeconstructor{\typemaybe}{\typeint}$型でなければならず，それを忘れないように印を付けておかねばならない．
% 例えば$$\maybetype{y}=f\binarymaybefunctormap\maybetype{x}$$のように書くことになるであろう．

% $$(\typeconstructor{\typemaybe}{\typename{a}},\binarymaybeappend,\constantnothing)$$
% \boxplus == \boxdot???

---

\section{リストの実装}

ここでリストの実装について若干述べておかねばならない．
紙上ではリストは自由に考えられるが，計算機上ではそれほど自由ではないからである．
ここではリストはLISPにおけるリストと同じ構造を持つものとする．
LISPにおけるリストとは要素$\mathFirst$と要素$\mathRest$からなるペアの集合である．
要素$\mathFirst$がリストの要素を持ち，要素$\mathRest$が次のペアを参照する．
リストの最後のペアの$\mathRest$は空リストを参照する．

リストのための特別な表現$$\mathFirst:\mathRest$$を用い，第1要素$\mathFirst$はリストが保持する型，第2要素$\mathRest$はリスト型であるとする．
演算子$:$を\keyword{結合演算子}と呼ぶ．

要素$\mathRest$はリストまたは空リストであるから，一般にリストは次のように展開できることになる．
\begin{align*}
[x_0,x_1,x_2\rangedots x_n]&=x_0:[x_1,x_2\rangedots x_n]\\
&=x_0:x_1:[x_2\rangedots x_n]\\
&=x_0:x_1:x_2:\dots:x_n:\hsklEmptyList
\end{align*}
結合演算子$:$は右結合する．
すなわち$$x_0:x_1:x_2=x_0:(x_1:x_2)$$である．

マップ演算子の実装は，リストの実装に踏み込めば簡単である．
空でないリストは必ず$x:\hsklList{y}$へと分解できるから
\begin{align*}
f\hsklMap x:\hsklList{y}&=fx:f\hsklMap\hsklList{y}\\
f\hsklMap\hsklEmptyList&=\hsklEmptyList
\end{align*}
とマップ演算子$\hsklMap$を定義できる．

\section*{余計な話：単位的半群としてのコンテナ}

$$\mathMonoid{\hsklListType{\hsklType{a}}}{\hsklAppend}{\hsklEmptyList}$$

$$\mathMonoid{\hsklMaybeType{\hsklType{a}}}{\hsklMaybeAppend}{\hsklNothing}$$


% \section{コンテナの型クラスと種}



\chapter{関手}

\section{関手}

圏$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$があるとする．
ここに集合$\mathSet{C}$は射の\keyword{対象}となる集合の集合であり，集合$\mathSet{P}$は射の集合である．

ここにもう一つの圏$\mathCategoryShort{\mathSet{C}'}{\mathSet{P}'}$があるとする．
対象$\mathSet{C}$の各元と対象$\mathSet{C}'$の各元の間に一対一対応があり，また射$\mathSet{F}$の各元と射$\mathSet{P}'$の各元の間に一対一対応があるとき，圏$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$から圏$\mathCategoryShort{\mathSet{C}'}{\mathSet{P}'}$への「射」が存在する．
この射を\keyword{関手}と呼ぶ．

‥と書いても抽象的すぎるので，具体例を見ていこう．
例えば$\hsklInt$型の演算子$+$は$\hsklInt\mathSetTimes\hsklInt$から$\hsklInt$への写像なので，$\hsklInt\mathSetTimes\hsklInt$と$\hsklInt$からなる集合$\mathSet{C}$と，演算子$+$だけからなる集合$\mathSet{P}$からなる組み合わせ$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$は圏である．

一方で$\hsklListType{\hsklInt}$型もリスト内の個々の$\hsklInt$型変数に対しては$+$演算子が有効だ．
そこで$\hsklInt\mathSetTimes{}\hsklListType{\hsklInt}$と$\hsklListType{\hsklInt}$からなる集合を$\mathSet{C}'$とし，リスト内の個々の要素に作用する$+$演算子単独の集合を$\mathSet{P}'$とする．
事実我々はすでにマップ演算子$\hsklMap$を持っているので，リスト内の個々の要素に作用する$+$演算子を作るのはわけない．
ということは，$\hsklInt$型から$\hsklListType{\hsklInt}$型を作る型コンストラクタ$\hsklListConstructor$とマップ演算子$\hsklMap$があれば，圏$\mathCategoryShort{\mathSet{C}}{\mathSet{P}}$から圏$\mathCategoryShort{\mathSet{C}'}{\mathSet{P}'}$へとジャンプできるのである．

型コンストラクタ$\hsklListConstructor$とマップ演算子$\hsklMap$の組み合わせ$(\hsklListConstructor,\hsklMap)$は関手の一例である．

同じことが型コンストラクタ$\hsklMaybeConstructor$とMaybeバージョンのマップ演算子$\hsklMaybeMap$の組み合わせ$(\hsklMaybeConstructor,\hsklMaybeMap)$にも言える．

そこでマップ演算子$\hsklMap$，Maybeバージョンのマップ演算子$\hsklMaybeMap$をひとくくりにして一般化マップ演算子$\hsklFmap$とする．
一般化マップ演算子は，右引数がリストであればマップ演算子を，右引数がMaybeであればMaybeバージョンのマップ演算子に「化ける」ものとする．

---

\section{関数と関手の関係}


\section{アプリカティブ関手}

関手の一般化マップ演算子をさらに汎用性のあるものにするために，二つの要素に分解する．
その要素とはpure演算子と$\hsklApplicativeMap$演算子である．
関手との後方互換性は$$f\hsklFmap x=\hsklPure{f}\hsklApplicativeMap x$$として確保する．


一般化マップ演算子が「普通の関数」$f$をコンテナの中の変数に適用するのに対し，アプリカティブマップ演算子はコンテナの中の関数をコンテナの中の変数へ適用する．

リストに対するアプリカティブマップ演算子$\hsklApplicativeListMap$は左引数のリスト内のすべての関数を順番に右引数のリスト内の変数に適用し，その結果をリストとして返す．

例えば$$[f,g,h]\hsklApplicativeMap[x,y,z]$$とした場合，左引数，右引数ともリストであるため$$[f,g,h]\hsklApplicativeMap[x,y,z]=[f,g,h]\hsklApplicativeListMap[x,y,z]$$となり，その結果は
\begin{align*}
[f,g,h]\hsklApplicativeMap[x,y,z]&=[f,g,h]\hsklApplicativeListMap[x,y,z]\\
&=[fx,fy,fz,gx,gy,gz,hx,hy,hz]
\end{align*}
である．

% 実装

\begin{align*}
(f:\hsklList{g})\hsklApplicativeListMap\hsklList{x}&=\hsklConcat(f\hsklMap\hsklList{x}:\hsklList{g}\hsklApplicativeListMap\hsklList{x})\\
\hsklEmptyList\hsklApplicativeListMap\hsklList{x}&=\hsklEmptyList
\end{align*}



\chapter{モナド}

\section{もう一つの関手}

$$f\cdot\Bar x=f'\mathop\heartsuit\Bar x$$

$$f'=\begin{cases}\langle\text{result}\rangle&\text{if nothing happened}\\
\text{some context}&\text{when something happened}\end{cases}$$

\section{モナドな関数}


\section{モナド則}

\section*{余計な話：モノイドなモナド}


\begin{table*}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c|c||}
\hline
\multirow{2}{*}{型クラス}
    &\multicolumn{3}{|c|}{$\hsklApplicative$}
    &\multicolumn{4}{|c||}{$\hsklMonadplus$}\\
\cline{4-8}
\multirow{1}{*}{}
    &\multicolumn{2}{|c|}{ }
    &$\hsklFunctor$
    &\multicolumn{2}{|c}{$\hsklMonad$}
    &\multicolumn{2}{|c||}{$\hsklMonoid$}\\
\hline\hline
型$\backslash$要素と演算子
    &$\applicativetype{x}$
    &$\binaryapplicativemap$
    &$\binaryfunctormap$
    &$\langle x\rangle_\mathsf{m}$
    &$\binarymonadmap$
    &$\mathidentity$
    &$\mathbinaryop$\\
\hline
リスト
    &$[x]$
    &$\binarylistapplicativemap$
    &$\binarylistfunctormap$
    &$[x]_\mathsf{m}$
    &$\clubsuit$
    &$\constantempty$
    &$\binarylistappend$\\
\hline
Maybe
    &$\[x\]$
    &$\binarymaybeapplicativemap$
    &$\binarymaybefunctormap$
    &$\[x\]_\mathsf{m}$
    &$\spadesuit$
    &$\constantnothing$
    &$\binarymaybeappend$\\
\hline
関数
    &$\langle\!\langle x\rangle\!\rangle$
    &$\binaryfunctionapplicativemap$
    &$\binaryfunctionfunctormap$
    &$\langle\!\langle x\rangle\!\rangle_\mathsf{m}$
    &$\circ$
    &$\anonymousparameter$
    &$\binarycompose$\\
\hline
Int（参考）
    &
    &
    &
    &
    &
    &$0$
    &$\binaryadd$\\
\hline
\end{tabular}
\end{center}
\end{table*}

\begin{table*}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c||}
\hline
\multirow{4}{*}{型クラス}
    &\multicolumn{6}{|c||}{$\hsklMonadplus$}\\
\cline{2-7}
\multirow{3}{*}{}
    &\multicolumn{4}{|c|}{$\hsklMonad$}
    &\multicolumn{2}{|c||}{$\hsklMonoid$}\\
\cline{2-4}
\multirow{2}{*}{}
    &\multicolumn{3}{|c|}{$\hsklApplicative$}
    &
    &\multicolumn{2}{|c||}{ }\\
\cline{2-2}
{ }
    &\multicolumn{1}{|c|}{$\hsklFunctor$}
    &\multicolumn{2}{|c|}{ }
    &
    &\multicolumn{2}{|c||}{ }\\
\hline\hline
型$\backslash$要素と演算子
    &$\binaryfunctormap$
    &$\applicativetype{x}$
    &$\binaryapplicativemap$
    &$\binarymonadmap$
    &$\mathidentity$
    &$\mathbinaryop$\\
\hline
リスト
    &$\binarylistfunctormap$
    &$\listtype{x}$
    &$\binarylistapplicativemap$
    &$\binarylistmonadmap$
    &$\constantempty$
    &$\binarylistappend$\\
\hline
Maybe
    &$\binarymaybefunctormap$
    &$\maybetype{x}$
    &$\binarymaybeapplicativemap$
    &$\binarymaybemonadmap$
    &$\constantnothing$
    &$\binarymaybeappend$\\
\hline
関数
    &$\binaryfunctionfunctormap$
    &$\functyontype{x}$
    &$\binaryfunctionapplicativemap$
    &$\binaryfunctionmonadmap$
    &$\anonymousparameter$
    &$\binarycompose$\\
\hline
Int（参考）
    &
    &
    &
    &
    &$0$
    &$\binaryadd$\\
\hline
\end{tabular}
\end{center}
\end{table*}

\part{モナドから見る世界}

\chapter{IO}

\chapter{例外}

\chapter{乱数}

\chapter{状態}

\chapter{非決定性}

\chapter{継続}

\chapter{X}

\chapter{Y}

\chapter{Z}


\part{圏とモナド}


\end{document}
