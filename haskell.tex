\documentclass[twocolumn]{jsbook}
\usepackage{amsmath,amssymb,ascmac,bm,multirow}

\title{プログラムにおける代数構造}
\author{Ichi Kanaya}
\date{2016}

\def\[{[\![}
\def\]{]\!]}

\newcommand{\keyword}[1]{\emph{#1}}
\newenvironment{leader}{\begingroup\gt}{\endgroup}
\newenvironment{point}{\begin{screen}}{\end{screen}}

% Lambda
\newcommand{\lambdasym}{\backslash}
\newcommand{\lambdadot}{\rightarrow}
\newcommand{\lambdaexp}[2]{\lambdasym#1\lambdadot#2}
\newcommand{\lambdacut}{\lozenge}

% Typeclasses
\newcommand{\typeclassname}[1]{\mathfrak{#1}}
\newcommand{\typeclassapplicative}{\typeclassname{Applicative}}
\newcommand{\typeclassbounded}{\typeclassname{Bounded}}
\newcommand{\typeclassenum}{\typeclassname{Enum}}
\newcommand{\typeclasseq}{\typeclassname{Eq}}
\newcommand{\typeclassfunctor}{\typeclassname{Functor}}
\newcommand{\typeclassintegral}{\typeclassname{Integral}}
\newcommand{\typeclassmonad}{\typeclassname{Monad}}
\newcommand{\typeclassmonadplus}{\typeclassname{Monadplus}}
\newcommand{\typeclassmonoid}{\typeclassname{Monoid}}
\newcommand{\typeclassnum}{\typeclassname{Num}}
\newcommand{\typeclassord}{\typeclassname{Ord}}
\newcommand{\typeclassreal}{\typeclassname{Real}}

% Types
\newcommand{\typename}[1]{\mathbf{#1}}
\newcommand{\typeconstructor}[2]{\mathop{#1}#2}
\newcommand{\typebool}{\typename{Bool}}
\newcommand{\typechar}{\typename{Char}}
\newcommand{\typefunction}{\typename{Function}}
\newcommand{\typeint}{\typename{Int}}
\newcommand{\typefloat}{\typename{Float}}
\newcommand{\typelist}{\typename{List}}
\newcommand{\typemaybe}{\typename{Maybe}}

% Morph
\newcommand{\morph}[2]{#1\mapsto#2}
\newcommand{\mmorph}[3]{#1\mapsto#2\mapsto#3}
\newcommand{\mmorphwithparenthesis}[3]{#1\mapsto(#2\mapsto#3)}
\newcommand{\mmmorph}[4]{#1\mapsto#2\mapsto#3\mapsto#4}

% Constants
\newcommand{\constantname}[1]{\mathrm{#1}}
\newcommand{\constanttrue}{\constantname{T}}
\newcommand{\constantfalse}{\constantname{F}}
\newcommand{\constantempty}{\emptyset}
\newcommand{\constantnothing}{\varnothing}

% Parameters
\newcommand{\anonymousparameter}{\lozenge}

% Identities
\newcommand{\identity}{\mathnormal{I}}
\newcommand{\identityfunctor}{\mathcal{I}}
\newcommand{\identityfunction}{\anonymousparameter}

% Unary ops.
\newcommand{\unarypred}{\blacktriangleleft}
\newcommand{\unarysucc}{\blacktriangleright}

% Binary ops.
\newcommand{\binaryeq}{\equiv}
\newcommand{\binaryl}{<}
\newcommand{\binaryle}{\le}
\newcommand{\binaryge}{\ge}
\newcommand{\binaryg}{>}
\newcommand{\binaryadd}{+}
\newcommand{\binarysub}{-}
\newcommand{\binarymultiply}{*}
\newcommand{\binarydivide}{/}
\newcommand{\binaryor}{\vee}
\newcommand{\binaryand}{\wedge}
\newcommand{\binarycompose}{\bullet}
\newcommand{\binaryfunctormap}{\cdot}
\newcommand{\binaryapplicativemap}{\times}
\newcommand{\binarymonadmap}{\Leftarrow}
\newcommand{\binarylistfunctormap}{\odot}
\newcommand{\binarylistapplicativemap}{\otimes}
\newcommand{\binarylistmonadmap}{\hookleftarrow}
\newcommand{\binarylistappend}{\oplus}
\newcommand{\binarymaybefunctormap}{\boxdot}
\newcommand{\binarymaybeapplicativemap}{\boxtimes}
\newcommand{\binarymaybemonadmap}{\leftleftarrows}
\newcommand{\binarymaybeappend}{\boxplus}
\newcommand{\binaryfunctionfunctormap}{\binarycompose}
\newcommand{\binaryfunctionapplicativemap}{\bowtie}
\newcommand{\binaryfunctionmonadmap}{\twoheadleftarrow}
\newcommand{\binaryapply}{\mathop{\$}}
\newcommand{\binaryconcat}{:}

% Functions
\newcommand{\functionpred}{\mathop{\text{pred}}}
\newcommand{\functionsucc}{\mathop{\text{succ}}}

% Parenthesis ops.
\newcommand{\applicativetype}[1]{\left\langle#1\right\rangle}
\newcommand{\listtype}[1]{\left[#1\right]}
\newcommand{\maybetype}[1]{\left\{#1\right\}}
\newcommand{\functyontype}[1]{\[#1\]}

% Guard
\newcommand{\guard}[1]{\mathop{\mid_{#1}}}
\newcommand{\guardcomma}{,\,}

% Range
\newcommand{\isin}{\in}
\newcommand{\rangedots}{\dots}
\newcommand{\infinitydots}{\dots}

% Type and class
\newcommand{\istypeof}{\mathop{::}}
\newcommand{\isclassof}{\subset}

% Keywords
\newcommand{\keywordname}[1]{\mathbf{#1}}
\newcommand{\keywordotherwise}{\keywordname{otherwise}}
\newcommand{\keywordif}{\mathop{\keywordname{if}}}
\newcommand{\keywordthen}{\mathop{\keywordname{then}}}
\newcommand{\keywordelse}{\mathop{\keywordname{else}}}

% Special words
\newcommand{\specialwordname}[1]{\mathsf{#1}}
\newcommand{\specialwordfirst}{\specialwordname{First}}
\newcommand{\specialwordrest}{\specialwordname{Rest}}

% Math
\newcommand{\mathbinaryop}{\circ}
\newcommand{\mathidentity}{\mathnormal{I}}
\newcommand{\mathsetname}[1]{\mathbb{#1}}
\newcommand{\mathtriple}[3]{(#1,#2,#3)}
\newcommand{\mathcompose}{\bullet}
\newcommand{\mathfold}{\bigcup}
\newcommand{\mathfoldright}{\bigsqcup}

\begin{document}
\maketitle
\tableofcontents

\part{代数構造とプログラミング}

\chapter{はじめに}

Haskellというプログラミング言語を知ろうとすると，従来のプログラミング言語の知識が邪魔をする．
モダンで，人気があって，Haskellから影響を受けた言語，例えばRubyやSwiftの知識さえ，Haskellを学ぶ障害になり得る．
ではどのようにしてHaskellの深みに到達すればいいのだろうか．

その答えは，一見遠回りに見えるが，一度抽象数学の高みに登ることである．

と言っても，あわてる必要はない．

近代的なプログラミング言語を知っていれば，すでにある程度抽象数学に足を踏み入れているからである．

\chapter{数学的準備}

\begin{leader}
この章では代表的な代数構造であり，またプログラミングとも深い関わりのあるモノイドと群について述べる．
モノイドは別名を単位的半群と言う通り，群の制約を緩めたバージョンとも言える．
数学ではモノイドや群のように，ある集合と，集合の元同士の関係に性質を見出し，それに名前をつけることがしばしばある．
本書ではこのように抽象的な性質を抜き出すことを今後繰り返す．
\end{leader}

\section{モノイド}

整数全体の\keyword{集合}を$\mathsetname{Z}$で表すこととしよう．
集合$\mathsetname{Z}$には$0$や$-10$や$123$などのありとあらゆる整数が含まれている．
任意の変数$x$が整数であることを，数学者は$x\in\mathsetname{Z}$という風に書き，$x$が集合$\mathsetname{Z}$の\keyword{元}であると呼ぶ．
我々は記号$\in$を別の用途に使いたいので代わりに記号$\istypeof$を使って$x\istypeof\mathsetname{Z}$と書くことにする．

二つの整数$$x,y\istypeof\mathsetname{Z}$$の間には\keyword{二項演算}が定義されている．
例えば足し算は二項演算の例で，それを表現するために\keyword{演算子}$+$がある．
整数$x,y$に足し算演算子を\keyword{作用させる}と，つまり$x+y$を作ると，その結果は再び整数になる．
これを$$x+y\istypeof\mathsetname{Z}$$と書く．
いま「演算子」を「作用」させたのだが，これはそれぞれ英語の ``operator'' と ``operate'' の訳である．
数学者や物理学者は演算子のことを\keyword{作用素}と呼ぶ場合もあるが，意味は同じである．

演算子$\binaryadd$は演算の順序によらず結果が同じである．
いま三つの整数$$x,y,z\istypeof\mathsetname{Z}$$があるとき$$x+(y+z)=(x+y)+z$$であるが，このように右を先に計算しても左を先に計算しても結果が変わらないことを\keyword{結合性}と呼ぶ．
また，結合性があることを求める規則を\keyword{結合則}と呼ぶ．
整数の足し算は結合則に従う．\footnote{足し算にはもう一つ$x+y=y+x$という性質があり，これを可換性と呼ぶが，今は考えなくて良い．}

整数の足し算にはもう一つの際立った特徴がある．
それは$0,x\istypeof\mathsetname{Z}$のとき$$0+x=x+0=x$$であるような$$0\istypeof\mathsetname{Z}$$が存在することだ．
このように足し算を行っても結果を変えなような元のことを\keyword{単位元}と呼ぶ．
特に足し算の場合は単位元のことを\keyword{零元}と呼ぶこともある．

さて，これらの性質を一般化してみよう．
集合$\mathsetname{M}$の元$x,y,z\istypeof\mathsetname{M}$とそれらの間の二項演算子$\mathbinaryop$が，
\begin{align}
x\mathbinaryop y\istypeof\mathsetname{M}\\
x\mathbinaryop(y\mathbinaryop z)=(x\mathbinaryop y)\mathbinaryop z&\dots\text{結合則}\\
{}^\exists\mathidentity:\mathidentity\mathbinaryop x=x\mathbinaryop\mathidentity=x&\dots\text{単位元の存在}
\end{align}
を満たしているとき，組み合わせ$\mathtriple{\mathsetname{M}}{\mathbinaryop}{\mathidentity}$を\keyword{モノイド}と呼ぶ．

先ほど見たように整数の集合$\mathsetname{Z}$と足し算演算子$+$と整数の$0$の組み合わせ$\mathtriple{\mathsetname{Z}}{+}{0}$はモノイドである．
整数については，掛け算演算子$*$に関しても$\mathtriple{\mathsetname{Z}}{*}{1}$がモノイドである．

他に，例えば回転角を$\theta$とする二次元の回転変換（行列）を$U(\theta)$ただし$$U(\theta)=\begin{bmatrix}\cos\theta&-\sin\theta\\\sin\theta&\cos\theta\end{bmatrix}$$として，回転変換$U$すべてからなる集合$\mathsetname{U}$を考えてみよう．

回転は合成できる．
回転の合成を$\bullet$で表すとすると
\begin{equation}
\label{eq:rotation}
U(\theta_1)\bullet U(\theta_2)=U(\theta_1+\theta_2)
\end{equation}
であるから，回転を合成した結果も回転である．

また式\eqref{eq:rotation}から$$U(\theta_1)\bullet\left(U(\theta_2)\bullet U(\theta_3)\right)=\left(U(\theta_1)\bullet U(\theta_2)\right)\bullet U(\theta_3)$$
であるから，回転変換は結合則も満たしている．

最後に回転変換に単位元があるかどうか調べてみよう．
何もしない回転変換は$0$度の回転であるから，何もしない回転を$$U_0=U(0)$$とよう．
そうすると$$U_0\bullet U(\theta)=U(\theta)\bullet U_0=U(\theta)$$であるから，$U_0$は回転変換の単位元であると言える．

このように，組み合わせ$\mathtriple{\mathsetname{U}}{\mathcompose}{U_0}$はモノイドである．

\begin{point}
集合$\mathsetname{M}$の元$x,y,z\in\mathsetname{M}$とそれらの間の二項関係$\mathbinaryop$が，
\begin{align*}
x\mathbinaryop y\istypeof\mathsetname{M}\\
x\mathbinaryop(y\mathbinaryop z)=(x\mathbinaryop y)\mathbinaryop z&\dots\text{結合則}\\
{}^\exists\mathidentity:\mathidentity\mathbinaryop x=x\mathbinaryop\mathidentity=x&\dots\text{単位元の存在}
\end{align*}
を満たしているとき，組み合わせ$\mathtriple{\mathsetname{M}}{\mathbinaryop}{\mathidentity}$をモノイドと呼ぶ．
\end{point}

\section{モノイドではないもの}
数学上の多くの構造がモノイドである．
整数や二次元の回転変換がそうであったが，一般に数と呼ばれるもの全て，また正方行列も行列の掛け算（または足し算），単位行列（または零行列）とともにモノイドになる．
ベクトルもまた，ベクトルの合成演算子，零ベクトルと組み合わせてモノイドになる．

そこで，今度は逆にモノイドでないものを考えてみよう．
例えば三次元ベクトルのベクトル積はどうだろうか．
三次元ベクトルのベクトル積は結合則が成り立たず，また単位元もないため，三次元ベクトル全体の集合とベクトル積はモノイドになることができない．

\section{群}
前述のモノイドにもう一つ規則を加えたものが群である．
群は集合$\mathsetname{G}$の元$x,y,z\in\mathsetname{G}$とそれらの間の二項関係$\mathbinaryop$について
\begin{align}
x\mathbinaryop y\istypeof\mathsetname{G}\\
x\mathbinaryop(y\mathbinaryop z)=(x\mathbinaryop y)\mathbinaryop z&\dots\text{結合則}\\
{}^\exists\mathidentity:\mathidentity\mathbinaryop x=x\mathbinaryop\mathidentity=x&\dots\text{単位元の存在}\\
{}^\exists x^{-1}:x^{-1}\mathbinaryop x=\mathidentity&\dots\text{逆元の存在}
\end{align}
であるような$\mathtriple{\mathsetname{G}}{\mathbinaryop}{\mathidentity}$のことであり，モノイドの規則に「逆元の存在」を加えたものである．
プログラマの言葉で言えば，群はモノイドの「子クラス」であると言える．

前節で紹介した$\mathtriple{\mathsetname{Z}}{+}{0},\mathtriple{\mathsetname{Z}}{*}{1},\mathtriple{\mathsetname{U}}{\mathcompose}{U_0}$は全て群でもある．

このように規則を少しずつ増やしていって，より強力な概念を構築していく方法は数学ではよく用いられる．
本書でもシンプルな規則から初めて，少しずつ規則を増やしていくやり方を多用する．

% 本書では群についてはこれ以上の深入りはしない．

\chapter{記法}

\begin{leader}
本書では一般の数学書やプログラミングの教科書からは少し異なった記法を用いる．
ある概念が発明されてからずっと後になって正しい記法が見つかり，それがきっかけとなって正しく理解されるという現象は歴史上よくあることである．
\end{leader}


\section{関数}

関数引数には括弧を付けない．我々はよく引数$x$をとる関数$f$を$f(x)$と書くが，括弧は冗長なのでいま後は$fx$と書くことにする．
引数$x$を関数$f$に「食わせる」ことを関数適用と呼ぶ．

複数引数をとる関数を我々はよく$f'(x,y)$と書くが，これも括弧が冗長なので今後は$f'xy$と書くことにする．
この場合式$f'xy$は左を優先して結合するものとする．つまり$$f'xy=(f'x)y$$である．
引数に「飢えた」関数$(fx)$を部分適用された関数と呼ぶ．

このように式の左側を優先的に演算していくことを左結合と呼ぶ．
関数適用は左結合である．

\section{演算子}

単項演算子には論理否定($\neg$)とマイナス($-$)がある．
本書で扱う単項演算子はこの2種類だけである．

二項演算子のうちよく使われるものは和($\binaryadd$)，積($\binarymultiply$)，差(${}\binarysub{}$)，商（${}\binarydivide{}$），論理和($\binaryor$)，論理積($\binaryand$)，同値($\binaryeq$)，大なり($\binaryg$)，小なり($\binaryl$)等である．
二項演算子はたとえ積記号であっても省略できない．
二項演算子は多数あるので，その都度説明する．

二項演算子は中置することが基本であるが，括弧で包むことで前置することも可能である．
任意の二項演算子$\mathbinaryop$について$$x\mathbinaryop y$$及び$$(\mathbinaryop)xy$$は全く同じ意味である．

二項演算子の結合性，すなわち左結合か右結合かは，演算子によって異なる．

演算の優先順位を明示的に与えるために括弧が用いられる．

\begin{point}
任意の二項演算子$\mathbinaryop$について$$x\mathbinaryop y=(\mathbinaryop)xy$$である．
\end{point}

\section{ラムダ式}
引数$x$をとり値$1+x$を返すラムダ式は次のように書くことにする．
$$\lambdaexp{x}{1+x}$$
この式はチャーチのオリジナルの論文の記法であれば$\Hat x\,.\,1+x$と書かれたところであり，現在でも多くの書物で$\lambda x\,.\,1+x$と記述されるところである．
しかし我々はすべてのギリシア文字を変数名のために予約しておきたいのと，ピリオド記号($.$)が今後登場する二項演算子$\cdot$と紛らわしいため，上述の記法を用いる．

ラムダ式を適用するには，ラムダ式を括弧で包む必要がある．
例を挙げる．
$$\left(\lambdaexp{x}{1+x}\right)2$$
この式は結果として$3$を返す．

複数引数をとるラムダ式は例えば$$\lambdaexp{xy}{x+y}$$のように引数を並べて書く．

記号$\lambdacut$を用いてラムダ式をより簡潔に書くこともできる．
ラムダ式$\lambdaexp{xy}{x+y}$は$$\lambdacut+\lambdacut$$と書いても良い．
式を左から読んで1番目の$\lambdacut$が元々の$x$すなわち第1引数を，2番目の$\lambdacut$が元々の$y$すなわち第2引数を意味する．

\chapter{関数}

\section{関数の定義}

ラムダ式を用いた関数の定義が可能である．
例えば引数$x$をとり値$1+x$を返す関数$f$は$$f=\lambdaexp{x}{1+x}$$と定義できる．
この省略形として$$fx=1+x$$と書いても良いし，さらに省略して$$f=(+)1$$と書いても良い．
もちろん$f=+1$でないことに注意しよう．

関数にスペシャルバージョンがある場合は列挙する．
例えば引数が$0$の場合は特別に戻り値も$0$であり，その他の場合は関数$f$と同じ振る舞いをする関数$f'$を考える．
このとき$f'$は次のように定義することになる．
\begin{equation*}
\begin{split}
f'0&=0\\
f'x&=1+x
\end{split}
\end{equation*}

関数定義に場合分けが必要な場合は「ガード」を用いる．
例えば引数の値が負の場合は$-1$を，$0$の場合は$0$を，それ以外の場合は関数$f$と同じ振る舞いをする関数$f''$は
\begin{equation*}
\begin{split}
f''x&\guard{x\binaryl0}=-1\\
&\guard{x\binaryeq0}=0\\
&\guard{\keywordotherwise}=1+x
\end{split}
\end{equation*}
という風に定義することにする．

\section{関数の合成}

関数は合成できる．関数$f$と関数$g$があって，その合成を$f\binarycompose g$と書くとき$$(f\binarycompose g)x=f(gx)$$である．
関数合成の演算子$\binarycompose$は関数適用よりも優先順位が高く，$(f\binarycompose g)x$は単に$f\binarycompose g\,x$と書いても良い．
この記法は括弧の数を減らすためにしばしば用いられる．

関数合成演算子とは逆に，優先順位の低い関数適用演算子も考えておくと括弧の数を減らすのに便利である．
関数適用演算子$\binaryapply$を次のように定義しておく．
$$f\binaryapply gx=f(gx)$$
演算子$\binaryapply$の優先順位は足し算演算子よりも低いものとする．
よって$f(x+1)$は$f\binaryapply x+1$と書くこともできる．

\section{条件式}

条件式とはスペシャルバージョンやガードを一般化したもので，
$$fx=\keywordif x\binaryeq0\keywordthen0\keywordelse 1+x$$
のように$\keywordif$節，$\keywordthen$節，及び$\keywordelse$節からなるものである．
$\keywordif$節の中身は真理値を返す関数であれば良いので，関数$p$を$$p=(\equiv)0$$としておき，$$fx=\keywordif px\keywordthen0\keywordelse 1+x$$と書く方法もしばしば用いられる．

\chapter{型と型クラス}

\section{型}

型とは変数が取りうる値に与えた制約のことである．
数学者がよく扱う型は論理型($\mathsetname{B}$)，整数型($\mathsetname{Z}$)，実数型($\mathsetname{R}$)といったところであろう．
ただし数学者たちは型ではなく集合と呼ぶ．
括弧内に示した記号は数学者たちが慣用的に用いているものである．

我々は計算機での実装を考慮して，数学者たちとは若干異なる型と表記方法を扱うことにする．
まず論理型($\mathsetname{B}$)はそのまま論理型として$\typebool$で表す．

計算機にとって都合の良い整数の範囲を考慮した整数型を$\typeint$で表す．
計算機にとって都合の良い整数の範囲とは，例えば64ビット計算機の場合$-2^{32}$から$2^{32}-1$までの範囲のことである．

計算機は残念ながら無限精度の実数を扱えない．
そこで標準精度の浮動小数点数を表す型を$\typefloat$で表す．

もう一つ，計算機ならではの型を導入しておこう．
それは$\typeint$とよく似ているが，特別に文字を扱うために考えられた型$\typechar$である．
文字といってもその中身は整数である．
整数ではあるが，わざわざ別な型とするのには理由がある．
歴史的には文字は小さな整数として表現されることが多かったため，また計算機のメモリが高価であったため，文字を扱うための専用の型はもっぱらメモリの節約のために存在した．
現在では，文字が数値にエンコードされる方式がより複雑になってきたために，文字を通常の数値と区別するために特別な型が容易さてれいるのである．


\section{関数の型}

関数にも型がある．
例えば整数引数を一つ取り，整数を返す関数$f$は$$f\istypeof\morph{\typeint}{\typeint}$$という型を持つ．

整数引数を二つ取り，整数を返す関数$f'$は$$f'\istypeof\mmorph{\typeint}{\typeint}{\typeint}$$という型を持つ．
これは$$f'\istypeof\mmorphwithparenthesis{\typeint}{\typeint}{\typeint}$$と同じ意味である．

\begin{table}
\caption{モノイド}
\label{tab:monoids}
\begin{center}
\begin{tabular}{||c||c|c||}
\hline
型クラス
    &\multicolumn{2}{|c||}{$\typeclassmonoid$}\\
\hline\hline
型$\setminus$要素と演算子
    &$\identity$
    &$\mathbinaryop$\\
\hline
$\typechar$
    &---
    &---\\
\hline
$\typebool$
    &$\constantfalse$
    &$\binaryor$\\
\hline
$\typebool$
    &$\constanttrue$
    &$\binaryand$\\
\hline
$\typeint$
    &$0$
    &$\binaryadd$\\
\hline
$\typeint$
    &$1$
    &$\binarymultiply$\\
\hline
$\typefloat$
    &$0$
    &$\binaryadd$\\
\hline
$\typefloat$
    &$1$
    &$\binarymultiply$\\
\hline
\end{tabular}
\end{center}
\end{table}

\section{型クラス}

$\mathtriple{\typeint}{+}{0}$はモノイドである．
同様に $\mathtriple{\typeint}{*}{1}$, $\mathtriple{\typefloat}{+}{0}$, $\mathtriple{\typefloat}{*}{1}$, $\mathtriple{\typebool}{\binaryor}{\constantfalse}$, $\mathtriple{\typebool}{\binaryand}{\constanttrue}$ もモノイドである．
そこで，任意の型$\typename{a}$について，組み合わせ$\mathtriple{\typename{a}}{\mathbinaryop}{\identity}$がモノイドである場合には$$\mathtriple{\typename{a}}{\mathbinaryop}{\identity}\isclassof\typeclassmonoid$$と書くことにする．
二項演算子，単位元が自明な場合は簡略化して$$\typename{a}\isclassof\typeclassmonoid$$と書くことにする．

このような型をより抽象化した型のようなものを型クラスと呼ぶ．
モノイドは型クラスの例である．
表\ref{tab:monoids}に型と対応するモノイドの単位元，演算子の一覧を示す．

もっと身近な型クラスもある．
例えば，型$\typename{a}$の変数どうしの間で等値性が定義されている場合，その型は型クラス$\typeclasseq$に属することになる．
型クラス$\typeclasseq$に属する型は等値演算子$\binaryeq$を提供する．

型$\typename{a}$の変数どうしの間で大小関係が定義されている場合，かつその型が型クラス$\typeclasseq$に属する場合，その型は型クラス$\typeclassord$にも属する．
型クラス$\typeclassord$に属する型は比較演算子$\binaryl,\binaryle,\binaryge,\binaryg$を提供する．

型$\typename{a}$の変数どうしの間で四則演算関係が定義されている場合，かつその型が型クラス$\typeclasseq$に属する場合，その型は型クラス$\typeclassnum$にも属する．
型クラス$\typeclassnum$に属する型は比較演算子$\binaryadd,\binarysub,\binarymultiply,\binarydivide$を提供する．

型$\typename{a}$が型クラス$\typeclassord$及び型クラス$\typeclassnum$に属しているとき，かつそのときに限り，型$\typename{a}$は型クラス$\typeclassreal$にも属する．

型$\typename{a}$の変数について，一つ小さい値を返す関数$\functionpred$と一つ大きい値を返す関数$\functionsucc$が定義されているとき，かつそのときに限り，型$\typename{a}$は型クラス$\typeclassenum$に属する．

型$\typename{a}$が型クラス$\typeclassreal$及び型クラス$\typeclassenum$に属しているとき，かつそのときに限り，型$\typename{a}$は型クラス$\typeclassintegral$にも属する．

これらの関係を表にまとめたものが表\ref{tab:type-and-typeclass}である．

\begin{table*}[tbp]
\caption{型と型クラス}
\label{tab:type-and-typeclass}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c|c|c|c|c|c|c||}
\hline
\multirow{4}{*}{型クラス}
    &\multicolumn{12}{|c||}{$\typeclassintegral$}\\
\cline{2-13}
\multirow{3}{*}{}
    &\multicolumn{10}{|c|}{$\typeclassreal$}
    &\multicolumn{2}{|c||}{$\typeclassenum$}\\
\cline{2-11}
\multirow{2}{*}{}
    &\multicolumn{5}{|c|}{$\typeclassord$}
    &\multicolumn{5}{|c|}{$\typeclassnum$}
    &\multicolumn{2}{|c||}{ }\\
\cline{2-2}\cline{7-7}
{ }
    &$\typeclasseq$
    &\multicolumn{4}{|c|}{ }
    &$\typeclasseq$
    &\multicolumn{4}{|c|}{ }
    &\multicolumn{2}{|c||}{ }\\
\hline\hline
型$\setminus$演算子
    &$\binaryeq$
    &$\binaryl$
    &$\binaryle$
    &$\binaryge$
    &$\binaryg$
    &$\binaryeq$
    &$\binaryadd$
    &$\binarysub$
    &$\binarymultiply$
    &$\binarydivide$
    &$\functionpred$
    &$\functionsucc$\\
\hline
$\typechar$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---
    &---
    &---
    &$\checkmark$
    &$\checkmark$\\
\hline
$\typebool$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---
    &---
    &---
    &$\checkmark$
    &$\checkmark$\\
\hline
$\typeint$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$\\
\hline
$\typefloat$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &$\checkmark$
    &---
    &---\\
\hline
\end{tabular}
\end{center}
\end{table*}

\chapter{コンテナ}

\section{リスト}

同じ型の値を一列に並べたものはリストである．
例えば$0$から始まり$9$まで続く整数のリストは$\listtype{0,1,2,3,4,5,6,7,8,9}$と書く．
等差数列に限って，簡略化した書き方が許される．
$0$から$9$までのリストは$\listtype{0,1\rangedots9}$と書いても良い．

より高度なリスト，例えば$0$から$9$までの平方数のリストは$$\listtype{x^2\guard{x\isin\listtype{0,1\rangedots9}}}$$のようにガードを用いて書く．
ここに右辺のリストから一つずつ要素を取り出して左辺に代入する演算子$\isin$を用いた．

ガードの中の式は複数あっても良い．
例えば$$\listtype{x+y\guard{x\isin\listtype{0,1\rangedots9}\guardcomma y\isin\listtype{0,1\rangedots5}\guardcomma x+y\binaryg3}}$$は$0\le x\le 10$かつ$0\le y\le 5$の範囲で$x+y>3$となる$x$及び$y$から$x+y$を並べたリストである．

リストは結合できる．例えばリスト$l$とリスト$m$を結合したリストは$$l\binarylistappend m$$で得られる．

リストは無限個の要素を持っても良い．
例えば自然数全体を表すリスト$n$は$$n=[1,2\infinitydots]$$のように定義して良い．

空リストは$\constantempty$で表す．

型$\typename{a}$のリストの型は$\listtype{\typename{a}}$で表す．
ある型を包み込んだ別の型を一般にコンテナ型と呼ぶ．

\section{畳み込み}

我々はよくリストの総和を表現するためにシグマ記号($\sum$)を使う．
リスト$\listtype{x_0,x_1\rangedots x_n}$の総和を$$\sum\listtype{x_0,x_1\rangedots x_n}=x_0+x_1+\dotsb+x_n$$とするようなシグマ記号である．
この表現を一般化してみよう．
リスト$\listtype{x_0,x_1\rangedots x_n}$が与えられたとき，$$\mathfold^\mathbinaryop_a\listtype{x_0,x_1\rangedots x_n}=a\mathbinaryop x_0\mathbinaryop x_1\mathbinaryop\dotsb\mathbinaryop x_n$$であると定義する．
この新しい記号$\mathfold$は畳み込み演算子と呼ばれる．
変数$a$はアキュムレータと呼ぶ．
アキュムレータは右側の引数が空であった場合のデフォルト値と考えても良い．

リストの総和をとる演算子$\sum$は$$\sum=\mathfold^+_0$$とすれば得られる．
同じようにリストの要素のすべての積をとる演算子$\prod$は$$\prod=\mathfold^\binarymultiply_1$$とすれば得られる．

畳み込み演算子は第1（上）引数に$\typename{a}$型と$\typename{b}$型の引数を取り$\typename{a}$型の戻り値を返す二項演算子，第2（下）引数に$\typename{a}$型，第3（右）引数に$\typename{b}$型のリストすなわち$\listtype{\typename{b}}$型を取り，$\typename{a}$型の値を返す．
従って畳み込み演算子の型は$$\mathfold\istypeof\mmmorph{(\mmorph{\typename{a}}{\typename{b}}{\typename{a}})}{\typename{a}}{\listtype{\typename{b}}}{\typename{a}}$$と定義できる．

畳み込み演算子には次のようなもう一つのバリエーションがある．
$$\mathfoldright^\mathbinaryop_a\listtype{x_0,x_1\rangedots x_n}=\left(x_0\mathbinaryop\left(x_1\mathbinaryop\dotsb\mathbinaryop\left(x_n\mathbinaryop a\right)\right)\right)$$
これは右畳み込みと呼ばれる演算子である．

\section{マップ}

リストの各要素に決まった関数を適用したい場合がある．
引数として関数$f$とリスト$\listtype{x_0,x_1\rangedots x_n}$を取り，戻り値として$\listtype{fx_0,fx_1\rangedots fx_n}$を返す演算子$\binarylistfunctormap$を考えよう．
このとき$$f\binarylistfunctormap\listtype{x_0,x_1\rangedots x_n}=\listtype{fx_0,fx_1\rangedots fx_n}$$であると定義する．
% リストのマップ演算子と呼ぶ$\mapfunc_\text{list}$は$$\mapfunc\nolimits_\text{list}::(\typename{a}\rightarrow\typename{b})\rightarrow\listtype{\typename{a}}\rightarrow\listtype{\typename{b}}$$という型を持つ．



\chapter{コンテナの高度な話題}


\section{Maybe}

整数$x$を$0$で除算することはエラーである．
しかし除算の度にエラーが起こったかどうか調べるのは面倒であるし，記述も煩雑になってしまう．
プログラマはよくこういう場合に「例外」という機構を用いるが，数学に例外は持ち込みたくない．
そこで変数$x$が正しく計算されたかもしれないし，されていないかもしれないということを，特別な記号$\maybetype{x}$で表しておこう．
ここで変数$\maybetype{x}$が取り得る値は正しく計算された値$x$か，あるいはエラーを表す値$\constantnothing$である．

この変数$\maybetype{x}$はもはや整数型とは言えない．
そこでこの$\maybetype{x}$の型を$\maybetype{\typeint}$と表して「きっと整数」型と呼ぶことにしよう．
英語では ``maybe integer'' と呼ぶ．

変数$x$が一度$0$除算の危険性に汚染された場合，その後ずっと$\maybetype{x}$と印をつけられなければならない．
このきっと整数$\maybetype{x}$に対して整数を引数にとる関数$f$を適用させるには，何らかの関数マップ演算子が必要である．
そこできっと整数の中身に直接関数を適用する演算子を$\binarymaybefunctormap$としよう．
具体的には$$f\binarymaybefunctormap\maybetype{x}$$のようにして関数$f$を変数$\maybetype{x}$に適用させる．
その結果はまた$\maybetype{\typeint}$型である．
従って，結果を受け取る変数も$\maybetype{\typeint}$でなければならず，それを忘れないように印を付けておかねばならない．
例えば$$\maybetype{y}=f\binarymaybefunctormap\maybetype{x}$$のように書くことになるであろう．


\section{コンテナの型クラスと種}

\section{リストの実装}

ここでリストの実装について若干述べておかねばならない．
紙上ではリストは自由に考えられるが，計算機上ではそれほど自由ではないからである．
ここではリストはLISPにおけるリストと同じ構造を持つものとする．
LISPにおけるリストとは要素$\specialwordfirst$と要素$\specialwordrest$からなるペアの集合である．
要素$\specialwordfirst$がリストの要素を持ち，要素$\specialwordrest$が次のペアを参照する．
リストの最後のペアの$\specialwordrest$は空リストを参照する．

これらのペアはタプルで実装したいところだが，参照，逆参照の煩雑さを避けるために，リストのための特別な表現$$\specialwordfirst\binaryconcat\specialwordrest$$を用い，第2要素である$\specialwordrest$はリスト型であるとする．
演算子$\binaryconcat$は結合演算子と呼ぶ．

要素$\specialwordrest$はリスト（または空リスト）であるから，一般にリストは次のように展開できることになる．
\begin{align*}
\listtype{x_0,x_1,x_2\rangedots x_n}&=x_0\binaryconcat\listtype{x_1,x_2\rangedots x_n}\\
&=x_0\binaryconcat x_1\binaryconcat\listtype{x_2\rangedots x_n}\\
&=x_0\binaryconcat x_1\binaryconcat x_2\binaryconcat\dotsb\binaryconcat x_n\binaryconcat\constantempty
\end{align*}
結合演算子$\binaryconcat$は右結合する．
すなわち$$x_0\binaryconcat x_1\binaryconcat x_2=x_0\binaryconcat(x_1\binaryconcat x_2)$$である．


\chapter{関手}

\section{関手}

\section{アプリカティブ関手}

\section{関数と関手の関係}

\chapter{モナド}

\section{アプリカティブ関手の拡張}

\section{モナド則}

\section{モノイドなモナド}


\begin{table*}
\begin{center}
\begin{tabular}{||c||c|c|c|c|c|c|c||}
\hline
\multirow{4}{*}{型クラス}
    &\multicolumn{7}{|c||}{$\typeclassmonadplus$}\\
\cline{2-8}
\multirow{3}{*}{}
    &\multicolumn{5}{|c|}{$\typeclassmonad$}
    &\multicolumn{2}{|c||}{$\typeclassmonoid$}\\
\cline{2-5}
\multirow{2}{*}{}
    &\multicolumn{4}{|c|}{$\typeclassapplicative$}
    &
    &\multicolumn{2}{|c||}{ }\\
\cline{2-3}
{ }
    &\multicolumn{2}{|c|}{$\typeclassfunctor$}
    &\multicolumn{2}{|c|}{ }
    &
    &\multicolumn{2}{|c||}{ }\\
\hline\hline
型$\setminus$要素と演算子
    &$\identityfunctor$
    &$\binaryfunctormap$
    &$\applicativetype{x}$
    &$\binaryapplicativemap$
    &$\binarymonadmap$
    &$\identity$
    &$\mathbinaryop$\\
\hline
リスト
    &$\constantempty$
    &$\binarylistfunctormap$
    &$\listtype{x}$
    &$\binarylistapplicativemap$
    &$\binarylistmonadmap$
    &$\constantempty$
    &$\binarylistappend$\\
\hline
Maybe
    &$\constantnothing$
    &$\binarymaybefunctormap$
    &$\maybetype{x}$
    &$\binarymaybeapplicativemap$
    &$\binarymaybemonadmap$
    &$\constantnothing$
    &$\binarymaybeappend$\\
\hline
関数
    &$\identityfunction$
    &$\binaryfunctionfunctormap$
    &$\functyontype{x}$
    &$\binaryfunctionapplicativemap$
    &$\binaryfunctionmonadmap$
    &$\identityfunction$
    &$\binarycompose$\\
\hline
Int（参考）
    &
    &
    &
    &
    &
    &$0$
    &$\binaryadd$\\
\hline
\end{tabular}
\end{center}
\end{table*}

\part{モナドから見る世界}

\chapter{IO}

\chapter{状態}

\part{圏とモナド}


\chapter{---}



% ----------

% Literals
\newcommand{\charlit}[1]{\texttt{#1}}

% Operators and symbols
\newcommand{\applicativefunc}{\bigotimes} % <*>
\newcommand{\bind}{\rightrightarrows} % >>=
\newcommand{\comp}{\bullet} % .
\newcommand{\concretetype}{\mathbf\ast} % *
\newcommand{\defeq}{\xleftarrow{\text{def}}}
\newcommand{\dollar}{\mathop{\$}} % $
\newcommand{\filterfunc}{\bigcap} % filter
\newcommand{\foldfunc}{\bigcup} % foldl
\newcommand{\foldrightfunc}{\bigsqcup} % foldr
\newcommand{\guard}[1]{\mathop{\mid_{{#1}}}}
\newcommand{\haskelllambda}{\backslash}
\newcommand{\lambdaperiod}{\;.\;}
\newcommand{\listappend}{\mathop{++}}
\newcommand{\mapfunc}{\bigodot} % fmap
\newcommand{\monadfunc}{\bigoplus}
\newcommand{\monadjoin}{\dag}
\newcommand{\nullelem}{\emptyset}
\newcommand{\pure}{\bigstar} % pure
\newcommand{\typealpha}{\boldsymbol{\alpha}}
\newcommand{\unit}{\star} % return

% Functions
\newcommand{\concat}{\mathop{\text{concat}}}

% Booleans
\newcommand{\booleankeyword}[1]{\text{#1}}
\newcommand{\falsevalue}{\text{F}}
\newcommand{\truevalue}{\text{T}}

% Typenames
\newcommand{\typename}[1]{\bm{#1}}
\newcommand{\booleantype}{\typename{B}}
\newcommand{\integertype}{\typename{Z}}
\newcommand{\realtype}{\typename{R}}

% Typeclass names
\newcommand{\typeclassname}[1]{\mathbb{#1}}
\newcommand{\enumtypeclass}{\typeclassname{E}}
\newcommand{\eqtypeclass}{\typeclassname{Q}}
\newcommand{\functortypeclass}{\typeclassname{F}}
\newcommand{\inttypeclass}{\typeclassname{I}}
\newcommand{\numtypeclass}{\typeclassname{N}}
\newcommand{\ordtypeclass}{\typeclassname{O}}

% Fanctor typeclasses
\newcommand{\fanctortypeclassname}[1]{\mathcal{#1}}

% Functors
\newcommand{\function}[1]{\left\langle#1\right\rangle}
\newcommand{\generalcontainer}[1]{\left\langle\!\left\langle#1\right\rangle\!\right\rangle}
\newcommand{\listtype}[1]{\left[#1\right]}
\newcommand{\maybe}[1]{\left\{#1\right\}}
\newcommand{\monad}[1]{\left[\!\left[#1\right]\!\right]}

% Functor names
\newcommand{\functor}[1]{\mathop{\textbf{#1}}}
\newcommand{\functionfunctor}{\mathop{\functor{Function}}}
\newcommand{\listfunctor}{\mathop{\functor{List}}}
\newcommand{\maybefunctor}{\mathop{\functor{Maybe}}}
\newcommand{\monadfunctor}{\mathop{\functor{Monad}}}

% Keywords
\newcommand{\haskellkeyword}[1]{\textbf{#1}}
\newcommand{\letinprogram}{\haskellkeyword{let}}
\newcommand{\otherwise}{\haskellkeyword{otherwise}}
\newcommand{\where}{\haskellkeyword{where}}

% Math keywords
\newcommand{\mathkeyword}[1]{\textbf{#1}}
\newcommand{\mathelse}{\mathop{\mathkeyword{else}}}
\newcommand{\mathif}{\mathop{\mathkeyword{if}}}
\newcommand{\maththen}{\mathop{\mathkeyword{then}}}

% Special keywords
\newcommand{\specialkeyword}[1]{\textsf{#1}}
\newcommand{\firstelem}{\specialkeyword{First}}
\newcommand{\identity}{\specialkeyword{id}}
\newcommand{\nothing}{\specialkeyword{Nothing}}
\newcommand{\restelems}{\specialkeyword{Rest}}

\chapter{思考の道具*}

「言語は思考を規定する」という．
実際プログラマは思考の道具としてプログラミング言語をよく用いるし，そのプログラマの好みのプログラミング言語の影響を強く受ける．
手続き的に問題を解くのが好きなプログラマもいれば，宣言的に問題を解くのが好きなプログラマもいる．
問題の複雑さを「オブジェクト」というプログラム単位に押し込むのが好きなプログラマもいれば，「クロージャ」という別のプログラム単位に押し込むのが好きなプログラマもいる．

一方で，古代ギリシャから連綿と続く数学者たちは，数学という言葉で問題を考えることを好む．
数学はわずかな方言の違いを無視すれば驚くほど統一された言語である．

プログラマが使う言葉すなわちプログラミング言語と，数学者たちが使う語はだいたい乖離しており，その両者の歩み寄りは虚しいものであることが多かった．
ここで言いたいのはプログラマが限られた文字セットしか使えないとか，スクリーン上の行という制約に縛られているとか，そのような表面的なことではない．
そうではなく，思考の様式が，プログラミング「文化」と数学「文化」で異なるという意味である．

プログラミング文化と数学文化の大きな違いの一つは，リアルタイムに起こるイベントの取り扱い方法である．
プログラマはほとんどいつもリアルタイムに起こるイベントに対応しないといけない．
一方で，数学者たちはそのようなイベントを「不純なもの」として理論から取り除く．
例えば変数$x$があるときは$0$だがあるときは$1$であるというのは，甚だ不純なものとして数学者の間では認識されるものだ．

\chapter{数学的準備*}

この章ではいま後本書で登場する数学的概念の記法を決めておく．

\section{定数・論理定数・文字定数}

定数はアラビア数字で記述するものとする．
定数が負の場合はマイナス記号($-$)を用いる．
定数が実数の場合は小数点($.$)を用いる場合がある．
例えば $-1, 0, 1.2$ は定数である．

論理定数とは真偽値を表す定数で，真($\truevalue$)及び偽($\falsevalue$)の2種類のみがある．

文字定数とはコード化された文字のことである．
文字コードを定数として扱うといささか読みづらくなるため，該当する文字をシングルクォートで囲むことにする．
例えば `\charlit{A}', `\charlit{b}', `\charlit{.}' は文字定数である．

\section{変数}

変数はアルファベット（ローマ文字またはギリシア文字）の小文字1文字で表すことにする．
変数名には任意個のプライム記号($'$)をつけても良いし，添え字をつけても良いこととする．
変数名はイタリック体で書く．

変数は代入演算子($=$)によって定数や変数，それらを複合した式の値を代入できる．
例えば $$x=1, y=x$$ は代入の例である．

\section{演算子}

演算子には数学記号を割り当てる．


\section{関数}

関数も変数と同じようにアルファベット（ローマ文字またはギリシア文字）の小文字1文字で表すことにする．
関数名には任意個のプライム記号($'$)をつけても良いし，添え字をつけても良いこととする．
三角関数のように十分な知名度を持つ関数や，それに匹敵する汎用的な関数は長い名前を持っても良い．
変数名や関数名はイタリック体で書くが，長い関数名はローマン体で書く．


二項演算子とは2引数関数の特別な場合であると考えてよい．
関数$r$を次のように中置する記法を定義しておく．
$$x\,{}^\backprime r^\backprime\,y\defeq rxy$$
バックプライム記号(${}^\backprime$)を使っているのはプライム記号($'$)と区別するためである．

既存の二項演算子$\circ$は次のようにして通常の関数として使えるものとする．
$$(\circ)xy\defeq x\circ y$$

\section{ラムダ式}

\section{関数定義}

\section{条件式}

\section{型}

\section{リスト}


\section{タプル}

複数の変数を束ねたものをタプルと呼ぶ．
変数$x$と変数$y$からなるタプルは$(x,y)$と書く．
いま$$t=(x,y)$$としたとき，タプルの中身を取り出すには$$(t_1,t_2)=t$$のようにしてパタンマッチングを用いる．

\section{リストの実装}


\chapter{型・型クラス・種*}

\section{関数の型}

$$f::\integertype\rightarrow\integertype$$

関数$f$が引数として整数を2個取り1個の整数を返すとき，その型は$$\integertype\rightarrow\integertype\rightarrow\integertype$$である．
型の式は右結合するものとする．
従って上式は$$\integertype\rightarrow\left(\integertype\rightarrow\integertype\right)$$と読む．
これは関数$f$が最初の引数を1個受け取り，$(\integertype\rightarrow\integertype)$型の関数を返していることを考えると理にかなっている表現である．

\section{型クラス}

$$\integertype\subset\eqtypeclass$$

$$\integertype\subset\ordtypeclass$$

$$\integertype\subset\enumtypeclass$$


\section{種}

$$\integertype::\concretetype$$

$$\maybe{\integertype}::\concretetype$$

$$\maybe{{}}::\concretetype\mapsto\concretetype$$

\chapter{マップ*}

Map.
$$f\odot[x_0,x_1\dotsb x_n]=[fx_0,fx_1\dotsb fx_n]$$
$$f\odot\{x\}=\{fx\}$$

Applicative map (fmap).
\begin{multline*}
[f_0,f_1\dotsb f_n]\otimes[x_0,x_1\dotsb x_{n'}]\\
=[f_0x_0,f_0x_1\dotsb f_0x_{n'},f_1x_0,f_1x_1\dotsb]
\end{multline*}
$$\{f\}\otimes\{x\}=\{fx\}$$
$$f\otimes g=f\comp g$$

Monadic map (bind).
$$f\oplus\monad{x}=\monad{fx}$$


\section{畳み込み}


\section{右畳み込み}


\section{フィルタ}

$$\filterfunc^p\listtype{x_0,x_1\dotsb x_n}\defeq\listtype{x\guard{x\in\listtype{x_0,x_1\dotsb x_n}\wedge px\equiv\truevalue}}$$

\section{マップ}



\section{一般化マップ}

マップ演算子の概念を一般化してみよう．
一般のマップ演算子はあるコンテナの中身に関数適用を行い，元のコンテナと同じコンテナを返す演算子であると考えることができる．
そこで，いま後マップ演算子の第2（右）引数は一般のコンテナであるとする．
型$\typename{a}$をコンテナに入れた型を一般に$\generalcontainer{\typename{a}}$と書くことにすると，一般化されたマップ演算子$\mapfunc$は$$\mapfunc::(\typename{a}\rightarrow\typename{b})\rightarrow\generalcontainer{\typename{a}}\rightarrow\generalcontainer{\typename{b}}$$という型を持つ．

マップはリストのマップのより汎用的なバージョンである．
つまり我々は$\mapfunc_\text{list}$を使わずに，最初から$\mapfunc$を使えば良いのである．

一般化マップの型は$\typename{a}\rightarrow\typename{b}$をとり$\generalcontainer{\typename{a}}\rightarrow\generalcontainer{\typename{b}}$を返しているようにも見える．
それゆえ一般化マップを用いることを関数の「持ち上げ(lifting)」と呼ぶのである．

\section{Maybe}



\section{関手}

ある型から，マップの第2（右）引数になれる型を作る射（一般化された写像）のことを関手と呼ぶ．
例えば型$\typename{a}$からリスト型$[\typename{a}]$を作る射$\listfunctor$ただし$$\listfunctor\typename{a}\defeq\typename{a}\mapsto\listtype{\typename{a}}$$は関手である．
また型$\typename{a}$から ``maybe a'' 型$\maybe{\typename{a}}$を作る射$\maybefunctor$ただし$$\maybefunctor\typename{a}\defeq\typename{a}\mapsto\maybe{\typename{a}}$$も関手である．

関数合成もまた関手の例である．
いま型$\typename{a}$を型$\function{\typename{a}}$に変換する関手$$\functionfunctor\typename{a}\defeq\typename{a}\mapsto\function{\typename{a}}$$を考える．
型$\function{\typename{a}}$は$$\function{\typename{a}}\defeq\typename{t}\rightarrow\typename{a}$$であるとする．
ここに型$\typename{t}$は任意の型である．
関数$f$が$$f::\typename{a}\rightarrow\typename{b}$$であり，関数$g$が$$g::\typename{t}\rightarrow\typename{a}$$であるとき，その合成$f\comp g$は$$f\comp g::\typename{t}\rightarrow\typename{b}$$でなければならない．
ここで型$\function{\typename{a}}$の定義式を用いると
\begin{align*}
\function{\typename{a}}&\defeq\typename{t}\rightarrow\typename{a}\\
\function{\typename{b}}&\defeq\typename{t}\rightarrow\typename{b}
\end{align*}
であるから，関数$g$並びに合成関数$f\comp g$は
\begin{align*}
g&::\function{\typename{a}}\\
f\comp g&::\function{\typename{b}}
\end{align*}
という型を持つことがわかる．
今一度マップ演算子の型$$\mapfunc::(\typename{a}\rightarrow\typename{b})\rightarrow\generalcontainer{\typename{a}}\rightarrow\generalcontainer{\typename{b}}$$を思い出してみよう．
これは関数合成にもそのまま使えることがわかる．
実際$$f\comp g\defeq\mapfunc^fg$$として関数合成は定義できる．

一般に$$\typename{a}\mapsto\generalcontainer{\typename{a}}$$という風に型$\typename{a}$をコンテナに入れて型$\generalcontainer{\typename{a}}$を作る射を関手と呼ぶ．

関手全体の型クラスを$\functortypeclass$で表す．
これまでに見た関手は$$\functionfunctor,\listfunctor,\maybefunctor::\functortypeclass$$である．


\section{関手が従う規則}

\begin{align}
\mapfunc^\identity&=\identity\\
\mapfunc^{\functor{f}\comp\functor{g}}&\equiv\mapfunc^{\functor{f}}\comp\mapfunc^{\functor{g}}
\end{align}

\section{アプリカティブ関手}

一般化マップとは$$\mapfunc::(\typename{a}\rightarrow\typename{b})\rightarrow\generalcontainer{\typename{a}}\rightarrow\generalcontainer{\typename{b}}$$のことであった．
一般化マップの第1引数である1引数関数がコンテナに入っている場合を想定しよう．
そうすると次のような「一般化された」マップ$\applicativefunc$を考えることができる．
$$\applicativefunc::\generalcontainer{(\typename{a}\rightarrow\typename{b})}\rightarrow\generalcontainer{\typename{a}}\rightarrow\generalcontainer{\typename{b}}$$
実際の使い方は$$\listtype{y_0,y_1\dotsb y_{n''}}=\applicativefunc^{\listtype{f_0,f_1\dotsb f_n}}\listtype{x_0,x_1\dotsb x_{n'}}$$のようになるであろう．

一般化マップ演算子$\applicativefunc$と次のピュア演算子$\pure$があれば，リストもMaybeも同じ枠組みで考えることができる．
ピュア演算子$\pure$は$$\pure::\typename{a}\rightarrow\generalcontainer{\typename{a}}$$という型を持つ．
関手の型$\typename{a}\mapsto\generalcontainer{\typename{a}}$とは矢印が違う事に注意しよう．
ピュア演算子は型を型へ変換するのではなく，変数をコンテナに入れられた別な変数へと変換する．

型$\generalcontainer{\typename{a}}$の変数をアプリカティブと呼ぶ．

リストの場合，ピュア演算子と一般化マップは次のように実装することができる．
\begin{align*}
\pure x&=\listtype{x}\\
\applicativefunc^{\listtype{f_0,f_1\dotsb f_n}}\listtype{x_0,x_1\dotsb x_{n'}}&=\listtype{fx\guard{f\in\listtype{f_0,f_1\dotsb f_n},x\in\listtype{x_0,x_1\dotsb x_{n'}}}}
\end{align*}

Maybeの場合は次のようにピュア演算子と一般化マップを実装することができる．
\begin{align*}
\pure x&=\maybe{x}\\
\applicativefunc^{\nothing}\maybe{x}&=\nothing\\
\applicativefunc^{\maybe{f}}\maybe{x}&=\mapfunc^f\maybe{x}
\end{align*}

% IO: skip.

% Function:
% \begin{align*}
% \pure x&=\haskelllambda y\rightarrow x\\
% \applicativefunc^fg&=\haskelllambda x\rightarrow fx(gx)
% \end{align*}

アプリカティブが従う規則

$$\applicativefunc^{\pure f}x\equiv\mapfunc^fx$$

\section{モナド}

ある型$\typename{a}$について，特殊なコンテナ$\monad{\typename{a}}$に入れられた型を想像してほしい．
この型にもマップ演算子$\monadfunc$があり$$\monadfunc::\left(\typename{a}\rightarrow\monad{\typename{b}}\right)\rightarrow\monad{\typename{a}}\rightarrow{\monad{\typename{b}}}$$という型を持っているとする．
このマップ演算子は第1（上）引数として型$\typename{a}$をとりコンテナに収めた型$\monad{\typename{b}}$を返す関数を，第2（右）引数としてコンテナに収められた型$\monad{\typename{a}}$をとり，戻り値としてコンテナに収められた型$\monad{\typename{b}}$を返す．

型$\typename{a}$から型$\monad{\typename{a}}$を作り出す関手を$\monadfunctor$とし$$\monadfunctor\typename{a}=\typename{a}\mapsto\monad{\typename{a}}$$とする．
$\typename{a}$型の変数から$\monad{\typename{a}}$型の変数を作る演算子を$\unit$とし，ユニット演算子と呼ぶ．

$\monad{\typename{a}}$型の変数をモナドと呼ぶ．
モナドはアプリカティブとよく似ているが，少し異なることに注意しよう．
モナドの応用範囲は極めて広く，それゆえ基本的な関手と考えられている．

Maybeの方がリストよりも簡単なので，Maybeから説明する．
Maybeの場合は次のような実装となる．
\begin{align*}
\unit x&=\maybe{x}\\
\monadfunc^f\nothing&=\nothing\\
\monadfunc^f\maybe{x}&=fx
\end{align*}
ここに関数$f$は$$f::\typename{a}\rightarrow\monad{\typename{b}}$$であるから，関数適用された値$fx$は$$fx::\monad{\typename{b}}$$という型を持つことに注意しよう．

% ---
% 
% $$\bind\,::\monad{\typename{a}}\rightarrow(\typename{a}\rightarrow\monad{\typename{b}})\rightarrow\monad{\typename{b}}$$
% 
% Maybe:
% \begin{align*}
% \unit x&=\maybe{x}\\
% \nothing\bind f&=\nothing\\
% \maybe{x}\bind f&=fx
% \end{align*}
% 
% ---

リストの場合は次のような実装となる．
\begin{align*}
\unit x&=\listtype{x}\\
\monadfunc^f\listtype{x_0,x_1\dotsb x_n}&=\concat\mapfunc^f\listtype{x_0,x_1\dotsb x_n}
\end{align*}
関数$\concat$はリストのリスト$$\listtype{\listtype{x_0,x_1\dotsb x_n},\listtype{y_0,y_1\dotsb y_n}\dotsb}$$をフラットなリスト$$\listtype{x_0,x_1\dotsb x_n,y_0,y_1\dotsb y_n\dotsb}$$へと変換する．

% List:
% \begin{align*}
% \unit x&=\listtype{x}\\
% \listtype{x_0,x_1\dotsb x_n}\bind f&=\concat\mapfunc^f\listtype{x_0,x_1\dotsb x_n}
% \end{align*}

% Function:
% \begin{align*}
% \unit x&=\haskelllambda y\rightarrow x\\
% g\bind f&=\haskelllambda h\rightarrow f(gh)h
% \end{align*}


\section{モナド則}

新しい演算子$\triangleleft$を$$(f\triangleleft g)x\defeq\monadfunc^f(gx)$$として導入する．
モナドは次の規則に従う．
\begin{align}
f\triangleleft\unit&=f\\
\unit\triangleleft f&=f\\
(f\triangleleft g)\triangleleft h&=f\triangleleft(g\triangleleft h)
\end{align}

\section{結合演算子}

「結合演算子($\bind$)」を$$x\bind f\defeq \monadfunc^fx$$のように定義する．

---

$$(f\triangleright g)x\defeq(fx)\bind g$$
\begin{align}
\unit\triangleright f&=f\\
f\triangleright\unit&=f\\
(f\triangleright g)\triangleright h&=f\triangleright(g\triangleright h)
\end{align}

\begin{align}
\unit x\bind f&=fx\\
\monad{x}\bind\unit&=\monad{x}\\
(\monad{x}\bind f)\bind g&=\monad{x}\bind(\haskelllambda x'\rightarrow(fx'\bind g))
\end{align}

Or,
\begin{align}
\monadfunc^f(\unit x)&=fx\\
\monadfunc^\unit\monad{x}&=\monad{x}\\
\monadfunc^g\left(\monadfunc^f\monad{x}\right)&=\monadfunc^{\haskelllamda x'\rightarrow\left(\monadfunc^gfx'\right)}\monad{x}
\end{align}

Memo.
\begin{align*}
\monadjoin\monad{\monad{x}}&\defeq\monad{x}\\
\mapfunc^f\monad{x}&=\monad{x}\bind(\unit\comp f)\\
\monadjoin\monad{x}&=\monad{x}\bind\identity\\
\monad{x}\bind f&\defeq\monadjoin\mapfunc^f\monad{x}\\
\unit\comp f&\defeq\mapfunc^f\comp\unit\\
\monadjoin\comp\mapfunc^\monadjoin&\defeq\monadjoin\comp\monadjoin\\
\monadjoin\comp\mapfunc^\unit&\defeq\monadjoin\comp\unit=\identity\\
\monadjoin\comp\mapfunc^{\mapfunc^f}&\defeq\mapfunc^f\comp\monadjoin
\end{align*}

\chapter{プログラミング*}

letとwhere.

乱数．


\end{document}
